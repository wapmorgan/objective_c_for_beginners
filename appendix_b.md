# Приложение В. Сводка языка Objective-C

В этом приложении содержится краткий справочник по языку Objective-C в удобном формате. Эта не полный справочник, а скорее неформальное описание средств языка. Тщательно проработайте этот материал после того, как закончите работу с основным текстом книги. Это позволит вам не только закрепить изученный материал, но и лучше понять возможности Objective-C.

Описание основывается на стандарте ANSI С99 (ISO/IEC 9899:1999) с рас-ширениями языка Objective-C. На момент написания этой книги в моей системе Mac OS X vl0.5.5 последняя версия компилятора GNU gcc имела номер 4.0.1.


## Диграфы и идентификаторы
### Символы-диграфы
Следующие двухсимвольные последовательности (диграфы) эквивалентны указанным односимвольным пунктуаторам.

| Диграф | Значение |
|--------|----------|
| <:     | [        |
| :>     | ]        |
| <%     | {        |
| %>     | }        |
| %:     | #        |
| %:%:   | ##       |

### Идентификаторы
Идентификатор в Objectivc-C состоит из последовательности букв (прописных и строчных), имен универсальных символов (см. ниже), цифр и знака подчеркивания. Первый символ идентификатора должен быть буквой, знаком подчеркивания или именем универсального символа. Первые 31 символов идентификатора обязательно будут значащими для внешнего имени, первые 63 символа обязательно будут значащими для внутреннею имени или имени макроса.

#### Имена универсальных символов
Имя универсального символа состоит из символов \и, мосле которых следуют четыре шестнадцатеричных числа, или из символов \U, после которых следуют восемь шестнадцатеричных чисел. Если первый символ идентификатора указан универсальным символом, его значение не может быть символом цифры. Универсальные символы при использовании в именах идентификаторов не могут указывать символ, значение которого меньше А0,6 (в отличие от 241б,401б или 60|6), или символ в диапазоне от D800l6 до DFFF|6 включительно.

Имена универсальных символов можно использовать в именах идентификаторов, символьных константах и символьных строках.

#### Ключевые слова
Приведенные ниже идентификаторы являются ключевыми словами, представляющими специальное значение для компилятора Objective-C.

* _Bool
* _Complex
* Jmaginary
* auto
* break
* bycopy
* byret
* case
* char
* const
* continue
* default
* do
* double
* else
* enum
* extern
* float
* for
* goto
* if
* in
* inline 
* inout
* int
* long
* oneway
* out register
* restrict
* return
* self
* short
* signed
* sizeof
* static
* struct
* super
* switch
* typedef
* union
* unsigned
* void
* volatile
* while

#### Директивы
Директивы компилятора начинаются со знака @ и используются особым образом для работы с классами и обработками, см. таблицу В. I.

Табл. В.1. Директивы компилятора

| Директива                | Описание                                                                                                                            | Пример                                                                                             |
|--------------------------|-------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|
| @"символы"               | Определяет константный строковый объект типа NSSTRING. (Дня смежных строк выполняется конкатенация.)                                | `NSString *url = @"http://www.kochan-wood.com";`                                                   |
| @class с1, с2,...        | Объявляет c1 , с2 ,... как классы.                                                                                                  | `@class Point, Rectangle;`                                                                         |
| @defs (класс)            | Возвращает список структурных переменных для класса.                                                                                | `struct Fract {@defs( Fraction);} *fractPtr; fractPtr = (struct Fract *) [[Fraction alloc] init];` |
| @dynamic имена           | Методы доступа для имен могут предоставляться динамически.                                                                          | `@dynamic drawRect;`                                                                               |
| @encode (тип)            | Строковое кодирование для типа.                                                                                                     | `@encode (int *)`                                                                                  |
| @end                     | Заканчивает секцию interface, секцию implementation или секцию протокола.                                                           | `@end`                                                                                             |
| @implementation          | Начинает секцию implementation,                                                                                                     | `@implementation Fraction`                                                                         |
| @interface               | Начинает секцию interface.                                                                                                          | `@interface Fraction: NSObject <Copying>`                                                          |
| @private                 | Определяет область действия одной или нескольких переменных экземпляра.                                                             | См. «Переменные экземпляра»                                                                        |
| @protected               | Определяет область действия одной или нескольких переменных экземпляра.                                                             |                                                                                                    |
| @public                  | Определяет область действия одной или нескольких переменных экземпляра.                                                             |                                                                                                    |
| @property (список) имена | Объявляет свойства в списке для имен.                                                                                               | `@property (retain, nonatomic)  NSSTHING *name;`                                                   |
| @protocol                | Создает объект типа Protocol для указанного протокола.                                                                              | `@protocol (Copying)]){...} if ([myObj conformsTo: (protocol)`                                     |
| @protocol имя            | Начинает определение протокола для имени.                                                                                           | `@protocol Copying`                                                                                |
| @selector (метод)        | Объект типа SEL для указанного метода.                                                                                              | `if ([myObj respondsTo: @selector(allocF)]) (...)`                                                 |
| @synchronized (объект)   | Начинает блок, который должен выполняться одним потоком. Объект называется взаимоисключающим (mutually exclusive, mutex) семафором. |                                                                                                    |
| @synthesize имена        | Генерирует методы доступа для имен, если они не заданы.                                                                             | `@synthesize name, email;` См. также «Переменные экземпляра»                                       |
| @try                     | Начинает блок для улавливания исключительных ситуаций (исключений).                                                                 | См. «Обработка исключительных ситуаций»                                                            |
| @catch (исключение)      | Начинает блок для обработки исключения.                                                                                             |                                                                                                    |
| @finally                 | Начинает блок, который выполняется в предположении, что предыдущем блоке @try было «инициировано» (throw) исключение.               |                                                                                                    |
| @throw                   | Инициирует исключение.                                                                                                              |                                                                                                    |

#### Предопределенные идентификаторы
В таблице В.2 приводится список идентификаторов, которые имеют специальный смысл в программах на Objective-C.

Табл. В.2. Специальные предопределенные идентификаторы

| Идентификатор | Описание                                                                                                                       |
|---------------|--------------------------------------------------------------------------------------------------------------------------------|
| _cmd          | Локальная переменная, автоматически определяемая в методе, который содержит селектор для этого метода.                         |
| __func__      | Локальная символьная строковая переменная, автоматически определяемая в функции или в методе; содержит имя функции или метода. |
| BOOL          | Булева переменная, обычно со значениями YES и NO.                                                                              |
| Class         | Тип объекта-класса.                                                                                                            |
| id            | Обобщенный тип объекта.                                                                                                        |
| IMP           | Указатель на метод, возвращающий значение типа id.                                                                             |
| nil           | Пустой объект.                                                                                                                 |
| Nil           | Пустой объект-класс.                                                                                                           |
| NO            | Определяется как (BOOL) 0                                                                                                      |
| NSObject      | Корневой объект Foundation, определенный в `< Foundation/NSObject.h>`.                                                         |
| Protocol      | Имя класса для хранения информации о протоколах.                                                                               |
| SEL           | Откомпилированный селектор.                                                                                                    |
| self          | Локальная переменная, автоматически определяемая в методе, которая обозначает получателя сообщения.                            |
| super         | Родительский объект получателя сообщения.                                                                                      |
| YES           | Определяется как (BOOL) 1.                                                                                                     |

## Комментарии
Имеется два способа вставки комментариев в программу. Комментарий может начинаться с двух символов //, и в этом случае любые последующие символы этой строки игнорируются компилятором.

Комментарий может также начинаться с символов /* и заканчиваться символами */• К такой комментарий можно включать любые символы, и он может занимать несколько строк. Комментарий можно использовать в любом месте программы, если для этого есть место. Однако комментарии не допускают вложенности. Это означает, что комментарий всегда заканчивается символами */, даже если до этого встретилось несколько наборов символов /*.

## Константы
### Константы целого типа
Константа целого типа (целая константа) - это состоящая из цифр последова-тельность, перед которой может дополнительно ставиться знак «плюс» или «минус». Если первой цифрой является 0, значит, это восьмеричная константа, и тогда следующие цифры должны быть в диапазоне 0-7. Если первой цифрой является О, и сразу после нее следует буква х (или X), значит, это шестнадцатеричная константа, и последующие цифры должны быть в диапазоне 0-9, a-f (или A-F).

В конце десятичной целой константы можно добавить суффикс I или L, и тогда она становится константой типа long int, если умещается в этот размер, иначе она интерпретируется как long long int. И, наконец, если она не умещается в long long int, она и нтерп ретируется как константа типа unsigned long long int.

В конце десятичной целой константы можно добавить суффикс II или LL, чтобы сделать ее long long int. При добавлении этого суффикса в конец восьмеричной или шестнадцатеричной константы, она интерпретируется сначала как long long int, но если не умещается в этот размер, то получает тип unsigned long long int.

В конце целой константы можно добавить суффикс и ИЛИ U, чтобы сделать ее константой без знака (unsigned). Если она не умещается в размер unsigned int, она интерпретируется как unsigned tong int. Если она превышает также этот размер, то интерпретируется как unsigned tong tong int.

Два суффикса — для unsigned и для tong — можно добавить к целой константе, чтобы она имела тип unsigned tong int. Если константа не умещается в этот тип, она обрабатывается как unsigned long long int.

Два суффикса - для unsigned и для tong long - можно добавить к целой кон-станте, чтобы она имела тип unsigned tong tong int.

Если десятичная целая константа без суффиксов слишком велика, чтобы уместиться в тип signed int, она интерпретируется как long int. Если она слишком велика, чтобы уместиться в тип long int, она интерпретируется как long long int.

Если восьмеричная или шестнадцатеричная целая константа без суффик-сов слишком велика, чтобы уместиться в тип signed int, она интерпретируется как unsigned int. Если она слишком велика, чтобы уместиться в тип unsigned int, она интерпретируется как long int, и если она не умещается в этот тип, то интерпретируется как unsigned long int. Если она не умещается в unsigned tong int, то интерпретируется как long tong int. И, наконец, если она слишком велика для tong long int, то интерпретируется как unsigned tong long int.

### Константы с плавающей точкой
Константа с плавающей точкой состоит из последовательности десятичных цифр, десятичной точки и еще одной последовательности десятичных цифр. Перед значением можно ставить знак «минус» для отрицательных значений. Кроме того, может отсутствовать последовательность цифр до десятичной точки или после нее, но не обе последовательности.

Если в конце константы с плавающей точкой добавлены буква е (или Е) и целое число (с необязательным знаком), константа имеет экспоненциальное представление. Это целое число (порядок) указывает, что значение до буквы е (мантисса) умножается на 10 в степени, равной этому целому числу (например, 1.5е-2 представляет 1.5 X ЮЛ или .015).

Шестнадцатеричная константа с плавающей точкой состоит из ведущих символов Ох или ОХ, после которых следуют одна или несколько десятичных или шестнадцатеричных цифр, затем буква р или Р и затем показатель степени для основания 2 с возможным знаком. Например, ОхЗрЮ представляет значение 3 х 2,с. Константы с плавающей точкой интерпретируются компилятором как значения с двойной точностью (double). Можно добавить суффикс f или F, и тогда константа будет иметь тип float вместо double; можно добавить суффикс I или L, чтобы указать константу типа long double.

### Символьные константы
Один символ, заключенный в апострофы, является символьной константой. Обработка нескольких символов, заключенных в апострофы, определяется ре-ализацией. В символьной константе можно использовать универсальный символ, чтобы указать символ, не входящий в стандартный набор символов.

#### Escape-последовательности
Специальные escape-последовательности распознаются и вводятся с помощью символа «обратный слэш*. Ниже приводятся эти escape-последовательности.

| Символ     | Описание                                         |
|------------|--------------------------------------------------|
| \а         | Звуковой сигнал                                  |
| \b         | Символ Backspace (возврат на одну позицию назад) |
| \f         | Form feed (подача страницы)                      |
| \n         | Переход на новую строку                          |
| \r         | Символ возврата каретки                          |
| \t         | Горизонтальное табулирование                     |
| \v         | Вертикальное табулирование                       |
| \\         | Обратный слэш                                    |
| \"         | Кавычка                                          |
| \'         | Апостроф                                         |
| \?         | Вопросительный знак                              |
| \nnn       | Восьмеричное значение символа                    |
| \unnn      | Имя универсального символа                       |
| \Unnnnnnnn | Имя универсального символа                       |
| \xnn       | Шестнадцатеричное значение символа               |

Для восьмеричного значения символа можно указать от одной до трех восьмеричных цифр. В последних трех случаях используются шестнадцатеричные цифры.

#### Символьные константы из расширенных наборов
Символьная константа из расширенных наборов записывается как L'x'. Такая константа имеет тин wchart, в соответствии с определением в файле <stddef.h>. Константы из расширенных наборов символов - это способ представить сим-вол из набора символов, который не может быть полностью представлен с помощью обычного тина char.

### Константы символьных строк
Последовательность, содержащая нуль или более символов, заключенных в кавычки, представляет константу символьной строки (строковую константу). В эту строку можно включить любой допустимый символ, в том числе любой из показанных выше escape-символов. Компилятор автоматически вставляет нуль- символ ( \0 ) в конце этой строки.

Обычно компилятор создаст указатель на первый символ строки, имеющий тип «указатель на char». Но если строковая константа используется с оператором sizeof для инициализации массива символов или с оператором &, то строковая константа имеет тип «массив элементов типа char».

Константы символьных строк не могут быть изменены программой.

#### Конкатенация символьных строк
Препроцессор автоматически выполняет конкатенацию смежных строковых констант. Строки могут быть любым числом пробелов. Таким образом, три строки
```
"a" "character"
"string"
```
эквивалентны одной строке "a character string" после конкатенации.

#### Многобайтные символы
Для перехода между различными состояниями в символьной строке можно использовать последовательности символов, определенные реализацией, что позволяет включать многобайтные символы.

#### Строковые константы из расширенных наборов
Строковые константы из расширенного набора символов представляются в формате L'...'. Каждая такая константа имеет тип «указатель на wchar_t, где wchar_t определяется в `<stddef.h>`.

#### Объекты константных символьных строк
Для создания объекта константной символьной строки нужно поместить сим-вол @ перед константной символьной строкой. Этот объект имеет типа NSConstantString.

Для смежных объектов константных символьных строк выполняется кон-катенация. Таким образом, три строковых объекта
```
@"а" @" character "
@"string"
```
эквивалентны одному строковому объекту @"а character string"

### Константы перечислимого типа
Идентификатор, который объявлен как значение для перечислимого типа, рассматривается как константа этого типа, но интерпретируется компилятором как тип int.

## Типы и объявления данных
В этом разделе приводится сводка базовых типов данных, производных типов данных, перечислимых типов данных, а также typedef. Здесь также приводится формат объявления переменных.

### Объявления
При определении какой-либо структуры, объединения (union), перечислимого типа данных или typedef компилятор не резервирует память автоматически. Из определения компилятор просто получает информацию об определенном типе данных и (необязательно) связывает с ним определенное имя. Такое определение можно делать внутри или вне функции или метода. В первом случае только данная функция или метод «знает» о его существовании; во втором случае определение распространяется на весь файл.

После того, как создано определение, можно объявлять переменные с этим типом данных. Для переменной любого типа данных будет выделена память, если только это не объявление extern (в этом случае память может быть выделена или не выделена, см. ниже раздел «Классы памяти и область действия». 

Язык Objective-C позволяет также выделять память одновременно с объяв-лением определенной структуры, объединения или перечислимого типа дан-ных. Для этого нужно просто перечислить соответствующие переменные, прежде чем завершить определение символом «точка с запятой».

### Базовые типы данных
Базовые типы данных приводятся в таблице В.З. Чтобы объявить переменную с определенным типом данных, нужно использовать формат
```
тип имя = начальное_значение;
```
Присваивание начального значения переменной не является обязательным и подчиняется правилам, описанным ниже в разделе «Переменные». Для объявления нескольких переменных используется формат
```
тип имя = начальное_значение, имя = начальное_значение, ...;
```
Перед объявлением типа можно дополнительно указать класс памяти, что описывается ниже в разделе «Переменные*. Если указан класс памяти и пере-менная должна иметь тип int, то int можно опустить. Например,
```
static counter;
```
объявляет counter как переменную static int.

Табл. В.З. Сводка базовых типов данных

| Тип                  | Описание                                                                                                                                                                                                             |
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| int                  | Целое значение, то есть значение, не содержащее десятичной точки; имеет точность не менее 32 бит.                                                                                                                    |
| short int            | Целое значение, которое занимает половину памяти по сравнению с типом int на некоторых машинах; имеет точность не менее I6 бит.                                                                                      |
| long int             | Целое значение увеличенной точности; имеет точность не менее 32 бит.                                                                                                                                                 |
| long long int        | Целое значение дополнительно увеличенной точности; имеет точность не менее 64 бит.                                                                                                                                   |
| unsigned int         | Положительное целое значение; может содержать положительные значения, вдвое больше, чем int; имеет точность не менее 32 бит.                                                                                         |
| float                | Значение с плавающей точкой, то есть может содержать знаки после десятичной точки; имеет точность не менее 6 цифр.                                                                                                   |
| double               | Значение с плавающей точкой увеличен ной точности; имеет точность не менее 10 цифр.                                                                                                                                  |
| long double          | Значение с плавающей точкой дополнительно увеличенной точности; имеет точность не менее 10 цифр.                                                                                                                     |
| char                 | Значение с одним символом; на некоторых машинах может добавляться знак при использовании в выражении.                                                                                                                |
| unsigned char        | То же самое, что и char, за исключением того, что в случае преобразования в целое значение не будет добавляться знак.                                                                                                |
| signed char          | То же самое, что и char, за исключением того, что в случае преобразования в целое значение будет добавляться знак.                                                                                                   |
| _Bool                | Булев тип; хранит значение 0 или 1.                                                                                                                                                                                  |
| float _Complex       | Комплексное число.                                                                                                                                                                                                   |
| double _Complex      | Комплексное число увеличенной точности.                                                                                                                                                                              |
| long double _Complex | Комплексное число дополнительно увеличенной точности.                                                                                                                                                                |
| void                 | Не обозначает никакого типа; используется при объявлении функции или метода, не возвращающих никакого значения, или для явной отмены результатов выражения; используется также как обобщенный тип указателя (void *) |

Отметим, что модификатор signed можно также указывать перед типами short irrt, int, long int и long long int. Поскольку эти типы всегда используются со знаком, модификатор не оказывает на них дополнительного влияния.

Типы данных Complex и .Imaginary позволяют объявлять комплексные и мнимые числа и работать с ними с помощью функций из библиотеки, поддерживающей арифметические операции с этими типами. Обычно следует включать в свою программу файл <complex.h>, где определяются макросы и объявляются функции для работы с комплексными и мнимыми числами. Например, переменную d типа double .Complex можно объявить и инициализировать со значением 5 + 10.5i с помощью оператора
```
double .Complex cl = 5 + 10.5 * I;
```
Затем можно использовать библиотечные процедуры creal и cimag для извлечения вещественной и мнимой частей d соответственно.

Используемая реализация не обязательно поддерживает типы Complex и Jmaginary. Она может поддерживать один тип и не поддерживать другой.

### Производные типы данных
Производный (derived) тип данных формируется из одного или нескольких базовых типов данных. Производными типами данных являются массивы, структуры, объединения и указатели (включая объекты). Функция или метод, которые возвращают значение указанного типа, также считаются производным типом данных. Функции и классы описываются по отдельности соответственно в разделах «Функции» и «Классы».

#### Массивы
##### Одномерные массивы
В определении массива может содержаться любой базовый тип данных или любой производный тип данных. Массивы функций не допускаются (хотя разрешается использовать массивы указателей на функции).

Объявление массива имеет следующий основной формаi.
```
тип имя[n] = { Выражение инициализации, Выражение_инициализации, ..);
```
Выражение п определяет число элементов массива с этим именем, и его можно опустить, если задан список начальных значений. В этом случае размер массива определяется числом заданных начальных значений или элементом с максимальным указанным номером, если используются назначенные инициализаторы.

Если определяется глобальный массив, каждое начальное значение должно быть константным выражением. Число значений в списке инициализации мо-жет быть меньше числа элементов массива (но не больше). Если задано меньше значений, то инициализируется только соответствующее число элементов массива; остальным элементам присваивается значение 0.

Особым случаем инициализации массива являются массивы символов, ко-торые можно инициализировать с помощью константной символьной строки. Например,
```
char today(] = "Monday";
```
объявляет today как массив символов. Элементы этого массива инициализируются в виде начальных значений соответственно символами 'М'.'о', 'n', 'd', 'а', 'у' и '\0\

Если объявить явным образом размер массива, не оставив элемента для конечного нуль-символа, то компилятор не поместит нуль-символ в конце массива.
```
char today[6] = "Monday";
```
В этом объявлении today является массивом из шести символов, и его эле-ментам присваиваются соответственно символы ’М\ 'o', *n', ЧГ, 'а' и ’у’.

Указывая элементы в прямоугольных скобках, можно инициализировать конкретные элементы массива в любом порядке. Например, ниже объявляется массив из Ю элементов с именем а (число элементов массива определяется элементом с максимальным указанным номером), а также задается начальное значение х + 1 (1234) для последнего элемента и значения 1,2,3 соответственно для первых трех элементов.
```
int х = 1233;
int а[] = { |9] = х + 1, [2] = 3, [1] = 2, [0] = 1 };
```

##### Массивы переменной длины
Внутри функции, метода или блока можно задать размер массива, используя выражение, содержащее переменные. В этом случае размер вычисляется на этапе выполнения. Например, функция
```
int makeVals (int n)
{
int valArray[n];
}
```
определяет автоматический массив с именем valArray и размером п элементов, где п вычисляется на этапе выполнения программы и может быть различным при различных вызовах этой функции. Массивы переменной длины нельзя инициализировать.

##### Многомерные массивы
Объявление многомерного массива имеет основной формат
```
тип имя[n] = [d1][d2]...[dn] = списокИнициализации
```
Здесь определяется, что массив с этим именем содержит dl xd2x...x dn эле-ментов указанного типа. Например,
```
int three_d [5] [2] [20];
```
определяет трехмерный массив three_d, содержащий 200 целых элементов.

Отдельный элемент многомерного массива указывается набором индексов каждой размерности, каждый из которых заключен в отдельные прямоуголь-ные скобки. Например, выражение
```
three.d [4][0][15] = 100;
```
присваивает значение 100 указанному элементу массива three_d.

Многомерные массивы можно инициализировать таким же образом, как одномерные. Для управления присваиванием значений элементам массива можно использовать вложенные пары фигурных скобок.

Ниже матрица определяется как двумерный массив, содержащий четыре строки и три столбца.
```
int matrix[4][3] =
{{1,2,3},
{ 4, 5, 6 },
{ 7, 8, 9 } };
```
Элементам первой строки матрицы присваиваются соответственно значе-ния 1,23; элементам второй строки — 4,5,6; и элементам третьей строки — 7, 8, 9. Элементам четвертой строки присваивается значение 0, поскольку для этой строки значения не заданы. Объявление
```
int matrix[4][3] =
{ 1,2, 3, 4, 5, 6, 7, 8,9};
```
инициализирует матрицу, содержащую те же значения, поскольку элементы многомерного массива инициализируются в порядке размерностей, то есть от левой размерности к правой. Объявление
```
int matrix[4][3] =
{1},
{4},
{7}};
```
присваивает 1-му элементу 1-й строки матрицы значение 1, 1-му элементу 2-й строки - значение 4 и I -му элементу 3-й строки - значение 7. Всем остальным элементам присваивается по умолчанию значение 0.

И, наконец, объявление
```
int matrix[4][3] = {[0][0] = 1, [1][1] = 5, [2][2] = 9};
```
инициализирует для указанных элементов матрицы заданные значения.

#### Структуры
##### Общий формат
```
struct имя
{
объявлениеКомпонента
объявлениеКомпонента
} списокПеременнык,
```
Для структуры с заданным именем указывается, что она содержит компоненты в соответствии с каждым объявлениемКомпонента. Каждое такое объявление содержит указание типа, после которого следует список из одного или нескольких имен компонентов.

Переменные можно объявить непосредственно во время определения структуры, указав их перед завершающим символом «точка с запятой», или их можно объявить в дальнейшем, используя формат
```
struct имя список именПеременнык,
```
Этот формат нельзя использовать, если в определении структуры не указано имя. В этом случае все переменные структуры должны быть объявлены с помощью определения.

Формат инициализации переменной-структуры аналогичен формату для массивов. Компоненты структуры можно инициализировать, заключив список начальных значений в фигурные скобки. Каждое значение в этом списке должно быть константным выражением, если инициализируется глобальная структура.

В объявлении
```
struct point
{
float х; float у;
} start = {100.0, 200.0};
```
определяется структура с именем point и переменная-структура с именем start с указанными начальными значениями. Конкретные компоненты структуры можно задавать для инициализации в любом порядке с помощью формы записи
```
.компонент = значение
```
в списке инициализации, например,
```
struct point end = {.у = 500, .х = 200 };
```
В объявлении
```
struct entry
{
char *word; char *def;
} dictionary[1000] = {
{"a", "first letter of the alphabet"},
{"aardvark", "a burrowing African mammal"},
{"aback", "to startle" }
};
```
объявляется словарь, содержащий 1000 структурных записей, причем первые три элемента инициализируются как указатели на указанные символьные строки. Используя назначенные инициализаторы, можно записать это следующим образом.
```
struct entry
{
char *word; char *def;
} dictionary! 1000] = {
[0].word = "a", (0].def = "first letter of the alplmet",
[t].word = "aardvark", [1 J.def = "a burrowing African mammal",
[2].word = "aback", [2].def = "to startle"
};
```
или в эквивалентной форме
```
Struct entry
{
char *word; char *def;
} dictionary[ 1000] = {
{ {.word = "a", .def = "first letter of the alphabet"},
{.word = "aardvark", .def = "a burrowing African mammal"),
{.word = "aback", .def = "to startle")
);
```
Автоматическую переменную-структуру можно инициализировать, присвоив ей другую структуру того же типа, например,
```
struct date tomorrow = today;
```
Здесь объявляется переменная-структура типа date с именем tomorrow, и ей присваивается содержимое (ранее объявленной) переменной-структуры типа date с именем today.

ОбъявлениеКомпонента, которое имеет формат
```
тип имяПоля: n
```
определяет доле длиной п бит внутри структуры, где п — целое значение. Поля могуг располагаться слева направо на одних машинах и справа налево на других. Если имяПоля опущено, то резервируется указанное число битов, но без ссылки. Если имяПоля опушено и п равно 0, то следующее поле выравнивается по границе следующего блока памяти, где размер блока зависит от реализации. Поле может иметь тип int, signed int или unsigned int. В зависимости от реализации поле типа int интерпретируется как signed или unsigned. К полю нельзя применять адресный оператор (&), и нельзя определять массивы молей.


#### Объединения
##### Общий формат
```
union имя
{
ОбъявлениеКомпонента
ОбъявлениеКомпонента
} списокПеременных,
```
Здесь определяется объединение с заданным именем и компонентами, соот-ветствующими каждому объявлениюКомпонента. Каждый компонент объединения использует общую область памяти, и компилятор обеспечивает резервирова-ние области памяти, достаточной, чтобы вместить самый большой компонент данного объединения.

Переменные можно объявить непосредственно во время определения объединения, или их можно объявить в дальнейшем, используя форму записи
```
union имя список именПеременнык,
```
при условии, что объединению было присвоено имя при его определении.

Программист сам должен следить за тем, чтобы значение, считываемое из объединения, соответствовало типу значения, которое было в последний раз сохранено в объединении. Первый компонент объединения можно инициали-зировать, заключив в фигурные скобки начальное значение, которое в случае глобальной union-переменной должно быть константным выражением.
```
union shared
{
long long int I; long int w[2];
} swap = { Oxffffffff};
```
Для инициализации другого компонента нужно указать имя этого компо-нента, как в
```
union shared swap2 = {.w[0] = 0x0, .w[1] = Oxffffffff };
```
Здесь объявляется union-переменная swap, и ее компоненту I присваивается шестнадцатеричное значение ffffffff.

Автоматическую union-переменную можно также инициализировать, при-своив ей объединение того же типа, например,
```
union shared swap2 = swap;
```

#### Указатели
Объявление переменной-указателя имеет базовый формат тип *имя,

Идентификатор имя объявляется с типом «указатель на тип»; типом может быть какой-либо базовый тип данных или производный тип данных. Например,
```
int *ip;
```
объявляет ip как указатель на тип int, и
```
struct entry *ер;
```
объявляет ер как указатель на структуру entry. Если определен класс Fraction, то
```
Fraction "myFract;
```
объявляет myFract как объект типа Fraction, или, точнее, myFract используется для хранения указателя на структуру данных объекта после того, как создан экземпляр объекта и он присвоен этой переменной.

Указатели, которые указывают на элементы массива, объявляются для указания на тип элемента, содержащегося в этом массиве. Например, предыдущее объявление ip можно было бы также использовать для объявления указателя на массив целых элементов.

Допускаются также более сложные формы объявлений указателей. Напри-мер,
```
char *tp[100];
```
объявляет tp как массив из 100 указателей на тип char, и
```
struct entry (*fnPtr) (int);
```
объявляет fnPtr как указатель на функцию, которая возвращает структуру entry и принимает один аргумент типа int.

Можно проверить, является ли указатель пустым (null), сравнив его с кон-стантным выражением, значение которого равно 0. В реализации можно выб-рать внутреннее представление null-указателя в виде значения, отличного от 0. Однако сравнение между указателем с таким внутренним представлением и константным значением 0 должаю показывать равенство.

Преобразование указателей в целые значения и целых значений в указате-ли, а также размер целой переменной, необходимой для хранения указателя, зависят от типа машины.

Тип «указатель на void» — это обобщенный тип указателя. Язык Objective-C гарантирует, что указатель любого типа может быть присвоен void-указателю, и затем можно выполнить обратное присваивание без изменения его значения.

Тип id — это обобщенный указатель на объект. Любой объект любого класса может быть присвоен id-псременной, и наоборот.

За исключением этих двух особых случаев присваивание указателей различного типа не допускается, и обычно при такой попытке компилятор выдает предупреждающее сообщение.

### Перечислимые типы данных
Общий формат
```
enum имя { епит_ /, епит_2,..} списокПеременнык,
```
Перечислимый тип с заданным именем определяется с перечисляемыми значениями enum l, епит_2,..., каждое из которых является идентификатором или идентификатором, после которого следует знак равенства и константное выра-жение. Можно также объявить спиажПеременных (с необязательными начальными значениями), и эти переменные будут иметь тип enum имя.

Компилятор присваивает перечисляемым идентификаторам последовательные целые значения, начиная с 0. Если идентификатор указан со знаком = и константным выражением, то идентификатору присваивается значение этого выражения. Последующим идентификаторам присваиваются значения, начиная со значения этого константного выражения плюс 1. Перечисляемые идентификаторы интерпретируются компилятором как константные целые значения.

Если нужно объявить переменную определенного ранее (и именованного) перечислимого тина, можно использовать конструкцию
```
enum имя списокПеременных,
```
Если объявлена переменная определенного перечислимого типа, то ей мож-но присвоить значение только того же типа, хотя компилятор, возможно, не зарегистрирует это как ошибку.

### typedef
Оператор typedef используется, чтобы присвоить новое имя базовому или производному типу данных. Этот оператор не определяет какой-либо новый тип, а просто назначает новое имя для существующего типа. Поэтому переменные, объявленные с типом, имеющим новое имя, интерпретируются компилятором точно так же, как с типом, для которого дополнительно назначено это новое имя.

Создавая определение typedef, нужно действовать, как при объявлении обычной переменной. При этом нужно поместить новое имя типа там, где обычно ставится имя переменной. И, наконец, перед всем этим нужно поставить ключевое слово typedef.

В показанном ниже примере
```
typedef struct
{
float х; float у;
} POINT;
```
имя POINT связывается со структурой, содержащей два компонента типа float с именами х и у. Затем можно объявлять переменные типа POINT, например,
```
POINT origin = {0.0, 0.0};
```

### Модификаторы типа: const, volatile и restrict
Перед объявлением типа можно помещать ключевое слов const, чтобы сообщить компилятору, что это значение нельзя изменять. Например,
```
const int х5= 100;
```
объявляет х5 как постоянную целую переменную — ей нельзя присвоить другое значение во время выполнения программы. Компилятор не обязательно будет реагировать на попытки изменения значения такой переменной.

Модификатор volatile явно указывает компилятору, что значение изменяется (обычно динамически). Если в выражении используется volatile-переменная, доступ к ее значению разрешается в любом месте, где она появляется.

Чтобы объявить переменную port17 как тип «volatile-указатель на char», можно написать следующую строку.
```
char *volatile port 17;
```
С указателями можно использовать ключевое слово restrict. Это указание компилятору на возможность оптимизации (аналогично ключевому слову register для переменных). Ключевое слово restrict сообщает компилятору, что данный указатель будет единственной ссылкой на определенный объект, то есть не будет указываться никаким другим указателем в пределах той же области действия. Строки
```
int * restrict intPtrA;
int * restrict intPtrB;
```
сообщают компилятору, что в пределах области действия, где определены intPtrA и intPtrB, они никогда не будут указывать на одно и то же значение. Их использование для указания целых значений (например, в массиве) будет взаимоисключающим.

## Выражения
Имена переменных, имена функций, выражения в виде сообщений, имена массивов, константы, вызовы функций, ссылки на массивы, а также ссылки на структуры и объединения — все это интерпретируется как выражения. Применение унарного (одноместного) оператора к этим выражениям (в допустимых случаях) тоже является выражением, как и сочетание этих выражений с помощью бинарного (двумсстно1\>) или тернарного (трехместного) оператора. И, наконец, выражение, заключенное в круглые скобки, тоже является выражением.

Отличное от void выражение любого типа, которое идентифицирует объект данных, называется lvalue (1-значением). Если ему может быть присвоено зна-чение, оно называется модифицируемым (изменяемым) lvalue.

Модифицируемые lvalue-выражения обязательны в определенных местах. Выражение в левой части оператора присваивания должно быть модифициру-емым lvalue. Унарный адресный оператор можно применить только к модифицируемом lvalue или к имени функции. И, наконец, операторы наращивания и уменьшения на 1 (инкремента и декремента) можно применять только к модифицируемым lvalue-выражениям.

### Сводка операторов Objective-C
В таблице В.4 приводится сводка различных операторов языка Objcctivc-C. Эти операторы приводятся в порядке убывания старшинства, и операторы, сгруп-пированные вместе, имеют одинаковый уровень старшинства.

Рассмотрим на следующем примере, как использовать таблицу В.4.
```
b | с & d * е
```
Оператор умножения имеет более высокий приоритет, чем побитовые операторы OR (|) и AND (&), поскольку он находится выше обоих операторов в таблице В.4. Аналогичным образом, побитовый оператор AND имеет более высокий приоритет, чем побитовый оператор OR, поскольку первый находится в этой т аблице выше, чем второй. Поэтому данное выражение вычисляется в следующем порядке.
```
b | ( с & ( d * е ))
```
Теперь рассмотрим следующее выражение, b % с * d

Табл. В.4. Сводка операторов Objective-C

| Оператор                                | Описание                                             | Ассоциативность  |
|-----------------------------------------|------------------------------------------------------|------------------|
| 0                                       | Вызов функции                                        | Слева направо    |
| []                                      | Ссылка на элемент массива или выражение с сообщением | - &vert;&vert; - |
| ->                                      | Указатель ссылки на компонент структуры              | - &vert;&vert; - |
| .                                       | Ссылка на компонент структуры или вызов метода       | - &vert;&vert; - |
| -                                       | Унарный минус                                        | Справа налево    |
| +                                       | Унарный плюс                                         | - &vert;&vert; - |
| ++                                      | Оператор инкремента                                  | - &vert;&vert; - |
| --                                      | Оператор декремента                                  | - &vert;&vert; - |
| !                                       | Логическое отрицание                                 | - &vert;&vert; - |
| ~                                       | Дополнение до нуля                                   | - &vert;&vert; - |
| *                                       | Ссылка на указатель (косвенным образом)              | - &vert;&vert; - |
| &                                       | Адрес                                                | - &vert;&vert; - |
| sizeof                                  | Размер объекта                                       | - &vert;&vert; - |
| (тип)                                   | Приведение типа (преобразование)                     | - &vert;&vert; - |
| *                                       | Умножение                                            | Слева направо    |
| /                                       | Деление                                              | - &vert;&vert; - |
| %                                       | Взятие по модулю                                     | - &vert;&vert; - |
| +                                       | Сложение                                             | - &vert;&vert; - |
| -                                       | Вычитание                                            | - &vert;&vert; - |
| <<                                      | Левый сдвиг                                          | - &vert;&vert; - |
| >>                                      | Правый сдвиг                                         | - &vert;&vert; - |
| <                                       | Меньше                                               | - &vert;&vert; - |
| <=                                      | Меньше или равно                                     | - &vert;&vert; - |
| >                                       | Больше                                               | - &vert;&vert; - |
| >=                                      | Больше или равно                                     | - &vert;&vert; - |
| ==                                      | Равенство                                            | - &vert;&vert; - |
| !=                                      | Неравенство                                          | - &vert;&vert; - |
| &                                       | Побитовый AND                                        | - &vert;&vert; - |
| ^                                       | Побитовый XOR                                        | - &vert;&vert; - |
| &vert;                                  | Побитовый OR                                         | - &vert;&vert; - |
| &&                                      | Логический AND                                       | - &vert;&vert; - |
| &vert;&vert;                            | Логический OR                                        | - &vert;&vert; - |
| ?:                                      | Условный                                             | Справа налево    |
| = *= /= %= += -= & = ^= &vert;= <<= >>= | Операторы присваивания                               | - &vert;&vert; - |
| ,                                       | Оператор «запятая»                                   | - &vert;&vert; - |

Поскольку операторы взятия по модулю и умножения включены в одну группу таблицы В.4, они имеют одинаковый уровень старшинства. Эти операторы выполняются слева направо. Следующее выражение будет вычисляться как
```
( b % с ) * d
```
В следующем примере выражение
```
++а->b
```
будет вычисляться как
```
++(а->b)
```
поскольку оператор -> имеет более высокий приоритет, чем оператор ++.

И, наконец, поскольку операторы присваивания группируются справа на-лево, оператор
```
а = b = 0;
```
будет вычисляться как
```
а = (Ь = 0);
```
в результате чего переменным а и b будет присвоено значение 0. В случае выра-жения
```
x[i] + ++i
```
не определено, в каком порядке компилятор будет выполнять оценку, — начиная с левой части оператора «плюс» или начиная с правой части. В данном случае порядок вычислений влияет на результат, поскольку значение i может быть увеличено до того, как будет вычисляться x[i],

В этом выражении порядок вычислений также не определен:
```
x[i] = ++i
```
В этой ситуации не определено, когда значение i будет использовано как индекс для х, — до приращения i или после приращения.

Порядок вычисления аргументов функции или метода тоже не определен. Поэтому при вызове функции
```
f(i, ++i);
```
или в выражении с сообщением
```
[myFract setTo: i over: ++i];
```
возможно, что сначала будет выполнено приращение i, в результате чего функ-ции или методу будут переданы два одинаковых значения.

Язык Objectivc-C гарантирует, что операторы && и || будут вычисляться слева направо. Поэтому в случае && гарантируется, что второй операнд нс будет оцениваться, если первый равен 0; в случае || гарантируется, что второй операнд не будет оцениваться, если первый не равен 0. Этот факт необходимо учитывать при формировании таких выражений, как
```
if ( dataFlag || [myData checkData])
```
поскольку в этом случае checkData вызывается, только если значение dataFlag равно 0. Еще один пример. Если в определении объект-массив а содержит п элементов, то оператор, который начинается с
```
if (index >= 0 && index < n && ([a objectAtlndex: index] == 0))
```
является ссылкой на элемент этого массива, только если index является допустимым индексом в этом массиве.

### Константные выражения
Константное выражение — это выражение, каждый из членов которого является константным значением. Константные выражения необходимы в следующих ситуациях.
1. Как значение после case в операторе switch.
2. Для указания размера массива.
3. Чтобы присвоить значение идентификатору перечисления.
4. Чтобы указать размер битового поля в определении структуры.
5. Чтобы присвоить начальные значения внешним или статическим переменным.
6. Чтобы задать начальные значения для глобальных переменных.
7. Как выражение после #if в препроцессорном операторе #if.
В первых четырех случаях константное выражение должно состоять из це-лых констант, символьных констант, перечисляемых констант и выражений sizeof. Могут использоваться только арифметические операторы, побитовые операторы, операторы отношения, оператор с условным выражением и опера-тор приведения тина (cast).

В пятом и шестом случаях помимо вышеперечисленных правил может ис-пользоваться явно или неявно адресный оператор. Однако он может приме-няться только к внешним или статическим переменным или функциям. На-пример, выражение
```
&х+ 10
```
будет допустимым константным выражением, если х является внешней или статической переменной. Кроме того, выражение
```
&а[10] - 5
```
янляется допустимым константным выражением, если а является внешним или статическим массивом. И, наконец, поскольку &а[0] эквивалентно выражению
```
а + sizeof (char) * 100
```
оно тоже является допустимым константным выражением.

В последней ситуации, где необходимо константное выражение (после #if), применяются такие же правила, как для первых четырех случаев, за исключе-нием того, что не могут использоваться оператор sizeof, константы перечисления и оператор приведения типа (cast). Однако разрешается специальный определенный оператор (см. раздел «Директива if»).

### Арифметические операторы
При условии, что
```
а, b выражения любого базового типа данных за исключением void; i, j выражения любого целого типа данных
```
выражение
```
-а  изменяет знак а на противоположный;
+а  дает значение а;
а + b выполняет сложение  а и b;
а - b выполняет вычитание b из а;
а * b выполняет умножение а на b;
а / b выполняет деление а на b;
i % j дает остаток от деления i на j.
```
В каждом выражении выполняются обычные арифметические преобразо-вания над операндами (см. ниже раздел «Преобразование базовых типов дан-ных»), Если а — переменная без знака (unsigned), то для вычисления -а сначала выполняется целочисленное расширение, выполняется вычитание из большего значения расширенного типа и к результату добавляется 1.

При делении двух целых значений выполняется усечение результата. Если один из операндов меньше нуля, то направление усечения не определено (то есть -3/2 может дать на некоторых машинах -1 и -2 на других); в противном случае усечение всегда выполняется в сторону 0(3/2 всегда дает 1). Сводку арифметических операций с указателями см. в разделе «Базовые операции с указателями».

### Логические операторы
При условии, что
```
а, b выражения любого базового типа данных за исключением void или оба операнда являются указателями;
```
выражение
```
а && b имеет значение 1, если а и Ь не равны нулю, и значение 0 в противном случае (Ь оценивается только в том случае, если а отлично от нуля);
а || b имеет значение 1, если а или b не равно нулю, и значение 0 в противном случае (Ь оценивается только в том случае, если а отлично от нуля);
! а имеет значение 1, если а равно 0, и значение 0 в противном случае.
```
К а и b применяются обычные арифметические преобразования (см. ниже раздел «Преобразование базовых типов данных»). Во всех случаях результат имеет тип int.

### Операторы отношения
При условии, что
```
а, Ь выражения любого базового типа данных за исключением void или оба операнда являются указателями;
```
выражение
```
а < b имеет значение 1, если а меньше Ь, и значение 0 в противном случае;
а <= b имеет значение 1, если а меньше или равно Ь, и значение 0 в противном случае;
а > Ь имеет значение 1, если а больше Ь, и значение 0 в противном случае;
а >= b имеет значение 1, если а больше или равно Ь, и значение 0 в противном случае;
а != b имеет значение 1, если а не равно Ь, и значение 0 в противном случае.
```
К а и b применяются обычные арифметические преобразования (см. ниже раздел «Преобразование базовых типов данных»). Первые четыре оператора отношения имеют смысл для указателей, только если они указывают на один и тот же массив либо на компоненты одной структуры или объединения. Во всех случаях результат имеет тип int.

### Побитовые операторы
При условии, что
```
i, j, п выражения любого целого типа данных;
```
выражение
```
i & j   выполняет побитовую операци ю AN D с i и j;
i | j   выполняет побитовую операцию OR с i и j;
i А j   выполняет побитовую операцию XOR с i и j;
~i   получает дополнение до нуля для i;
i << n выполняет сдвиг i влево на n бит;
i >> n выполняет сдвиг i вправо на n бит.
```
К этим операндам применяются обычные арифметические преобразования за исключением « и », когда для каждого операнда выполняется целочисленное расширение (см. ниже раздел «Преобразование базовых типов данных»). Если количество битов смешения меньше нуля либо больше или равно числа битов в объекте смешения, то результат смешения не определен. На некоторых машинах правое смещение является арифметическим (заполняется бит знака), а на других — логическим (заполнение нулем). Тип результата операции смещения такой же, как у расширяемого левого операнда.

### Операторы наращивания и уменьшения на 1 (операторы инкремента и декремента)
При условии, что
```
I модифицируемое lvalue-выражение, тип которого не уточнен как const;
```
выражение
```
++I увеличивает I на 1, после чего I используется как значение выражения;
I++ использует I как значение выражения и затем увеличивает I на 1;
--I уменьшает I на I, после чего I используется как значение выражения;
I-- использует I как значение выражения и затем уменьшает 1 на I.
```
Ниже в разделе «Базовые операции с указателями» описываются эти операции с указателями.

### Операторы присваивания
При условии, что
```
I модифицируемое lvalue-выражение, тип которого не уточнен как const;
op любой оператор, который можно использовать как оператор присваивания (см. таблицу В.4);
а выражение;
```
выражение
```
I = а сохраняет значение а в I;
I ор= а применяет орк I и а, сохраняя результат в I.
```
Если в первом выражении а имеет один из базовых типов данных (за исклю-чением void), то а преобразуется для соответствия типу I. Если I - указатель, то а должен быть указателем того же типа, void-указателем или null-указателем.

Если I — void-указатель, то а может быть указателем любого типа. Второе выражение интерпретируется как I = I ор (а), за исключением того, что I оценивается только один раз (например, в случае x[i++] += 10).

### Условный оператор
При условии, что
```
а, Ь, с выражения;
```
выражение
```
а ? b: с получает значение Ь, если а отлично or нуля, или с в противном случае. Вычисляется только выражение b или с.
```
Выражения Ь и с должны иметь одинаковый тип данных. Если это не так, но оба выражения имеют арифметические типы данных, то применяются обычные арифметические преобразования, чтобы сделать их типы одинаковыми. Если одно из них является указателем, а другое равно 0, то второе выражение используется как null-указатель того же типа, что и первое. Если одно из них является указателем на void, а другое является указагелем на другой тип, то вто-рое преобразуется в указатель на void и результат имеет такой же тип.

### Оператор приведения типа
При условии, что
```
тип имя какого-либо базового типа данных, перечислимый тип данных (с ключевым словом enum) или тип, определенный как typedef либо приведенный тип данных;
а выражение;
```
выражение
```
( тип) преобразует а в указанный тип.
```
Отметим, что использование типа в круглых скобках при объявлении или определении метода не является примером использования оператора приведе-ния типа.

### Оператор sizeof
При условии, что
```
тип совпадает с описанием в предыдущем разделе;
а выражение;
```
выражение
```
sizeof (тип) имеет значение, равное числу байтов памяти, необходимых для зна-чения указанного типа;
sizeof а имеет значение, равное числу байтов памяти, необходимых для ре-зультата вычисления а.
```
Для типа char результат по определению равен 1. Если а — имя массива, для которого задан размер (явным образом или неявно через инициализацию), и это не формальный параметр и не extern-массив, для которого не указан размер, то sizeof а дает число байтов, необходимых для хранения этих элементов в а.

Если а — имя класса, то sizeof (а) дает размер структуры, необходимой для хранения экземпляра а.

Целое значение, которое дает оператор sizeof, имеет тип size_t, который определен в стандартном header-файле <stddef.h>.

Если а — массив переменной длины, то данное выражение вычисляется на этапе выполнения; в противном случае оно вычисляется на этапе компиляции и его можно использовать в константных выражениях (см. выше раздел «Кон-стантные выражения»).

### Оператор «запятая»
При условии, что
```
а, b выражения;
```
выражение
```
а, Ь означает вычисление а и затем вычисление Ь. Результирующее выражение имеет тип и значение b.
```

### Базовые операции с массивами
При условии, что
```
а   объявляется как массив из п элементов;
i   выражение любого целого типа данных;
v   выражение;
```
выражение
```
а[0]    является ссылкой на первый элемент а;
а[n -1] является ссылкой на последний элемента; a[i] является ссылкой на элемент а с номером i; a[i] = v сохраняет значение v в ар].
```
В каждом случае тип результата совпадает с типом элементов, содержащихся в а. Сводку операций с указателями и массивами см. ниже в разделе «Базовые операции с указателями».

### Базовые операции со структурами
**Примечание.** Эго также относится к объединениям (union).

При условии, что
```
х модифицируемое lvalue-выражение типа struct s; у  выражение типа struct s;
m имя одно из компонентов структуры S; obj  любой объект;
М   любой метод;
v   выражение;
```
выражение
```
х   является ссылкой на всю структуру и имеет тип struct s;
y.m является ссылкой на компонент m структуры у и имеет тип, объявленный для компонента т;
x.m = v присваивает v компоненту m выражения х и имеет тип, объявленный для компонента т;
х = у присваивает х значение у и имеет тип struct s;
f (у) вызывает функцию f, передавая как аргумент содержимое структуры у (внутри f должен быть объявлен формальный параметр типа struct s);
[obj М: у] вызывает метод М для объекта obj, передавая как аргумент содержимое структуры у (внутри метода этот параметр должен быть объявлен как тип struct s);
return у; возвращает структуру у (возвращаемое значение, объявленное для функции или метода, должно иметь тип struct s).
```

### Базовые операции с указателями
При условии, что х  lvalue-выражение типа t,
```
pt  модифицируемое lvalue-выражение типа «указатель на t»;
v   выражение;
```
выражение
```
&х дает указатель на х и имеет тип «указатель на t»;
pt = &х задает pt как указатель на х и имеет тип «указатель на Ь>;
pt = 0 присваивает pt null-указатель;
pt == 0 проверяет, является ли pt null-указателем;
*pt является ссылкой на значение, указываемое pt и имеет тип t
*pt = v сохраняет значение v в том месте, на которое указывает pt, и имеет тип t
```

#### Указатели на массивы
При условии, что
```
а массив элементов типа t;
ра1 модифицируемое lvalue-выражение типа «указатель на t», которое указывает на какой-либо элемент в а;
ра2 lvalue-выражение типа «указатель на Ь>, которое указывает на какой-либо элемент в а или на элемент, следующий за последним элементов в а;
v выражение;
п целое выражение;
```
выражение
```
a, &a, &a[0]    каждое дает указатель на первый элемент;
&a[n]   создает указатель на элемент с номером n массива а и имеет тип «указатель на t»;
*pa1    является ссылкой на элемент, на который указывает pal, и имеет тип «t»;
*pa1 = v    сохраняет значение v в элементе, на который указывает pal, и имеет тип «t»;
++pa1   задает указатель ра1 на следующий элемент а независимо от типа элементов, содержащихся в а, и имеет тип «указатель на /»;
--pa1   задает указатель pal на предыдущий элемента независимо от типа элементов, содержащихся в а, и имеет тип «указатель на i»;
*++pa1  увеличивает pal на 1 и затем ссылается назначение в а, на которое указывает pal; имеет тип t,
*pa1++  ссылается на значение в а, на которое указывает ра1, прежде чем увеличить ра1 на 1; имеет тип к
pa1 + n создает указатель, который указывает в а на n элементов дальше, чем ра1, и имеет тип «указатель на /»;
pa1 - n создает указатель, который указывает в а на n элементов ближе, чем ра1, и имеет тип «указатель на /»;
*(pa1 + n) = v  сохраняет значение v в элементе, на который указывает ра1 + n, и имеет тип « указатель на f»;
pa1 < pa2   проверяет, что ра1 указывает в а более ближний элемент, чем ра2; имеет тип int (для сравнения двух указателей можно использовать любые операторы отношения);
pa2 - pa1   дает число элементов, содержащихся в а между указателями ра2 и pal (в предположении, что ра2 указывает на элемент, который находится дальше, чем ра1), и имеет значение целого типа;
a + n   создает указатель на элемент массива а с номером п и имеет тип «указатель на t»; эквивалентно во всех отношениях выражению &а[n];
*(а + n)    ссылка на элемент массива а с номером п, имеет тип «fa и эквивалентно во всех отношениях выражению а[п].
```
Целое значение, получаемое в результате вычитания двух указателей, имеет конкретный тип ptrdiffj, который определен в стандартном header-файле `<stddef.h>`.

#### Указатели на структуры
При условии, что
```
х   модифицируемое lvalue-выражение типа struct s;
ps  модифицируемое lvalue-выражение типа «указатель на struct ss>;
m   имя какого-либо компонента структуры s, имеющего тип t;
v   выражение;
```
выражение
```
&х  дает указатель на х и имеет тип «указатель на struct s»;
ре - &х задает ре как указатель па х, имеющий тип «указатель на struct s>>;
ps->m является ссылкой на компонент m структуры, указанной с помощью ps, и имеет тип t,
(*ps).m тоже является ссылкой на этот компонент и эквивалентно во всех отношениях выражению ps->m;
ps->m = v сохраняет значение v в компоненте m структуры, указанной с помо-щью ps, и имеет тип t.
```

### Составные литералы
Составной литерал (compound literal) представляет собой имя типа, заключен-ное в круглые скобки, после которого следует список инициализации. В ре-зультате создается неименованное значение указанного типа, область действия которого ограничена блоком, в котором оно создано, или глобальной областью действия, если оно определено вне блока. В последнем случае все инициализаторы должны включать только константные выражения.

Например,
```
(struct point) {.х = 0, .у = 0)
```
является выражением, которое создает структуру типа struct point с указанными начальными значениями. Его можно присвоить другой структуре типа struct point, например,
```
origin = (struct point) {.x = 0, .у = 0);
```
Или его можно передать функции или методу, если предполагается, что ар-гумент имеет тип struct point, например,
```
moveToPoint ((struct point) {.x = 0, .у = 0});
```
Можно также определять типы, отличные от структур. Например, если intPtr имеет тип int *, то оператор
```
intPtr = (int [100]) {[0] = 1, [50] = 50, [99] = 99 };
```
(который может находиться в любом месте программы) задает intptr, указывающий на массив, содержащий 100 целых элементов, причем первые 3 элемента инициализируются указанным образом.

Если размер массива не задан, он определяется списком инициализации.

### Преобразование базовых типов данных
Язык Objective-C преобразует операнды арифметических выражений в заранее определенном порядке, который называется обычными арифметическими преобразованиями .
1. Если один из операндов имеет тип long double, второй операнд преобразуется в long double, таким же будет тип результата.
2. Если один из операндов имеет тип double, второй операнд преобразуется в double, таким же будет тип результата.
3. Если один из операндов имеет тип float, второй операнд преобразуется в тип float, таким же будет тип результата.
4. Если один из операндов имеет тип _Bool, char, short int, является битовым полем типа int или является перечислимым типом данных, то он преобразуется в тип int, если int может полностью представлять его диапазон значений; в противном случае он преобразуется в unsigned int. Если оба операнда имеют одинаковый тип, таким же будет тип результата.
5. Если оба операнда указаны как signed или оба как unsigned, то целый тип меньшего размера преобразуется в больший целый тип, и таким же будет тип результата.
6. Если операнд с атрибутом unsigned имеет размер, который не меньше размера операнда с атрибутом signed, то операнд signed преобразуется в тип операнда unsigned, таким же будет тип результата.
7. Если операнд с атрибутом signed может представлять все значения операнда unsigned, то второй преобразуется в тип первого, если он может полностью представлять весь диапазон его значений, таким же будет тип результата.
8. Есл и был достигнут этот шаг, то оба операнда преобразуются в тип с атрибутом unsigned, соответствующий типу с атрибутом signed.

Шаг 4 называется более формально целочисленным расширением. Преобразование операндов нормально проходит в большинстве ситуаций, хотя следует отметить следующие особенности.
1. Преобразование char в int может вызвать на некоторых машинах расширение на знаковый бит, если char не объявлен как unsigned.
2. Преобразование целого типа с атрибутом signed в целый тип большего раз-мера вызывает расширение влево за счет знакового бита; преобразование целого типа с атрибутом unsigned в целый тип большего размера вызывает заполнение левою бита нулем.
3. Преобразование любого значения в _Воо1 дает значение 0, если значение равно нулю, и 1 в противном случае.
4. Преобразование более длинного целого типа в более короткий вызывает усечение целого значения слева.
5. Преобразование типа с плавающей точкой в целый тип вызывает усечение дробной части значения. Если целый тип является недостаточным, чтобы вместить преобразованное значение с плавающей точкой, то результат яв-ляется неопределенным (как и в случае преобразования отрицательного значения с плавающей точкой в целое с атрибутом unsigned).
6. Преобразование более длинного значения с плавающей точкой в более ко-роткий тип может вызывать или не вызывать округление, прежде произой-дет усечение.

## Классы памяти и область действия
Термин класс памяти (storage class) относится к способу выделения памяти ком-пилятором и к области действия определения конкретной функции или метода. Классы памяти — это auto, static, extern и register. Класс памяти можно не указывать в объявлении, и он будет назначен по умолчанию, как это описывается ниже.

Термин область действия (scope) относится к границам действия определенного идентификатора внутри программы. Идентификатор, определенный вне любой функции, метода или блока операторов (мы будем называть здесь это БЛОКОМ), доступен для ссылки в любой последующей точке файла. Идентификаторы, определенные внутри БЛОКА, являются локальными относительно этого БЛОКА и могут локально переопределять идентификатор, определенный вне этого БЛОКА. Имена меток, а также имена формальных параметров известны во всем БЛОКЕ. Метки, переменные экземпляра, имена структур и компонентов структур, имена объединений и компонентов объединений, а также имена перечислимых типов данных не обязательно должны отличаться друг от друга или от имен переменных, функций или методов. Однако идентификаторы перечисления все же должны отличаться от имен переменных и от других идентификаторов перечисления, определенных в пределах одной области действия. Имена классов имеют глобальную область действия и должны отличаться от имен других переменных и типов в пределах одной области действия.

### Функции
Если при определении функции определяется класс памяти, он должен быть указан как static или extern. К функции, которая объявляется как static, можно обращаться только в пределах файла, который содержит эту функцию. Функ-ции, объявленные как extern (или функции, для которых не указан никакой класс), могут вызываться функциями или методами из других файлов.

### Переменные
В таблице В.5 приводится сводка различных классов памяти, которые могут использоваться в объявлении переменных, а также их области действия и спо-собы их инициализации.

Табл. В.5. Переменные: сводка классов памяти, областей действия и способов инициализации

| Класс памяти | Место объявления переменной | На нее можно ссылаться                                                                 | И инициализировать с помощью  | Комментарии                                                                                                                                                                                                                                                     |
|--------------|-----------------------------|----------------------------------------------------------------------------------------|-------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| static       | Вне любого БЛОКА            | Внутри данного файла                                                                   | Только константного выражения | Переменные инициализируются только один раз при запуске программы; значения сохраняются в пределах БЛОКОВ; значение по умолчанию 0                                                                                                                              |
|              | Внутри какого-либо БЛОКА    | Внутри этого блока                                                                     |                               |                                                                                                                                                                                                                                                                 |
| extern       | Вне любого блока            | Внутри данного файла                                                                   | Только константных выражения  | Переменная должна быть определена хотя бы в одном месте без ключевого слова extern или в одном месте с использованием ключевого слова extern с присваиванием начального значения.                                                                               |
|              | Внутри какого-либо БЛОКА    | Внутри этого блока                                                                     |                               |                                                                                                                                                                                                                                                                 |
| auto         | Внутри какого-либо БЛОКА    | Внутри этого блока                                                                     | Любого допустимого выражения  | Переменная инициализируется каждый раз при входе в БЛОК; нет никакого значения по умолчанию.                                                                                                                                                                    |
| register     | Внутри какого-либо БЛОКА    | Внутри этого блока                                                                     | Любого допустимого выражения  | Присваивание регистра (register) не гарантируется; разнообразные ограничения на типы переменных, которые могут быть объявлены; нельзя брать адрес переменной с register; инициализируется каждый раз при входе в этот БЛОК; нет никакого значения по умолчанию. |
| Не указан    | Вне любого блока            | Внутри данного файла или из других файлов, которые содержат соответствующие объявления | Только константного выражения | Это объявление может появляться только в одном месте; переменная инициализируется при запуске программы; значение по умолчанию 0; по умолчанию используется класс памяти auto.                                                                                  |
|              | Внутри какого-либо БЛОКА    | (См. auto)                                                                             | (См. auto)                    |                                                                                                                                                                                                                                                                 |

### Переменные экземпляра
К переменным экземпляра можно получать доступ с помощью любого метода экземпляра, определенного для данного класса в секции interface, где явно объявляется эта переменная, или в категориях, созданных для данного класса. К наследуемым переменным экземпляра тоже можно осуществлять непосред-ственный доступ без каких-либо специальных объявлений. Методы класса не имеют доступа к переменным экземпляра.

Для управления областью действия переменной экземпляра можно исполь-зовать специальные директивы @private, @protected и @риЫк. После появления этих директив они действуют, пока не встретится закрывающая фигурная скобка, заканчивающая объявление соответствующих переменных экземпляра, или пока не будет использована другая из этих трех директив. Например, следующие строки являются началом объявления секции interface для класса с именем Point, содержащего четыре переменные экземпляра. 
```
@interface Point: NSObject
{
@private
int internail D;
@protected float x; float y;
@public BOOL valid;
}
```
Переменная internallD объявлена как private, переменные x и у — как protected (директива по умолчанию), переменная valid — как public.

Эти директивы описываются в таблице В.6.

Табл. В.6. Область действия переменных экземпляра

| Директива  | На переменную можно ссылаться                                                                                                                                                                                                                                                                                                                                                          | Комментарии                                                                                            |
|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|
| @protected | С помощью методов экземпляра в данном классе, методов экземпляра в подклассах, и методов экземпляра в расширениях категорий на данный класс.                                                                                                                                                                                                                                           | Эта директива по умолчанию.                                                                            |
| @private   | С помощью методов экземпляра в данном классе, методов экземпляра в расширениях категорий на данный класс, но не из каких-либо подклассов.                                                                                                                                                                                                                                              | Эта директива ограничивает доступ самим классом.                                                       |
| @public    | С помощью методов экземпляра в данном классе, методов экземпляра в подклассах и методов экземпляра в расширениях категорий на данный класс; доступ к такой переменной можно также выполнять из других функций или методов, применяя к экземпляру класса оператор косвенного указателя структуры (->), после которого следует имя переменной экземпляра (например, myfract->numerator). | Эту директиву следует использовать только при необходимости; она нарушает понятие инкапсуляции данных. |


## Функции
В этом разделе содержатся сведения о синтаксисе и работе функций.

### Определение функции
#### Общий формат
```
возвращаемыйТип имя (тип1 парам 1, тип2 парам2,..)
{
Объявления Переменных
программныйОператор
программныйОператор
return выражение;
}
```
Определяется функция имя, которая возвращает значение типа возвращаемый-Тип и имеет формальные параметры парам1, парам2,парам 1 объявляется с типом тип/, парам2с типом тип2, ит.д.

Локальные переменные обычно объяапяются в начале функции, но это не обязательно. Они могут быть объявлены в любом месте, и тогда доступ к ним ограничен операторами, которые следует в функции после их объявления.

Если функция не возвращает значения, то возвращаемыйТип указывается как void.

Если в круглых скобках содержится только void, функция не принимает ни-каких аргументов. Если применяются .. в качестве последнего (или единственного) параметра в списке, функция принимает переменное число аргументов, например,
```
int printf (char *format, ...)
{
}
```
В объявлениях для аргументов одномерных массивов не обязательно указывать число элементов этого массива. Для многомерных массивов нужно обязательно указать размер каждой размерности, кроме первой.

Описание оператора return см. ниже в разделе «Оператор return». По-прежнему поддерживается старый способ определения функций. Для этого используется следующий общий формат.
```
возвращаемыйТип имя (парам 1, парам2,„) объявления параметров
{
ОбъявленияПеременных
программныйОператор
программныйОператор
return выражение,
}
```
Здесь в круглых скобках указываются только имена параметров. Если функция не принимает никаких аргументов, то указываются только левая и правая круглые скобки. Тин каждого параметра объявляется вне круглых скобок и перед левой фигурной скобкой, открывающей определение функции. Например, ниже определяется функция с именем rotate, которая принимает два парамегра с именами value и п.
```
unsigned int rotate (value, n) unsigned int value; int n;
{
}
```
Первый аргумент определяется как unsigned int и второй как int.

Перед определением функции можно поместить ключевое слово inline как указание компилятору. Некоторые компиляторы заменяют вызов такой функ-ции конкретным кодом самой функции, что ускоряет выполнение. Ниже пока-зан соответствующий пример.
```
inline int min (int a, int b)
{
return ( a < b ? a : b);
}
```

### Вызов функции
#### Общий формат
```
имя ( арг1, арг2,..)
```
Происходит вызов функции имя, и значения арг1, арг2, ... передаются функ-ции как аргументы. Если функция не принимает никаких аргументов, указы-ваются только открывающая и закрывающая круглые скобки (например, initialize 0).

Если вызывается функция, которая определена после самого вызова или находится в другом файле, то необходимо включить объявление прототипа для этой функции, которое имеет следующий общий формат.
```
возвращаемыйТип имя (тип1 парам 1, тип2 парам2, .. )
```
Это указывает компилятору тип возвращаемого значения функции, число аргументов, которое она принимает, и тип каждого аргумента. Например, в строке
```
long double power (double x, int n);
```
содержится объявление power как функции, которая возвращает значение типа long double и принимает два аргумента типа double и типа int. Имена аргументов внутри круглых скобок на самом деле являются фиктивными именами, и они могут быть опущены, то есть
```
long double power {double, int); означает то же самое.
```
Если компилятор уже встретил определение функции или объявление про-тотипа для этой функции, то при вызове функции тип каждого аргумента пре-образуется (там, где возможно) в соответствии с типом, который объявлен в функции.

Если компилятор не встретил ни определения функции, ни объявления про-тотипа, то он предполагает, что функция возвращает значение типа int, автома-тически преобразует все аргументы типа float в тип double и выполняет целочисленное расширение любых целых аргументов, как описано выше в разделе «Преобразование базовых типов данных». Другие аргументы функции передаются без преобразования.

Функции, которые принимают переменное число аргументов, должны быть объявлены соответствующим образом. В противном случае компилятор будет предполагать, что функция принимает фиксированное число аргументов, ос-новываясь на числе аргументов, фактически использованных при вызове фун-кции.

Если функция была определена в старом формате (см. выше раздел «Определение функции»), то объявление для такой функции имеет следующий формат.
```
возвращаемыйТип имя ();
```
Аргументы, передаваемые такой функции, преобразуются в соответствии с описанием в предыдущем абзаце.

Для функций, возвращаемый тип которых объявлен как void, компилятор выводит сообщение для любых вызовов, где делается попытка использования возвращаемого значения.

Все аргументы передаются функции по их значению, поэтому их значения не могут быть изменены функцией. Но если функции передается указатель, то функция может изменить значения, которые указываются этим указателем, но она все же не может изменить значение самой переменной-указателя.

### Указатели на функции
Имя функции без последующей пары круглых скобок создает указатель на эту функцию. К имени функции можно также применить адресный оператор, что-бы создать указатель на эту функцию.

Если fp — указатель на функцию, то соответствующую функцию можно вызвать, написав
```
fp()
```
или
(*fp)()
Если функция принимает аргументы, они должны быть указаны в круглых скобках.

## Классы
В этом разделе приводятся сведения о синтаксисе и семантике классов.

### Определение класса
В определение класса включается объявление переменных экземпляра и мето-дов в секции interface, а также определение кода для каждого метода в секции implementation.
#### Секция interface
##### Общий формат
```
@interface имяКласса: родительскийКласс <протокол, ...>
{
объявления ПеременныхЭкземлляра
}
объявлениеМегода
объявлениеМегода
@end
```
Класс имяКласса объявляется с помощью родительского класса родительс-кийКласс. Если имяКласса принимает также один или несколько формальных протоколов, то имена протоколов перечисляются в угловых скобках после ро-дительского класса. В этом случае соответствующая секция implementation должна содержать определения всех методов из перечисленных протоколов.

Если двоеточие и родительскийКласс не указаны, это означает, что объявляется новый корневой класс.

##### Объявления переменных экземпляра
В необязательной секции объявленияПеременныхЭкземплярауказываются тип и имя каждой переменной экземпляра для данного класса. Каждый экземпляр класса имяКласса получаег свой собственный набор этих переменных плюс переменные, наследуемые из класса родительскийКласс. Доступ к таким переменным можно осуществлять непосредственно по имени в методах экземпляра, определенных в классе имяКласса, или из подклассов класса имяКласса. Если доступ ограничен директивой @private, то подклассы не могут осуществлять доступ к таким пере-менным (см. выше раздел «Переменные экземпляра»).

Методы класса не имеют доступа к переменным экземпляра.

##### Объявления свойств
**Общий формат**
```
@property {атрибуты) списокИмен-,
```
Объявляются свойства с помощью заданного списка атрибутов с разделите­
лями-запятыми.

списокИмен — это список с разделителями-запятыми, содержащий имена свойств объявляемого типа.
```
{тип) имяСвойства1, имяСвойства2, имяСвойстваЗ,...
```
Директива @property может присутствовать в любом месте секции объявления метода для класса, протокола или категории.

Табл. В.7. Атрибуты свойств

| Атрибут    | Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| assign     | Используется простое присваивание, чтобы задать значение переменной экземпляра в методе-установщике (setter). (Это атрибут по умолчанию.)                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| сору       | Используется метод сору, чтобы задать значение переменной эк­земпляра.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| getter=имя | Используется имя для имени метода-получателя (getter) вместо имени имяСвойства, которое используется по умолчанию для синтезируемого метода-получателя.                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| nonatomic  | Значение может быть возвращено непосредственно из синтезируемого метода-получателя. Если этот атрибут не объявлен, то методы доступа (accessor) действуют с атрибутом atomic; это означает, что доступ к переменным экземпляра защищен блокировкой mutex. Это обеспечивает защиту в среде с несколькими потоками за счет того, что операция get или set выполняется только в одном потоке. Кроме того, по умолчанию в среде без сборки мусора синтезируемый метода-получатель будет удерживать (retain) и автоматически высвобождать (autorelease) свойство, прежде чем возвратить его значение. |
| ~fwrite    | Значение свойства можно читать и задавать. Компилятор предполагает, что вы сами предоставили метод-получатель и метод-установщик (getter и setter), или он будет синтезировать оба метода, если используется директива @synthesize.                                                                                                                                                                                                                                                                                                                                                              |
| retain     | Свойство должно удерживаться (retain) во время присваивания. Этот атрибут можно указывать только для типов Objective-C.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| setter=имя | Используется имя для имени метода-установщика (setter) вместо заданного имени имяСвойства, которое используется по умолчанию для синтезируемого метода доступа.                                                                                                                                                                                                                                                                                                                                                                                                                                  |

Можно указывать только один из атрибутов assign, сору или retain. Если у вас не используется сборка мусора, то один из этих атрибутов должен быть использован явным образом; в противном случае вы получите предупреждение от компилятора. Если у вас используется сборка мусора и вы не указали один из этих трех атрибутов, то будет применяться атрибут по умолчанию assign. В этом случае компилятор выдаст предупреждение, только если данный класс подчиняется протоколу NSCopying (в этом случае для свойства может потребоваться атрибут сору, а не assign).
Если вы используете атрибут сору, то синтезируемый метод-установщиком применяет метод сору данного объекта. Это дает немутабельную копию. Если вам требуется мутабсльная копия, то вы можете предоставить вместо этого свой собственный метод-установщик.

##### Объявление метода
**Общий формат**
```
мТип (возвращаемыйТип) имя??1: (тип1) парам 1 имя??2: (тип2) парам2, ...;
```
Объявляется метод имя 1:имя2:.., который возвращает значение типа возвраща-емыйТип; он имеет формальные параметры парам1, парам2\   ларам/ объявляется с типом 7ил/, парам2с типом тип2, и т.д.

Любое из имен после имя/ (то есть имя2,...) можетбыть опущено; в этом слу-чае все же используется двоеточие в качестве заполнителя, и оно становится частью имени метода (см. следующий пример).

Если в качестве м Тил указан знак +, это означает, что объявляется метод класса, а если знак -, то объявляется метод экземпляра.

Если объявляемый метод наследуется из родительского класса, то новое определение подавляет определение родительского класса. В этом случае все же имеется доступ к методу родительского класса, и для этого нужно передать сообщение к super. Вызов методов класса происходит, когда соответствующее сообщение передается объекту-классу, а вызов методов экземпляра происходит, когда соответствующее сообщение передается экземпляру класса. Методы класса и методы экземпляра могут иметь одинаковые имена.

Одинаковое имя метода может также использоваться в различных классах. Способность объектов различных классов реагировать на методы с одинако-выми именами называется полиморфизмом (polymorphism).

Если метод не возвращает значения, то возвращаемыйТип указы вас гея как void. Если метод возвращает значение типа id, то возвращаемыйТип можно не указывать, хотя практика надежного программирования рекомендует указы вать id к? возвращаемый тип.

Если используется ,... в качестве последнего (или единственного) параметра в списке, то метод принимает переменное число параметров, например,
```
-(void) print: (NSSTRING *) format, ...
{
}
```
Ниже приводится пример объявления класса в секции interface: объявляется класс с именем Fraction, родительским классом для которого является NSObject.
```
@interface Fraction: NSObject
{
int numerator, denominator;
)
+(Fraction *) newFract;
-(void) setTo: (int) n : (int) d;
-(void) setNumerator: (int) n andDenominator: (int) d;
-(int) numerator;
-(int) denominator;
@end
```
Класс Fraction имеет две целые переменные экземпляра с именами numerator и denominator. Он также содержит один метод класса с именем newFract, который возвращает объект типа Fraction. В него включены также два метода экземпляра с именами setTo:: и setNumerator:andDenominator:. Каждый из них принимает два аргумента и не возвращает никакого значения. В нем содержатся также два метода экземпляра с именами numerator и denominator, которые не принимают никаких аргументов и возвращают значение типа int.

#### Секция implementation
##### Общий формат
```
@implementation имяКласса;
    определениеМетода
    определениеМетода
    ...
@end
```
Определяется класс с именем имяКлаеса. Родительский класс и переменные экземпляра обычно не объявляются повторно в секции implementation (хотя это можно делать), поскольку они уже объявлены ранее в секции interface.

Если реализуются методы ые из какой-либо категории (см. ниже раздел «Оп-ределение категории»), то в секции implementation должны быть определены все методы, объявленные в секции interface. Если в секции interface были указаны один или несколько протоколов, то должны быть определены все методы этих протоколов — неявным образом через наследование или явным образом путем определения в секции implementation.

Каждое определениеМетода содержит код, который будет выполняться при вызове этого метода.

##### Определение метода
**Общий формат**
```
мТип (возвращаемый Тип) имя1: (тип1) парам 1: имя2(тип2) парам2, ...
{
обьявленияПеременных
программныйОператор
программныйОператор
return выражение;
}
```
Определяется метод имя1:имя2:.., который возвращает значение типа возвращаемыйТип и имеет формальные параметры парам}, парам2,....; парам} объявляется с типом тип}, парам2с типом тип2, и т.д. Если в качестве мТип указан знак +, это означает, что определяется метод класса, а если знак то определяется метод экземпляра. Это объявление метода должно быть согласовано с соответствующим объявлением метода в секции interface или с определенным ранее определением протокола.

В методе экземпляра можно обращаться к переменным экземпляра данного класса и любым переменным, которые унаследованы этим методом непосред-ственно по имени. Если определяется метод класса, он не может обращаться к каким-либо переменным экземпляра.

Внутри метода можно использовать идентификатор self для ссылки на объект, для которого вызывается метод, то есть на получателя сообщения. Внутри метода можно использовать идентификатор super для ссылки на родительский класс объекта, для которою вызывается метод.

Если возвращаемыйТип не указан как void, то в определении метода должны содержаться один или несколько операторов relume выражениями типа возвра-щаемыйТип. Если возвращаемыйТип указан как void, использовать оператор return не обязательно, и в случае использования он не может содержать возвращаемого значения.

Ниже приводится пример определения метода, где определяется метод setNumerator:andDenominator: в соответствии с его объявлением (см. выше раздел «Объявление метода»),
```
-(void) setNumerator: (int) n andDenominator: (int) d
{
numerator = n; denominator = d;
}
```
В этом методе двум его переменным экземпляра присваиваются передавае-мые аргументы и не выполняется оператор return (хотя это можно сделать), по-скольку в объявлении метода он не возвращает никакого значения.

В объявлениях для аргументов одномерных массивов не обязательно указывать число элементов этого массива. Для многомерных массивов нужно обязательно указать размер каждой размерности, кроме первой.

Внутри метода можно объявлять локальные переменные, и они обычно объявляются в начале определения метода. Память для автоматических локальных переменных выделяется при вызове метода, и она освобождается при выходе из метода.

Описание оператора return см. ниже в разделе «Оператор return».

##### Синтезируемые методы доступа
**Общий формат**
```
@synthesize свойство1, свойство2, ...
```
Здесь указывается, что для перечисленных свойств свойство}, свойство2,... должны быть синтезированы методы доступа.

В списке можно использовать форму записи свойство = instance_var, чтобы ука-зать, что свойство будет связано с переменной экземпляра instanceуаг. Синтези-руемые методы будут иметь характеристики, базирующиеся на атрибутах, объявленных ранее для свойства с помощью директивы @property.

### Определение категории
**Общий формат**
```
@interface имяКласса (имяКатегории) <протокол,...>
    объявлениеМетода
    объявлениеМетода
@end
```
Здесь объявляется категория имяКатегории для класса имяКласса с перечислен-ными методами. Если указаны один или несколько протоколов, категория под-чиняется перечисленным протоколам.

Компилятору должно быть известно имяКласса из предшествующего объяв-ления в секции @interface для этого класса. Можно объявить любое число кате-горий влюбом числе различных исходных файлов. Перечисленные методы ста-новятся частью данного класса и наследуются подклассами.

Категории уникально определяются парами ямяКласса/имяКатегории. Например, в определенной программе может быть только одна категория NSArray (Private). Но можно использовать одинаковые имена категорий. Например, определенная программа может содержать категорию NSArray (Private) и категорию NSString (Private), и это будут различные категории.

Вы не обязаны реализовать методы категории, которые не собираетесь ис-пользовать.

Категория может только расширять определение класса дополнительными методами или переопределять существующие методы этого класса. Она не мо-жет определять какие-либо новые переменные экземпляра для этого класса.

Если в нескольких категориях объявлен методе одним и тем же именем для одного класса, то нельзя определить, какой метод будет выполняться при вы-зове.
Например, в следующем примере для класса Complex определяется катего-рия с именем ComplexOps, содержащая четыре метода экземпляра.
```
#import «Complex.h»
@interface Complex (ComplexOps)
-(Complex *) abs;
-(Complex *) exp;
-(Complex *) log;
-(Complex *) sqrt;
@end
```
Можно предположить, что где-либо будет присутствовать секция implementation, в которой реализуются один ли несколько из этих методов.
```
#import "ComplexOps.h"
@implementation Complex (ComplexOps)
-(Complex *) abs
{
}
-(Complex *) exp
{
}
-(Complex *) log
{
}
-(Complex *} sqrt
{
}
@end
```
Категория, содержащая методы, которые будут реализоваться другими подклассами, называется неформальным (informal) протоколом или абстрактной (abstract) категорией. В отличие от формальных протоколов, компилятор не выполняет никаких проверок на подчинение неформальному протоколу. На этапе выполнения объект может проверяться на подчиненность неформальному протоколу в зависимости от конкретного метода.

### Определение протокола
**Общий формат**
```
@protocol имяПроюкола <протокол, ...>
    обьявленияМетодов
@optional
    обьявленияМетодов
@required
    обьявленияМетодов
@end
```
Здесь определяется протокол имяПроюкола с указанными методами. Если включены другие протоколы, то протокол имяПротокола принимает (adopt) перечисленные протоколы.

Это определение называют также определением формального протокола. Класс подчиняется (conform) протоколу имяПротокола, если в нем определяются или наследуются все обязательные (required) методы, объявленные в этом протоколе, а также все методы любых других перечисленных протоколов. Компилятор проверяет подчиненность и выводит предупреждение, если класс не подчиняется объявленному формальному протоколу. На этапе выполнения объекты могут проверяться или Tie проверяться на подчиненность формальному протоколу.

Перед списком методов, реализация которых не обязательна, может ставиться директива @optional. В дальнейшем можно использовать директиву @required, чтобы обновить список обязательных методов, которые должны быть реализованы для подчинения протоколу.

Протоколы часто не привязываются к какому-либо определенному классу, но применяются как способ определения общего интерфейса, используемого несколькими классами.

#### Специальные модификаторы типов
Для типов параметров и возвращаемого значения методов, объявляемых в про-токолах, могут использоваться спецификаторы типов, которые приводятся в таблице В.8. Эти спецификаторы используются для распределенных объектных приложений.

Табл. В.8. Специальные модификаторы типов в протоколах

| Спецификатор | Описание                                                                                                                                                                                                                                      |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| in           | Аргумент относится к объекту, значение которого будет изменено отправителем и передано (т.е. скопировано) назад получателю.                                                                                                                   |
| out          | Аргумент относится к объекту, значение которого будет изменено получателем и передано назад отправителю.                                                                                                                                      |
| inout        | Аргумент относится к объекту, значение которого будет изменяться как отправителем, так и получателем, и будет передаваться между ними; это спецификатор по умолчанию.                                                                         |
| oneway       | Используется для объявлений типа возвращаемого значения; обычно используется (one way void), чтобы указать, что объект, вызвавший этот метод, не обязан ожидать получения возвращаемого значения, то есть метод может выполняться асинхронно. |
| bycopy       | Аргумент или возвращаемое значение должно копироваться.                                                                                                                                                                                       |
| byref        | Аргумент или возвращаемое значение передается по ссылке и не копируется.                                                                                                                                                                      |

### Объявление объекта
**Общий формат**
```
имяКласса *var1, *var2, ...;
```
Здесь определяются переменные varl, var2,... как объекты из класса тяКласса. Отметим, что это объявление переменных-указателей, при котором не выделяется пространство для конкретных данных, содержащихся в каждом объекте. В объявлении
```
Fraction *myFract;
```
определяется myFract как объект класса Fraction или, точнее, как указатель на этот объект. Чтобы фактически выделить пространство для структуры данных класса Fraction, нужно вызвать обычно alloc или новый метод для этого класса, например,
```
myFract = [Fraction alloc];
```
В результате для объекта типа Fraction будет выделен достаточный обьем па-мяти и возвращен указатель на этот объект, который будет присвоен переменной myFract. Переменную myFract часто называют объектом или экземпляром класса Fraction. Если метод alloc определен в корневом объекте, всем переменным эк-земпляра нового выделяемого объекта присваивается значение 0. Но это не оз-начает, что объект инициализирован должным образом; прежде чем использовать этот объект, для него должен быть вызван какой-либо метод инициализации (например, init).

Поскольку переменная myFract была объявлена явным образом как объект из класса Fraction, она называется переменной со статическим контролем типа. Компилятор может проверять применение переменных со статическим контролем типа на согласованность с определением класса с точки зрения правильности использования методов, а также типов их аргументов и возвращаемых значений.

#### Объявление объекта с типом id
**Общий формат**
```
id <протокол,...> varl, var2, ...;
```
Здесь объявляются переменные varl, var2,... как объекты из неопределенного класса, который подчиняется протоколам, перечисленным в угловых скобках. Список протоколов не является обязательным.

Переменным типа id можно присваивать объекты из любого класса, и наоборот. Если указаны один или несколько протоколов, компилятор проверяет, что методы, используемые из перечисленных протоколов для любой из объявленных переменных, используются соответствующим образом, то есть в соответствии с типами аргументов и возвращаемых значений для методов, объявленных в формальном протоколе.

Например, в строках
```
id <MathOps> number;
result = [number add: number2];
```
компилятор проверяет, определяется ли метод add: в протоколе athOps. Если да, то компилятор проверяет для этого метода согласованность с типами аргументов и возвращаемого значения. Например, если метод add: принимает целый аргумент, а вы передаете ему объект класса Fractior, то компилятор выводит соответствующее сообщение.

Система следит за классом, которому принадлежит каждый объект; поэтому на этапе выполнения она может определить класс объекта и затем выбрать для вызова подходящий метод. Эти две процедуры называются соответственно динамическим контролем типов (dynamic typing) и динамическим связыванием (dynamic binding).

### Выражения с сообщениями
#### Формат 1
```
[получатель имя1: арг1 имя2: арг2, имяЗ: аргЗ.. ]
```
Выполняется вызов метода имя!:имя2:имяЗ из класса, указанного получателем, и значения арг1, арг2,... передаются как аргументы. Эго называется выражением с сообщением (message expression). Значением выражения является значение, воз-вращаемое методом, или void, если метод объявлен соответствующим образом и не возвращает никакого значения. Тип этого выражения совпадает с типом, объявленным для вызываемого метода.

#### Формат 2
```
[получатель имя];
```
Если метод не принимает никаких аргументов,то этот формат используется для вызова метола имя из класса, указанного получателем.

Если получатель имеет тип id, то компилятор ищет среди объявленных классов определение или наследуемое определение указанного метода. Если не найдено такого определения, компилятор выводит предупреждение, что получатель не ответит на указанное сообщение. Кроме того, предполагается, что метод возвращает значение типа id и преобразует любые аргументы типа float в тип double, а также выполняет целочисленное расширение для любых целых аргументов, как описано выше в разделе «Преобразование базовых типов данных». Другие аргументы метода передаются без преобразования.

Если получатель является объе кто м - классом (который можно создать, просто указав имя класса), то вызывается указанный метод класса. В противном случае получатель является экземпляром класса, и тогда вызывается соответствующий метод экземпляра.

Если получатель является переменной или выражением со статическим конт-ролем типа, то компилятор ищетметод в определении класса (или среди любых наследуемых методов) и преобразует любые аргументы (когда это возможно), чтобы он и соответствовали ожидаемым аргументам данного метода. Например, если метод должен получать значение с плавающей точкой и ему передано значение целого тина, соответствующий аргумент автоматически преобразуется при вызове этого метода.

Если получатель является указателем на null-объект, то есть nil, ему тоже можно передавать сообщения. Если метод, связанный с сообщением, возвращает объект, то выражение с этим сообщением дает значение nil. Если метод не возвращает какого-либо объекта, то значение этого выражения не определено.

Если один и тот же метод определен более чем в одном классе (путем явного определения или врезультате наследования), компилятор проверяет среди этих классов соответствие типам аргументов и возвращаемою значения.

Все аргументы передаются методу по значению, поэтому их значения не могут быть изменены методом. Если методу передается указатель, то метод может изменять значения, на которые ссылается этот указатель, но метод все же не может изменять значение самого указателя.

#### Формат 3
```
получатель.свойство
```
Это вызов getter-метода, то есть метода-получателя (по умолчанию свойство) для получателя, если выражение не используется как lvalue-выражение (см. Формат 4). Имя getter-метода можно изменять с помощью директивы @property, и тогда это будет вызываемый метод.

Если используется имя getter-метода по умолчанию, то приведенное выше выражение эквивалентно следующему.
```
[получатель свойство]
```

#### Формат 4
```
получатель.свойство = выражение
```
Это вызов setter-метода (метода-установщика), связанного со свойством свой-ство, и в качестве его аргумента передается значение выражения. По умолчанию вызывается setter-метод ^Свойство:, если для этого свойства не было назначено имя другого setter-метода с использованием предшествующей директивы @property.

Если используется имя setter-метода по умолчанию, то приведенное выше выражение эквивалентно следующему.
```
[получатель set Свойство: выражение]
```

## Программные операторы
Программным оператором (program statement) является любое допустимое вы-ражение (обычно присваивание или вызов функции), которое закапчивается точкой с запятой, или это один из специальных операторов, описанных ниже. Перед любым оператором можно ставить необязательную метку; метка состоит из идентификатора, после которого ставится символ «двоеточие» (см. также оператор goto).

### Составные операторы
Программные операторы, содержащиеся в фигурных скобках, называются со-ставным оператором, или блоком, и могут находиться в любом месте программы, где допустим хоть один оператор. Блок может содержать свой собственный набор объявлений переменных, которые могут замещать одноименные переменные, определенные вне этого блока. Областью действия таких локальных переменных является блок, в котором они определены.

### Оператор break
**Общий формат**
```
break;
```
Выполнение оператора break внутри области действия оператора for, while, do или switch вызывает прекращение работы этого оператора. Выполнение про-должается с оператора, непосредственно следующего после цикла или пере- ключалеля (switch).

### Оператор continue
Общий формат
```
continue;
```
Выполнение оператора continue внутри цикла вызывает пропуск операторов, которые следуют в этом цикле непосредственно после continue. В проти виом слу-чае выполнение цикла продолжается обычным образом.

### Оператор do
Общий формат
```
do
    программный Оператор
while (выражение);
```
Если выражение имеет ненулевое значение, то выполняется программныйОпера- юр. Отметим, что поскольку выражение вычисляется каждый раз после того, как выполнен программныйОпераюр, здесь гарантируется, что программныйОператор будет выполнен хотя бы один раз.

### Оператор for
#### Формат 1
```
for (выражение_ 1; выражение_2; выражение_3) програтныйОператор
```
Выражение_1 вычисляется один раз, когда начинается выполнение цикла. Затем вычисляется выражение_2. Если это выражение имеет ненулевое значение, то выполняется программныйОператор и затем вычисляется выражение_3. Это про-исходит, пока выражение_2 имеет ненулевое значение. Поскольку выражение_2вычисляется каждый раз перед тем, как выполняется программныйОператор, этот оператор может быть никогда не выполнен, если выражение_2 имеет значение 0 при первом входе в цикл.

Для выражения_ 1 можно объявить переменные, локальные для данного цикла for. Эти переменные действительны в области действия этого цикла for. Например, в
```
for (int i = 0; i < 100; ++i)
```
объявляется целая переменная i, которой присваивается начальное значение 0, когда начинается цикл. Эта переменная доступна для любых операторов внутри этого цикла, но она недоступна после завершения цикла.

#### Формат 2
```
for (var in выражение) программныйОператор
```
В этом варианте цикла for задается быстрое перечисление (fast enumeration). Для переменной var можно также объявлять ее тип, что делает область ее действия локальной для данного цикла for. Выражение выражение дает результат, который подчиняется протоколу NSFastEnumeration. Обычно выражение является кол-лекцией, например, массивом или словарем.

При каждом прохождении цикла for переменной var присваивается следующий объект, полученный при начальном вычислении выражения, и выполняется тело цикла, которое представляет программныйОпзратор. Выполнение цикла за-вершается, ког да выполнен перебор всех объектов в выражении.

Отметим, что в данном цикле for нельзя изменить содержимое коллекции. Если это происходит, то создается исключение.

Для массива происходит перечисление по порядку каждого из его элементов. Для словаря происходит перечисление каждого ключа без определенного порядка. Для набора (set) происходит перечисление каждого члена набора без определенного порядка.

### Оператор goto
Общий формат
```
goto идентификатор;
```
Выполнение оператора goto вызывает передачу управления непосредственно оператору с меткой идентификатор. Оператор с меткой должен находиться в той же функции или методе, где и goto.

### Оператор if
#### Формат 1
```
if {выражение)
    программныйОператор
```
Если результат вычисления выражения не равен нулю, то выполняется программ-ныйОператор', иначе он пропускается.

#### Формат 2
```
if (выражение)
    программныйОператор
else
    программныйОператор2
```
Если значение выражения не равно нулю, то выполняется программныйОпера- тор1; иначе выполняется программныйОператор2. Если программный0ператор2 является еще одним оператором if, образуется цепочка if-else if, например,
```
if {выражение1)
    программныйОператор
else if (выражение2)
    программныйОператор2
else
    программныйОператорп
```
Предложение else всегда связано с последним оператором if, который не со-держит else. При необходимости можно использовать фигурные скобки, чтобы изменить эту связь.

### Оператор null
**Общий формат**
```
;
```
Выполнение null-оператора (пустого оператора) не оказывает никакого влияния и используется в основном, чтобы выполнить требование программного оператора в цикле for, do или while. В следующем операторе выполняется копирование символьной строки, указанной с помощью from, в строку, указанную с помощью to.
```
while (*to++ = *from++ )
    ;
```
В этом операторе используется null-оператор, чтобы выполнить требование того, что после выражения цикла while должен присутствовать программный оператор.

### Оператор return
#### Формат 1
```
return;
```
Выполнение оператора return вызывает немедленный возврат выполнения программы в вызывающую функцию или метод. Этот формат можно использовать только для возврата из функции или метода, которые не возвращают никакого значения.

Если выполнение доходит до конца функции или метода, не встретив оператор return, то происходит возврат, как при выполнении оператора return в этом формате, поэтому в таком случае не возвращается никакого значения.
#### Формат 2
```
return выражение;
```
Вызывающей функции или методу возвращается значение выражения. Если тип выражения не согласуется с типом возвращаемого значения, указанным в объявлении функции или метода, то его значение автоматически преобразуется перед возвратом в объявленный тип.

### Оператор switch
**Общий формат**
switch (выражение)
{
    case константа_1:
        программный оператор
        программный оператор
        ...
        break;
    case кон стан та_2:
        программный оператор
        программный оператор
        ...
        break;
    case константа_п;
        программный оператор
        программный оператор
        ...
        break;
    default:
        программный оператор
        программный оператор
        ...
        break;
}
Выполняется вычисление и сравнение выражения со значениями константных выражений константа_1, константа_2, константап. Если значение выражения совпадает с одним из этих case-значений, то выполняются последующие про-граммные операторы. Если ни одно из case-значений не совпадает со значением выражения, то выполняется (если он включен) вариант по умолчанию default. Если вариант default не включен, то не выполняются никакие операторы, включенные в switch.

Результат вычисления выражения должен быть целого типа, и никакие два варианта case не должны иметь одинаковое значение. Отсутствие оператора break в определенном case-варианте вызывает продолжение выполнения в следующем case-варианте.

### Оператор while
**Общий формат**
```
while (выражение)
    программныйОператор
```
Если значение выражения не равно нулю, выполняется программныйОператор. Поскольку выражение вычисляется каждый раз перед тем, как выполняется прог-раммныйОператор, этот оператор может никогда не выполняться.

## Обработка исключений
Для обработки исключений во время выполнения нужно включить операторы, которые могут генерировать исключение, в блок @try, который имеет общий формат
```
@try
    программныйОператор 1
@catch (исключение)
    программныйОператор 2
@catch (исключение)
    ...
@finally
    программныйОператор n
```
Если исключение выдает программныйОператор 1, то проверяются (по поряд-ку) последующие блоки @catch на совпадение соответствующего исключения с выданным исключением. Если да, то будет выполнен соответствующий программ-ныйОператор. Независимо от факта выдачи и перехвата исключения будет вы-полнен блок @finally (если он задан).

## Препроцессор
Препроцессор анализирует исходный файл до того, как компилятор рассмотрит сам код. Препроцессор выполняет следующие действия.
1. Он заменяет триграммы (группы из трех последовательных символов) на их эквиваленты (см. выше раздел «Составные операторы»).
2. Он объединяет в одну с троку любые строки, которые заканчиваются обратным слешем (\\).
3. Он разделяет программу на поток маркеров.
4. Он удаляет комментарии, заменяя их одним пробелом.
5. Он обрабатывает мрепроцессорные директивы (см. ниже раздел «Директивы препроцессора») и раскрывает макросы.

### Последовательности из триграмм
Для обработки наборов символов, не соответствующих ASCII, используются следующие трехсимвольные последовательности (триграммы), которые распоз-наются и обрабатываются специальным образом там, где они находятся в про-грамме (а также внутри символьных строк).

| Триграмма | Значение |
|-----------|----------|
| ??=       | #        |
| ??(       | [        |
| ??)       | ]        |
| ??<       | {        |
| ??>       | }        |
| ??/       | \        |
| ??’       | ^        |
| ??!       | &vert;   |
| ??-       | ~        |

### Директивы препроцессора
Все директивы препроцессора начинаются с символа #, когорый должен быть первым символом в строке, отличным от пробела. После # могут следовать один или несколько символов «пробел» или tab.

#### Директива #define
##### Формат 1
```
#define имя текст
```
Определяется имя идентификатора для препроцессора, это имя связывается с текстом, который начинается после первого пробела, следующего за именем, и заканчивается концом строки. При последующем использовании имени в программе оно заменяется текстом.

##### Формат 2
```
#define имя (парам_ 1, парам_2,..., парам_п) текст
```
Определяется макрос имя, принимающий аргументы парам_1, парам_2, ..., парам_п, каждый из которых является идентификатором. При последующем ис-пользовании имени в программе со списком аргументов происходит подстановка текста, причем аргументы вызова этого макроса заменяют все экземпляры соответствующих параметров внутри текста.

Если макрос принимает переменное число параметров, то в конце списка аргументов используются три точки. Остальные аргументы в списке обозначаются специальным идентификатором _VA_ARGS_. Например, ниже определяется макрос с именем myPrintf, принимающий переменное число аргументов.
```
#define myPrintf(...) printf ("DEBUG:" _VA_ARGSJ;
```
Этот макрос можно использовать, например, в форме
```
myPrintf ("Hello world!\n"); или
myPrintf ("i = %i, j = %i\n", i, j);
```
Если для определения требуется более чем одна строка, то для продолжения каждой строки ее нужно заканчивать символом обратного слеша. После опре-деления имени его можно использовать в любом месте данного файла.

В директивах «define, которые принимают аргументы, можно использовать оператор #, после которого следует имя аргумента. Препроцессор помещает в кавычки фактическое значение, передаваемое макросу при его вызове, то есть значение превращается в символьную строку. Например, определение
```
#define printint(x) printf (# х "= %d\n", х)
```
при вызове
```
printint (count);
```
раскрывается препроцессором как printf ("count" "= %i\n", count); или эквивалентно как
```
printf ("count = %i\n", count);
```
Препроцессор помещает символ \ перед любой кавычкой или символами \ при выполнении этой операции преобразования в строку. Например, в случае определения
```
#define str(x) # х вызов
sir (The string ,r\t"contains a tab)
```
раскрывается следующим образом
```
"The string \"\\t\"contains a tab"
```
В директивах «define, принимающих аргументы, допускается также оператор ##. Перед ним (или после него) ставится имя аргумента для макроса. Препроцессор берет значение, передаваемое при вызове макроса, и создает один маркер из этого аргумента и из маркера, который следует за ## (или предшествует ##). Например, в случае определения макроса
```
#define printx(n) print! ("%i\n", x «# n );
```
вызов
```
printx (5)
```
дает
```
printf ("%i\n", x5);
```
Определение
```
#define printx(n) printf ("x"« n "= %i\n", x ## n );
```
при вызове
```
printx(1O)
```
дает
```
printf ("xIO = %i\n", xIO);
```
после подстановки и конкатенации символьных строк.

Вокруг операторов « и #« можно не ставить пробелы.

#### Директива #error
##### Общий формат
```
#error текст
...
```
Указанный текст записывается препроцессором как сообщение об ошибке.

#### Директива #if
##### Формат 1
```
#if константное^выражение «endif
```
Вычисляется константное выражение. Если результат не равен нулю, то обрабаты-ваются все строки программы до директивы «endif; в противном случае они ав-томатически пропускаются и не обрабатываются препроцессором или компи-лятором.

##### Формат 2
```
#if константное_выражение_1
    ...
#elif константное_выражение_2
    ...
#elif константноевыражениеп
    ...
#else
    ...
#endif
```
Если константное выражение^ не равно нулю, то обрабатываются все строки программы до #elif, а остальные строки до «endif пропускаются. В противном случае, если константное_выражение_2не равно нулю, то обрабатываются все строки программы до следующей директивы #elif, а остальные строки до «endif про-пускаются. Если все константные выражения равны нулю, то обрабатываются строки после «else (если включена эта директива).

Как часть константного выражения можно использовать специальный оператор defined. Например, при использовании
```
#if defined (DEBUG)
    ...
#endif
```
будет обрабатываться код между «if и «endif, если ранее был определен иденти-фикатор DEBUG (см. также «ifdef в следующем разделе). Идентификатор не обя-зательно заключать в круглые скобки, то есть
```
#if defined DEBUG
```
действует точно так же.

#### Директива #ifdef
**Общий формат**
```
#ifdef идентификатор
    ...
#endif
```
Если значение идентификатора было ранее определено (с помощью «define или опции командной строки -D при компиляции программы), то обрабатываются все строки программы до «endif; в противном случае они пропускаются. Как и в случае директивы «if, с директивой «ifdef можно использовать директивы #elif и «else.

#### Директива #ifndef
**Общий формат**
```
#ifndef идентификатор
    ...
#endif
```
Если значение идентификатора не было ранее определено, то обрабатываются все строки программы до «endif; в противном случае они пропускаются. Как и в случае директивы «if, с директивой «ifndef можно использовать директивы #elif и «else.

#### Директива # import
##### Формат 1
```
#import "имяФайла"
```
Если файл имяФайла был ранее включен в программу, этот оператор пропус-кается. В противном случае препроцессор ищет сначала файл имяФайла в папках, которые определены реализацией. Обычно поиск начинается с той же папки, где содержится исходный файл, и если файл не найден, то выполняется поиск в последовательности стандартных мест, определенных реализацией. После того, как файл найден, его содержимое включается в программу в том месте, где находится директива «import. Препроцессорные директивы, содержащиеся во включенном файле, тоже анализируются. Поэтому сам включенный файл может содержать другие директивы «import или #include.

##### Формат 2
```
#import <имяФайла>
```
Если этот файл не был включен ранее, препроцессор ищет его только в стан-дартных местах. В частности, текущая папка исходных файлов исключается из поиска. В остальном действия, выполняемые после того, как файл найден, иден-тичны тому, что описано выше.

При любом формате можно указать определенное ранее имя, после чего происходит раскрытие этого имени. Например, можно использовать следующую последовательность.
```
#define ROOTOBJECT <NSObject.h>
...
#import ROOTOBJECT
```

#### Директива #include
Эта директива действует таким же образом, как #import, но не выполняется проверка предшествующего включения указанного header-файла.

#### Директива #line
**Общий формат**
```
#line константа "имяФайла"
```
Эта директива указывает компилятору, что последующие строки программы нужно обрабатывать в предположении, что имя исходного файла — имяФайла и что отсчет номеров строк во всех последующих строках начинается с константы. Если имяФайла не указано, то используется имя файла, указанное последней директивой «line, или имя исходного файла (если ранее не было указано никакого имени файла).

Директива «line в основном используется для задания имени файла и номера строки, которые выводятся при выдаче ошибки компилятором.

#### Директива # pragma
**Общий формат**
```
#pragma текст
```
Препроцессор выполнит некоторые действия, определенные реализацией. Например,
```
«pragma loop_opt(on)
```
вызывает специальную оптимизацию циклов в определенном компиляторе. Если эту директиву встретит компилятор, который не распознает указание loop_opt, то она будет игнорироваться.

#### Директива #undef
**Общий формат**
```
#undef идентификатор
```
Указанный идентификатор станиишен неопределенным для препроцессора. Последующие директивы #ifdef или «ifndef действуют так, как будто данный иден-тификатор никогда не был определен.

#### Директива \#
Это null-директива, и она игнорируется препроцессором.

### Заранее определенные идентификаторы
Следующие идентификаторы определены препроцессором.

| Идентификатор    | Описание                                                                                 |
|------------------|------------------------------------------------------------------------------------------|
| __LINE__         | Номер текущей компилируемой строки.                                                      |
| __FILE__         | Имя текущего компилируемого исходною файла.                                              |
| __DATE__         | Дата компилируемого файла в формате Мм дд гггг.                                          |
| __TIME__         | Время компилируемого файла в формате «чч:мм:сс».                                         |
| __STDC__         | Определен как 1, если компилятор согласуется со стандартом ANSI, и 0 в противном случае. |
| __STDC_H0STED__  | Определен как 1, если данная реализация поддерживается (hosted), и 0 в противном случае. |
| __STDC_VERSION__ | Определен как 199901L.                                                                   |