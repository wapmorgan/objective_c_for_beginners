# Глава 16. Работа с файлами
Foundation framework позволяет получать доступ к файловой системе для вы-полнения основных операций с файлами и папками (каталогами) с помощью NSFileManager, методы которого позволяют выполнять следующие операции.
* Создание нового файла.
* Чтение из существующего файла.
* Запись данных в файл.
* Переименование файла.
* Удаление файла.
* Проверка существования файла.
* Определение размера файла, а также других атрибутов.
* Создание копии файла.
* Проверка двух файлов на совпадение содержимого.

Многие из этих операций можно также выполнять с папками. Например, можно создать папку, прочитать ее содержимое или удалить се. Еще одна возможность — это возможность привязки (link) файлов. Привязка означает, что один и тот же файл может существовать под двумя именами и даже в двух различных папках.

Чтобы открыть файл и выполнить с этим файлом несколько операций чте-ния-записи, используются методы из NSFileHandle. Методы этого класса позво-ляют следующее.

* Открывать файл для чтения, записи или изменения (update — чтение и запись).
* Искать указанное местоположение в файле.
* Считывать или записывать заданное число байтов из файла или в файл.
Методы из NSFileHandle можно также применять к устройствами (сокетам). В этой главе мы будем работать только с обычными файлами.

## 16.1. Управление файлами и папками: NSFileManager
Файл или папка уникально указывается для NSFileManager с помощью имени пути доступа к файлу (pathname). Имя пути — это объект класса NSString, который может представлять относительное или полное имя пути. Относительное имя пути определяется относительно текущей папки. Например, имя файла copyl.m означает, что файл copyl.m находится в текущей папке. Символы «слэш» являются разделителями папок в указанном пути. Имя файла ch16/copy1.m тоже является относительным именем пути, указывая файл copyl .m, хранящийся в папке chi6, которая содержится в текущей папке.

Полные имена пути, которые также называют абсолютными именами пути, начинаются с ведущего слэша (/). Слэш на самом деле представляет папку, ко-торая называется корневой (root) папкой. На моем Мае полное имя пути к моей домашней папке — /Users/stevekochan. Этот путь представляет три папки: / (корне-вая папка), Users и stevekochan.

Специальный символ «тильда» (~) используется как сокращенное представ-ление домашней папки пользователя. Так, -linda — это сокращение для домашней папки пользователя linda, которая может быть представлена в виде пути / Users/linda. Отдельный символ «тильда» указывает домашнюю папку текущего пользователя, путь -/copyl.m означает ссылку на файл copyl.m, хранящийся в до-машней папке текущего пользователя. Другие специальные символы для пути в стиле UNIX, такие как точка (.) для текущей папки и .. для родительской папки, следует удалять из имен пути при работе с файлами в методах Foundation. Для этого можно использовать разнообразные утилиты, которые будут рассмат-риваться ниже в этой главе.

Избегайте фиксированных путей в своих программах. Как будет описано далее, имеются функции и методы, которые позволяют получать имя пути для текущей папки, домашней папки пользователя и папки для создания временных файлов. Обращайтесь к ним, насколько это возможно. Ниже мы покажем, что Foundation содержит функцию для получения списка специальных папок, таких как папки пользователя Documents.

В таблице 16.1 приводится сводка основных методов NSFileManager для работы с файлами. В этой таблице path (путь), path}, palh2,from (из) и !о (куда) — объекты класса NSString, attr (атрибут) - объект NSDictionary, handler - обработчик (хендлср) обратного вызова, который вы можете предоставлять для обработки ошибок. Если указать nil для handler, то выполняется действие по умолчанию. Для методов, возвращающих значение типа BOOL, это YES при успешном завершении операции и N0, если операцию не удалось выполнить. В этой главе не товорится о том, как писать хендлеры.

Табл. 16.1. Наиболее распространенные файловые методы класса NSFileManager

| Метод                                                                  | Описание                                                                |
|------------------------------------------------------------------------|-------------------------------------------------------------------------|
| -(NSData *) contentsAtPath: path                                       | Читает данные из файла.                                                 |
| -(BOOL) createFileAtPath: path contents: (BOOL) data attributes: attr  | Пишет данные (data) в файл                                              |
| -(BOOL) removeFileAtPath: path handler: handler                        | Удаляет файл.                                                           |
| -(BOOL) movePath: from toPath: to handler: handler                     | Переименовывает или перемещает файл (to не может существовать заранее). |
| -(BOOL) copyPath: from toPath: to handler: handler                     | Копирует файл (to не может существовать заранее).                       |
| -(BOOL) contentsEqualAtPath: path1 andPath: path2                      | Сравнивает содержимое двух файлов.                                      |
| -(BOOL) fileExistsAtPath: path                                         | Проверяет существование файла.                                          |
| -(BOOL) isReadableRleAtPath: path                                      | Проверяет, существует ли файл и доступен ли он для чтения.              |
| -(BOOL) isWritableFileAtPath: path                                     | Проверяет, существует ли файл и доступен ли он для записи.              |
| -(NSOictionary *) fileAttributesAtPath: path traverseLink: (BOOL) flag | Читает атрибуты файла.                                                  |
| -(BOOL) changeFileAttributes: attr atPath: path                        | Изменяет атрибуты                                                       |

Каждый из этих файловых методов вызывается в объекте NSFileManager, который создается при отправке сообщения defauttManager этому классу.
```
NSFileManager *fm;
...
fm = [NSFileManager defaultManager];
```
Например, для удаления файла todolist из текущей папки нужно создать сна-чала объект класса NSFileManager, как показано выше, и затем вызвать метод removeFileAtPath:.
```
[fm removeFileAtPath: @"todolist" handler: nil];
```
Возвращаемый результат можно проверить, чтобы убедиться, что удаление этого файла выполнено успешно.
```
if ([fm removeFileAtPath: @"todolistn handler: nil] == NO) {
    NSLog (@"Couldn’t remove file todolist"); (Нельзя удалить файл todolist)
    return 1;
}
```
Словарь атрибутов позволяет, в частности, указывать разрешения доступа к создаваемому файлу или получать либо изменять информацию для существую-щего файла. Разрешения по умолчанию задаются при создании файла с указанием значения nil в качестве этого параметра. Метод fileAttributesAtPadiitraverseUnk: возвращает словарь, содержащий атрибуты указанного файла. Параметр traverseLink: имеет значение YES или N0 для символических ссылок. Если файл задан символической ссылкой и указано значение YES, то возвращаются атрибуты файла привязки; если указано значение N0, то возвращаются атрибуты самой привязки (ссылки).

Для уже существующих файлов в словарь атрибутов включается такая ин-формация, как владелец файла, размер файла, дата его создания, и т.д. Каждый атрибут можно извлекать из словаря по его ключу; все эти ключи определены в <Foundation/NSFileManager.h>. Например, NSFileSize - это ключ для атрибута размера файла.

В программе 16.1 показаны основные операции с файлами. В этом примере предполагается, что в текущей папке есть файл testfile, содержащий следующие три строки текста.
```
This is a test file with some data in it. (Это тестовый файл с некоторыми данными.)
Here’s another line of data. (Это еще одна строка данных.)
And a third. (И третья.)
```
```
// Основные файловые операции
// Предполагается, что существует файл "testfile"
// в текущей рабочей папке

#import <Foundation/NSObject.h>
#import <Foundation/NSString.h>
#import <Foundation/NSFileManager.h>
#import <Foundation/N$AutoreleasePool.h>
#import <Foundation/NSDictionary.h>

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    NSString    *fName = @"testfile";
    NSFileManager *fm;
    NSDictionary    *attr;

    // Нужно создать экземпляр filemanager

    fm = [NSFileManager defaultManager];

    // Сначала проверим существование нашего тестового файла
    if ([fm fileExistsAtPath: fName] == NO) {
        NSLog (@"File doesn’t exist!"); (Файл не существует)
        return 1;
    }

    // Теперь создадим копию

    if ([fm copyPath: fName toPath: @"newfile" handler; nil] == NO) {
        NSLog (@"File copy failed!"); (Копирование файла не выполнено)
        return 2;
    }

    // Проверим эти два файла на идентичность

    if ([fm contentsEqualAtPath: fName andPath: @"newfile"] == NO) {
        NSLog (@"Files are not equal!"); (Файлы не равны)
        return 3;
    }

    // Теперь переименуем копию

    if {[fm movePath: @"newfile" toPath: @"newfile2" handler: nil] == NO) {
        NSLog (@"File rename failed!"); (Переименование файла не выполнено)
        return 4;
    }

    // Получим размер newfile2

    if ((attr = [fm fileAttributesAtPath: @"newfile2" traverseLink: NO]) == nil) {
        NSLog (@"Couldn't get file attributes!"); (Невозможно получить атрибуты файла)
        return 5;
    }

    NSLog (@"File size is %i bytes",
            [[attr objectForKey: NSFileSize] intValue]);

    // И, наконец, удалим исходный файл

    if ([fm removeFileAtPath: fName handler; nil] == NO) {
        NSLog (@"File removal failed!"); (невозможно удалить файл)
        return 6;
    }

    NSLog (@"All operations were successful!");
    // Вывод содержимого нового созданного файла
    NSLog(@"%@" [NSString stringWithContentsOfFile: @"newfile2" encoding:
        NSUTF8StringEncoding error: nil]);

    [pool drain];
    return 0;
}

```
Вывод программы 16.1
```
File size is 84 bytes (Размер файла 84 байта)
All operations were successful! (Все операции выполнены успешно)

This is a test file with some data in it. (Это тестовый файл с некоторыми данными.)
Here's another line of data. (Это еще одна строка данных.)
And a third. (И третья.)
```
Программа сначала проверяет, существует ли файл testfile. Если да, то про-грамма создает его копию и затем проверяет эти файлы на совпадение. Опытные пользователи UNIX обратят внимание, что мы не можем переместить или копировать файл в определенную папку, просто указав эту целевую папку для методов copy Path: toPath: и movePath:toPath:; в этой папке должно быть явно указано имя файла.

**Примечание.** Мы можем создать testfile с помощью Xcode, выбрав New File... (создать файл) в меню File. В появившейся левой панели нужно выделить Other (Другое) и затем выбрать в правой панели Empty File (Пустой файл). Введите testfile как имя файла и убедитесь, что он создается в той же папке, что и выпол-няемый файл — в вашей папке проекта Build/Debug.

Метод movePath:toPath: можно использовать для перемещения файла из одной папки в другую. (Или для перемещения целой папки.) Если оба пути указывают на одну и ту же папку (как в нашем примере), то результатом будет переименование файла. Например, в программе 16.1 мы переименовываем файл newfile в newfile2.

Как указывалось в таблице 16.1, при выполнении операций копирования, переименования или перемещения указанный целевой файл (to) не может су-ществовать заранее, иначе операция не будет выполнена.

Размер файла newfile2 определяется с помощью метода fileAttributesAtPath:traverseUnk:. Мы проверяем, что возвращается непустой (не nil) словарь, и затем используем метод NSDictionary objectForKey: для получения из словаря размера файла с помощью ключа NSFileSize. Затем выводится целое значение из словаря.

Метод removeFileAtPath:handler: удаляет наш исходный файл testfile.

И, наконец, метод NSString stringWithContentsOfFile: читает содержимое файла newfile2 в строковый объект, который затем передается как аргумент в NSLog для вывода.

В программе 16.1 проверяется успешность выполнения каждой файловой операции. Если операция не выполнена, выводится сообщение об ошибке с помощью NSLog, и программа завершает работу, возвращая ненулевое значение состояния выхода. Каждое ненулевое значение, которое соответствует ошибке в программе, уникальным образом определяет тип ошибки. Если вы пишете средства, запускаемые из командной строки, это полезный способ, поскольку другая программа может проверять возвращаемое значение, например, из сце-нария оболочки.

### Работа с классом NSData
При работе с файлами часто требуется читать данные во временную область хранения в памяти, которую называют буфером (buffer). Буфер часто использу-ется при сборе данных для последующего вывода в файл. Класс Foundation NSData позволяет легко создавать буфер, читать в него содержимое файла или писать содержимое буфера в файл. Для 32-битного приложения в буфере NSDATA можно хранить до 2 Гб. В случае 64-битного приложения в таком буфере можно хранить до 8 Эб (экзабайт), то есть 8000 Гб информации!

Можно определять немутабельные (NSData) или мутабельные (NSMutableData) области памяти. Мы ознакомим вас с методами данного класса в этой главе, а также в последующих главах.

В программе 16.2 показано, как читать содержимое файла в буфер, опреде-ленный в памяти.

Эта программа читает содержимое файла newftle2 и записывает его в новый файл с именем newfile3. В некотором смысле это реализация операции копиро-вания файла, хотя и не столь простая, как метод copy Rath :to Path: handler:,
```
// Создание копии файла
#import <Foundation/NSObject.h>
#import <Foundation/NSString.h>
#import <Foundation/NSFileManager.h>
#import <Foundation/NSAutoreteasePool.h>
#import <Foundation/N5Data.h>
int main (int arge, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] initj;
    NSFileManager *fm;
    NSData  *fileData;

    fm = [NSFileManager defaultManager];

    // Чтение файла newfile2
    fileData = [fm contentsAtPath: @"newfile2"];

    if (fileData == nil) {
        NSLog (@"File read failed!");
        return 1; 
    }

    // Запись данных в newfile3

    if ([fm createFileAtPath: @"newfile3" contents; fileData attributes: nil] == N0} {
        NSLog (@"Couldn’t create the copy!"); (Невозможно создать копию.)
        return 2;
    }

    NSLog (@"File copy was successful!"); (Копирование файла выполнено успешно)

    [pool drain];
    return 0;
}

```
Вывод программы 16.2
```
File copy was successful! (Копирование файла выполнено успешно)
```
Метод NSData contentsAtPath: просто принимает имя пути и читает содержимое указанного файла в область памяти (которую он создает). Метод возвращает в качестве результата объект области памяти или nil, если операцию чтения не удается выполнить (например, если этот файл не существует или недоступен для чтения).

Метод createRleAtPath:соntents:attributes: создает файл с указанными атрибутами (или использует атрибуты по умолчанию, если для аргумента атрибутов указано значение nil). Затем содержимое указанного объекта NSData записывается в файл. В нашем примере эта область памяти содержит данные прочитанного ранее файла.

### Работа с папками
В таблице 16.2 приводятся методы NSFileManager для работы с папками (катало-гами). Многие из этих методов аналогичны методам для обычных файлов из таблицы 16.1 (обозначения такие же, как в таблице 16.1).

Табл. 16.2. Наиболее распространенные методы

| Метод                                                     | Описание                                                                                       |
|-----------------------------------------------------------|------------------------------------------------------------------------------------------------|
| -(NSString *) currentDirectoryPath                        | Получает текущую папку.                                                                        |
| -(BOOL) changeCurrentDirectoryPath: path                  | Изменяет текущую папку.                                                                        |
| -(BOOL) copyPath: from toPath: to handler: handler        | Копирует структуру папки (to не может существовать заранее).                                   |
| -(BOOL) createDirectoryAtPath: path attributes: attr      | Создает новую папку.                                                                           |
| -(BOOL) fileExistsAtPath: path isDirectory: (BOOL *) flag | Проверяет, содержится ли данный файл в папке (результат YES/NO сохраняется в переменной flag). |
| -(NSArray *) directoryContentsAtPath: path                | Создает список содержимого папки.                                                              |
| -(NSDirectoryEnumerator *) enumeratorAtPath: path         | Перечисляет содержимое папки.                                                                  |
| -(BOOL) removeFileAtPath: path handler: handler           | Удаляет пустую папку                                                                           |
| -(BOOL) movePath: from toPath: to handler: handler        | Переименовывает или перемещает папку (to не может существовать заранее).                       |

В программе 16.3 показаны основные операции с папками.
```
// Основные операции с папками

#import <Foundation/NSObject.h>
#import <Foundation/NSSIring.h>
#import <Foundation/NSFileManager.h>
#import <Foundation/NSAutoreleasePool.h>

int main (int argc, char *argv[])
{
    NSAutoreleasePooi * pool = [[NSAutoreleasePool alloc] init];
    NSString    *dirName    = @"testdir";
    NSString    *path;
    NSFileManager   *fm;

    // Нужно создать экземпляр filemanager

    fm = [NSFileManager defaultManager];

    // Получение текущей папки

    path = [fm currentDirectoryPath];
    NSLog (@"Current directory path is %@", path); (Путь к текущей папке)

    // Создание новой папки

    if ([fm createDirectoryAtPath: dirName attributes: nil] == NO) {
        NSLog ((@"Couldn’t create directory!"); (Невозможно создать папку)
        return 1;
    }

    // Переименование новой папки

    if ((fm movePath: dirName toPath: @"newdir" handler: nil] == NO) {
        NSLog {@Directory rename failed!");
            return 2;
    }

    // Смена папки на другую папку

    if ([fm changeCurrentDirectoryPath: @newdir"] == NO) {
        NSLog (@Change directory failed!"); (Невозможно сменить папку)
        return 3;
    }

    // Получение и вывод пути к текущей рабочей папке

    path = [fm currentDirectoryPath];
    NSLog (@"Current directory path is %@", path); (Путь к текущей папке)

    NSLog (@"All operations were successful!"); (Все операции выполнены успешно)

    [pool drain];
    return 0;
}
```
Вывод программы 16.3
```
Current directory path is /Users/stevekochan/progs/ch16 (Путь к текущей папке)
Current directory path is /Users/stevekochan/progs/ch16/newdir
All operations were successful! (Все операции выполнены успешно)
```
Работу программы 16.3 легко понять из текста самой программы. Сначала мы получаем путь к текущей папке для информативных целей. Затем в текущей папке создается новая папка testdir. Затем в программе используется метод movePath:toPath:handler: для переименования этой новой папки из testdir в newdir. Помните, что этот метод позволяет также перемещать всю структуру папки (включая ее содержимое) из одного места файловой системы в другое.

После переименования новой папки программа делает эту новую папку те-кущей с помощью метода changeCurrentDirectoryPath:. Затем выводится путь к текущей папке, чтобы убедиться, что изменение было выполнено успешно.

### Перечисление содержимого папки
Получил! список содержимого папки. Этот процесс можно осуществить с по-мощью метода enumeratorAtPath: или directoryContentsAtPath:. В первом случае каждый файл указанной папки перечисляется по отдельности, Если один из этих файлов является папкой, то по умолчанию его содержимое тоже рекурсивно перечисляется. Во время этого процесса мы можем динамически запрещать рекурсию (отправив сообщение skipDescendants объекту перечисления), чтобы содержимое папки не перечислялось.

В случае метода directoryContentsAtPath: выполняется перечисление указанной папки, и метод возвращает массив со списком. Если какой-либо из этих файлов является папкой, его содержимое не перечисляется данным методом. В программе 16.4 показано, как использовать каждый из этих методов.
```
// Перечисление содержимого папки

#import <Foundation/NSString.h>
#import <Foundation/NSFileManager.h>
#import <Foundation/NSAutoreleasePool.h>
#import <Foundation/NSArray.h>

int main (int argc, char *argv[])
{
    NSAutoreteasePool   * pool = [[NSAutoreleasePool alloc] initj;
    NSString    *path;
    NSFileManager   *fm;
    NSDirectoryEnumerator *dirEnum;
    NSArray *dirArray;

    // Создание экземпляра filemanager

    fm = [NSFileManager defaultManager];

    // Получение пути к текущей рабочей папке

    path = [fm currentDirectoryPath];

    // Перечисление содержимого папки

    dirEnum = [fm enumeratorAtPath: path];

    NSLog (@"Contents of path"); (Содержимое папки)
    while ((path = [dirEnum nextObject]) != nil)
        NSLog (@"%@", path);

    // Еще один способ перечисления содержимого папки
    dirArray = [fm directoryContentsAtPath:
                    [fm currentDirectoryPath]];
    NSLog (@"Contents using directoryContentsAtPath:"); (Содержимое с помощью ...)

    for (path in dirArray)
        NSLog (@"%@", path);

    [pool drain];
    return 0;
}
```
Вывод программы 16.4
```
Contents of /Users/stevekochan/mysrc/ch16: (Содержимое папки)
a.out
dirl.m
dir2.m
filel .m
newdir
newdir/filel.m
newdir/output
pathl.m
testfile

Contents using directoryContentsAtPath: (Содержимое с помощью directoryContentsAtPath:)
a.out
dirl.m
dir2.m
filel.m
newdir
pathl.m
testfile
```
Рассмотрим следующую последовательность кода.
```
dirEnum = [fm enumeratorAtPath: path];

NSLog (@"Contents of path);

while ((path = [dirEnum nextObject]) != nil)
    NSLog (@"%@", path);
```
Мы начинаем перечисление содержимого папки с отправки сообщения enumeratioaAtPatti: объекту filemanager, в данном случае — fm. Метод enumeratorAtPath: возвращает объект NSDirectortyEnumerator, который сохраняется в dirEnum. Теперь каждый раз при отправке сообщения nextObject этому объекту метод возвращает путь к следующему файлу в перечисляемой папке. Когда не остается файлов для перечисления, метод возвращает значение nil.

Из вывода программы 16.4 видно, чем отличаются эти методы. Метод enumeratorAtPath: создает список содержимого папки newdir, а метод directoryContentsAtPath: не создает. Если бы папка newdir содержала подпапки, то они тоже были бы перечислены методом enumeratorAtPath:.

Как говорилось выше, при выполнении цикла while в программе 16.4 вы могли бы запретить перечисление содержимого любых подпапок, внеся в код следующее изменение.
```
while ((path = [dirEnum nextObject]) != nil) {
    NSLog (@"%@", path);

    [fm fileExistsAtPath: path isDirectory: &flag];

    if (flag == YES)
        [dirEnum skipDescendents];
}
```
Здесь флаг представлен переменной типа BOOL. Метод fileExistsAtPath: сохраняет значение YES в этом флаге, если указанный путь содержится в папке, иначе сохраняется значение NO.

Вы можете вывести все содержимое dirArray с помощью одного вызова NSLog
```
NSLog (@"%@", dirArray);
```
вместо быстрого перечисления, использованного в программе.

### Работа с путями: NSPathUtilities.h
В NSPathUtilities.h включены расширения функций и категорий к NSString для ра-боты с путями. Они позволяют сделать ваши программы более независимыми от структуры файловой системы и местонахождения конкретных файлов и папок. В программе 16.5 показано, как работать с функциями и методами из NS Path Utilities.h.
```
// Основные операции с путями

#import <Foundation/NSString.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSFileManager.h>
#import <Foundation/NSAutoreleasePool.h>
#import <Foundation/NSPathUtilities.h>

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    NSString    *fName = @"path.m";
    NSFileManager   *fm;
    NSString    *path, *tempdir, *extension, *homedir, *fullpath;
    NSString    *upath = @"~stevekochan/progs/../ch16/./path.m";

    NSArray *components;

    fm = [NSFileManager defaultManager];

    // Получение временной рабочей папки

    tempdir = NSTemporaryDirectory ();

    NSLog (@"Temporary Directory is %@", tempdir); (Временная папка)

    // Извлечение базовой папки из текущей папки path = [fm currentDirectoryPath];

    NSLog (@"Base dir is %@", [path lastPathComponent]); (Базовая папка)

    // Создание полного пути к файлу fName в текущей папке

    fullpath = [path stringByAppendingPathComponent: fName];
    NSLog (@"fullpath to %@ is %@", fName, fullpath); (Полный путь к...)

    // Получение расширения имени файла

    extension = [fullpath path Extension];
    NSLog (@"extension for %@ is %@", fullpath, extension); (Расширение имени для...)

    // Получение домашней папки пользователя

    homedir = NSHomeDirectory {);
    NSLog (@"Your home directory is %@", homedir); (Ваша домашняя папка ...)

    // Разбиение пути на его компоненты)

    components = [homedir pathComponents];

    for ( path in components)
        NSLog (@"%@", path);

    // "Стандартизация" пути

    NSLog (@"%@" => upath,
        [upath stringByStandardizingPath] );

    [pool drain];
    return 0;
}
```
Вывод программы 16.5
```
Temporary Directory is /var/folders/HT/HTyGLvSNHTuNb6NrMuo7QE+++TI/-Tmp-/ (Временная папка)
Base dir is examples (Базовя папка - examples)
fullpath lo path.m is /Users/stevekochan/progs/examples/path.m (полный путь к ...)
extension for /Users/stevekochan/progs/examples/path.m is m (расширение имени для ...)
Your home directory is /Users/stevekochan (Ваша домашняя папка ...)
/
Users
stevekochan
-stevekochan/progs/../ch16/./path.m => /Users/stevekochan/chl 6/path.m
```
Функция NSTemporaryDirectory возвращает имя пути в системе для папки, в которой могут сохраняться временные файлы. Создавая временные файлы в этой папке, не забывайте удалять их по окончании использования. Кроме того, имена файлов должны быть уникальными, особенно в тех случаях, когда несколько экземпляров вашего приложения работает одновременно. (См. упражнение 5 в конце этой главы.) Это может произойти, если несколько пользователей выполнят вход в вашу систему и будут выполнять одно приложение.

Метод lastPathComponent извлекает последний файл, указанный в пути. Это полезно, если нужно получить из абсолютного имени пути только базовое имя файла.

Метод stringВуАрреndingPathComponent: позволяет присоединять имя файла в конце пути. Если имя пути, указанное как получатель, не заканчивается символом «слэш», метод вставляет этот символ в имя пути, чтобы отделить его от присоединяемого имени файла. Сочетая метод currentDirectory с методом stringByAppendingPathComponent:, можно создавать полный путь к файлу в текущей папке. Этот способ показан в программе 16.5.

Метод pathExtension дает расширение имени файла для указанного имени пути. Например, расширением для имени файла path.m является т, и данный метод возвращает это расширение. Если имя файла не содержит расширения, то метод просто возвращает пустую строку.

Функция NSHomeDirectory возвращает домашнюю папку для текущего пользователя. Чтобы получить домашнюю папку для определенного пользователя, можно использовать вместо этого функцию NSHomeDirectoryForUser, указав имя пользователя как аргумент для этой функции. 

Метод pathComponents возвращает массив, содержащий каждый из компонентов указанного пути. В программе 16.5 последовательно извлекается каждый элемент возвращаемого массива, и каждый компонент отображается в отдельной строке вывода.

И, наконец, иногда имена пути содержат символы «тильда» (~), о чем мы уже говорили выше. Методы FileManager воспринимают - как сокращенное пред-ставление домашней папки пользователя, или -user для домашней папки ука-занного пользователя. Если ваши имена путей могут содержать символы «тиль-да», то раскрыть их позволяет метод stringByStandardizingPath. Этот метод возвращает путь в стандартизованном виде, то есть с удалением специальных символов. Метод stringByExpandingTildelnPatii раскрывает тол ько символ «тильда», если он присутствует в имени пути.

### Наиболее распространенные методы для работы с путями
В таблице 16.3 приводятся наиболее распространенные методы для работы с путями. В данной таблице components — это объект NSArray, содержащий строко-вые объекты для каждого компонента пути; path — это строковый объект, ука-зывающий путь к файлу; ext — это строковый объект, указывающий расширение имени файла (например, @"mp4").

| Метод                                              | Описание                                                                                                                              |
|----------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| +(NSStrirtg *) pathWittiComponents: components     | Создает допустимый путь из элементов components.                                                                                      |
| -(NSArray *) pathComponents                        | Разделяет путь на его составляющие компоненты.                                                                                        |
| -(NSString *) lastPathComponent                    | Извлекает последний компонент пути.                                                                                                   |
| -(NSString *) path Extension                       | Извлекает расширение имени из последнего компонента пути.                                                                             |
| -(NSString *) stringByAppendingPathComponent: path | Добавляет путь path в конец существующего пути.                                                                                       |
| -(NSString *) stringByAppendingPathExtension: ext  | Добавляет расширение имени ext к последнему компоненту пути.                                                                          |
| -(NSString *) string ByDeletingLastPathComponent   | Удаляет последний компонент пути.                                                                                                     |
| -(NSString *) string ByDeleting LastPathComponent  | Удаляет последний компонент пути.                                                                                                     |
| -(NSString *) stringByDeletingPathExtension        | Удаляет расширение имени из последнего компонента пути.                                                                               |
| -(NSString *) stringByExpandingTildelnPath         | Раскрывает символы «тильда» в пути как домашнюю папку текущего пользователя (;) или домашнюю папку указанного пользователя (@@-user). |
| -(NSString *) stringByResolvingSymlinksInPath      | Пытается разрешить (раскрыть) символические ссылки в пути.                                                                            |
| -(NSString *) stringByStandardizingPath            | Стандартизует путь, раскрывая - ..(родительская папка), .(текущая папка) и символические ссылки.                                      |

В таблице 16.4 представлены имеющиеся функции для получения информа-ции о пользователе, его домашней папке и его панке для хранения временных файлов.

Табл. 16.4. Наиболее распространенные функции для работы с путями

| Функция                                           | Описание                                                                           |
|---------------------------------------------------|------------------------------------------------------------------------------------|
| NSString *NSUserName (void)                       | Возвращает имя входа (login) текущего пользователя.                                |
| NSString *NSFullUserName (void)                   | Возвращает полное пользовательское имя текущего пользователя.                      |
| NSString *NSHomeDirectory (void)                  | Возвращает путь к домашней папке текущего пользователя.                            |
| NSString *NSHomeDirectoryForUser (NSString *user) | Возвращает домашнюю папку пользователя user.                                       |
| NSString *NSTemporaryDirectory(void)              | Возвращает путь к папке, которую можно использовать для создания временного файла. |

Возможно, вам потребуется также функция Foundation NSSearchPathForDPrectorieslnDomains для обнаружения в системе специальных папок, таких как Application.

### Копирование файлов и использование класса NSProcessInfo
В программе 16.6 показано средство командной строки для реализации простой операции копирования файлов. Эта команда применяется следующим образом.
```
copy from-file {bcfjlysq afqk) to-file (afqk-rjgbz)
```
В отличие от метода NSFileManager copyPath:toPath:handler:, это средство ко-мандной строки позволяет также использовать to-file как имя папки. Тогда эта папка копируется в папку to-file под именем from-file. Еще одно отличие от ука-занного метода: если to-file уже существует, его содержимое перезаписывается. Это в большей степени согласуется со стандартной командой копирования UNIX (ср). 

Для получения имен файлов из командной строки можно использовать ар-гументы argc и argv, передаваемые в main. В качестве этих аргументов в команд-ной строке указываются, соответственно, целый ряд типов аргументов (включая имя команды) и указатель на массив символьных С-строк.

Вместо обработки С-строк, что приходится делать при работе с argv, исполь-зуйте класс Foundation NSProcessinfo. NSProcessInfo содержит методы, позволяющие задавать и считывать различные типы информации о выполняемом приложении (то есть вашем процессе). Эти методы приводятся в таблице 16.5.

Табл. 16.5. Методы класса NSProcessinfo

| Метод                                      | Описание                                                                                                                                                                                                         |
|--------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| +(NSProcessInfo *) processlnfo             | Возвращает информацию о текущем процессе.                                                                                                                                                                        |
| -(NSArray *) arguments                     | Возвращает аргументы для текущего процесса в виде массива объектов NSString.                                                                                                                                     |
| -(NSDictionary *) environment              | Возвращает словарь, состоящий из пар «переменная/значение», представляющих текущие переменные среды (например, PATH и НОМЕ) вместе с их значениями.                                                              |
| -(int) processldentifier                   | Возвращает идентификатор процесса, то есть уникальный номер, назначаемый операционной системой для идентификации каждого выполняемого процесса.                                                                  |
| -(NSString *) processName                  | Возвращает имя текущего выполняемого процесса.                                                                                                                                                                   |
| -(NSString *) globallyllniqueString        | Возвращает при каждом вызове новую уникальную строку. Это можно использовать для генерации уникальных имен временных файлов (см. упражнение 5).                                                                  |
| -(NSString *) hostName                     | Возвращает имя хост-системы (возвращает SteveKochans-Computer.local в моей системе Mac OS X).                                                                                                                    |
| -(NSUInteger) operatingSystem              | Возвращает число, обозначающее операционную систему (возвращает значение 5 на моем Маке).                                                                                                                        |
| -(NSString *) operatingSystemName          | Возвращает имя операционной системы (возвращает константу NSMACHOperatingSystem на моем Маке, где возможные возвращаемые значения определены в NSProcessInfo.h).                                                 |
| -(NSString *) operatingSystemVersionString | Возвращает текущую версию операционной системы (возвращает Version 10.5.4 (Build 9Е17) в моей системе Mac OS X).                                                                                                 |
| -(void) setProcessName: (NSString *) name  | Задает имя name для текущего процесса. Следует использовать с осторожностью, поскольку необходимо учитывать некоторые предположения об имени вашего процесса (например, в настройках пользователя по умолчанию). |

```
// Реализация простой утилиты копирования
#import <Foundation/NSString.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSFileManager.h>
#import <Foundation/NSAutoreleasePool.h>
#import <Foundation/NSPathUtilities.h>
#import <Foundation/NSProcesslnfo.h>

int main {int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    NSFileManager *fm;
    NSString *source, *dest;
    BOOL isDir;
    NSProcessInfo *proc = [NSProcessInfo processlnfo];
    NSArray *args = [proc arguments];

    fm = [NSFileManager defaultManager];

    // Проверка того, что в командной строке заданы два аргумента
    if ([args count] != 3) {
        NSLog (@"Usage: %@ src dest", [proc processName]);
        return 1;
    }

    source = [args objectAtlndex: 1];
    dest = [args objectAtlndex: 2];

    // Проверка того, что исходный файл можно читать

    if ([fm isReadableFileAtPath: source] == NO) {
        NSLog (@"Can't read %@", source);
        return 2;
    }

    // Является ли целевой файл (dest) папкой?
    // Если да, то исходный файл (source) добавляется в конец целевого пути

    ffm fileExistsAtPath: dest isDirectory: &isDir);
    if (isDir == YES)
        dest = [dest stringByAppendingPathComponent:
            [source lastPathComponent]];

    // Удаление целевого файла, если он уже существует

    [fm removeFileAtPath: dest handler: nil];

    // Все сделано, можно выполнять копирование
    if ([fm copyPath: source toPath: dest handler: nil] == NO) {
        NSLog (@"Copy failed!");
        return 3;
    }

    NSLog (@"Copy of %@ to %@ succeeded!", source, dest);

    [pool drain];
    return 0;
}
```
Вывод программы 16.6
```
$ Is -I смотрим, какие файлы у нас есть
total 96
-rwxr-xr-x 1 stevekoc staff 19956 Jul 24 14:33 copy -rw-r~r~1 stevekoc staff 1484 Jul 24 14:32 copy.m -rw-r-r- 1 stevekoc staff 1403 Jul 24 13:00 filel.m drwxr-xr-x 2 stevekoc staff 68 Jul 24 14:40 newdir -ПАГ-Г-Г--1 stevekoc staff 1567 Jul 24 14:12 pathl.m -rw-r-r--1 stevekoc staff 84 Jul 24 13:22 testfile $ copy попытка команды без аргументов Usage: copy src dest (Использование: ...)
$ copy foo copy2
Can’t read foo (Невозможно прочитать foo)
$ copy copy.m backup.m
Copy of copy.m to backup.m succeeded! (Копирование copy.m в backup.m выполнено!)
$ diff copy.m backup.m сравнение файлов
$ copy copy.m newdir попытка копирования в папку
Copy of copy.m to newdir/copy.m succeeeded! (Копирование copy.m в newdir/copy.m
выполнено!)
$ Is -I newdir total 8
-rw-r-r- 1 stevekoc staff 1484 Jul 24 14:44 copy.m
$
```
Метод NSProcessInfo arguments возвращает массив строковых объектов. Первый элемент этого массива — имя процесса, остальные элементы содержат аргументы, которые вводятся в командной строке.

Сначала проверяем, что в командной строке введено два ар^менга. Для этого проверяем размер массива args, возвращаемого методом arguments. Если проверка дает правильный результат, то программа затем извлекает имена исходного и целевого файлов из массива args, присваивая их значения переменным source и dest соответственно.

Затем программа проверяет, может ли читаться исходный файл, выдает со-общение об ошибке и завершает работу, если файл не читается.

Оператор
```
tfm fileExistsAtPath: dest isDirectory: ftsDir];
```
проверяет файл, который указывается переменной dest, чтобы определить, не является ли он папкой. Как вы видели выше, ответ (YES или N0) сохраняется в переменной isDir.

Если dest является папкой, то нужно добавить в конец имени этой папки имя исходного файла в качестве последнего компонента пути. Для этого используется метод работы с папками stringByAppendingPathComponent:. Например, если значением переменной source является строка chl6/copy1.m, а значением пере-менной dest является /Users/stevekochan/progs, и это папка, то нужно изменить значение dest на /Users/steveкосhan/progs/coру 1 .т.

Метод copyPath:ToPath:handler: не допускает перезаписи файлов. Таким обра-зом, чтобы избежать ошибки, программа пытается удалить с начала целевой файл с помощью метода removeFileAtPath:handler:* На самом деле не имеет значения, выполнит л и эту работу данный метод, поскольку он в любом случае выдаст ошибку, если целевой файл не существует.

Если достигнут конец программы, то предполагается, что задача выполнена, и выдается соответствующее сообщение.

### Основные файловые операции: NSFileHandle
Методы из класса NSFileHandle позволяют выполнять более сложную работу с файлами. В начале этой главы мы перечислили некоторые возможности этих методов.

В общем случае при работе с файлом нужно выполнить следующие шаги.
1. Открыть файл и получить объект класса NSFileHandle для ссылки на этот файл в последующих операциях ввода-вы вода.
2. Выполнить необходимые операции ввода-вывода с открытым файлом.
3. Закрыть файл.

В таблице 16.6 приводятся некоторые наиболее распространенные методы NSFileHandle. В этой таблице fh — это объект NSFileHandle, data — это объект NSData, path — это объект NSString, offset — это значение типа unsigned long long.

| Метод                                               | Описание                                                                                   |
|-----------------------------------------------------|--------------------------------------------------------------------------------------------|
| +(NSFileHandle *) fileHandleForReadingAtPath: path  | Открывает файл для чтения.                                                                 |
| +(NSFileHandle *) fileHandleFoiWritingAtPath: path  | Открывает файл для записи.                                                                 |
| +(NSFileHandle *) fileHandleForUpdatingAtPath: path | Открывает файл для изменения (чтение и запись).                                            |
| -(NSData *) availableData                           | Возвращает данные, доступные для чтения, из устройства или канала.                         |
| -(NSData *) readDataToEndOfFile                     | Читает оставшиеся данные до конца файла порциями не более (UINT_MAX) байт.                 |
| -(NSData *) readDataOflength: (NSUInteger) bytes    | Читает заданное количество байтов {bytes) из файла.                                        |
| -(void) writeData: data                             | Записывает данные (data) в файл.                                                           |
| -(unsigned long long) offsetlnFite                  | Получает текущее смещение в файле                                                          |
| -(void) seekToFileOffset: offset                    | Задает текущее смещение (offset) в файле.                                                  |
| -(unsigned long long) seekToEndOfFile               | Помешает текущее смещение в конец файла.                                                   |
| -(void) truncateFileAtOffset: offset                | Задает размер файла, равный o/fee/байт (с заполнением при необходимости свободного места). |
| -(void) closeFile                                   | Закрывает файл.                                                                            |

Здесь не приводятся методы NSFileHandle для стандартного ввода, стандарт-ного вывода, стандартных ошибок и null-устройства. Они имеют форму fileHandleWithDevice, где обозначение Device может быть представлено как Standardlnput, StandardOutput, Standard Error или NullDevice.

Здесь также не приводятся методы для чтения и записи данных в фоновом режиме, то есть асинхронно.

Следует отметить, что класс FileHandle не предусматривает создание файлов. Это нужно делать с помощью методов FtleManager, которые были описаны выше. Например, в методах fileHandleForWritingAtPath: и fileHandleForUpdatingAlF’ath: предполагается, что файл существует, и они возвращают значение nil, если его нет. В обоих случаях смешение задастся в начале файла, поэтому запись (или чтение в режиме update) начинается с начала файла. Кроме того, если вы работали с UNIX, то, видимо, обратили внимание, что открытие файла для записи не вызывает усече-ния файла. Вы должны сделать это самостоятельно, если это вам нужно.

Программа 16.7 открывает исходный файл testfile, который мы создали в на-чале главы, читает его содержимое и копирует его в файл с именем testout.
```
// Основные операции обработки файлов
// Предполагается, что существует файл с именем "testfile"
// в текущей рабочей папке 
#import <Foundation/NSObject.h>
#import <Foundation/NSString.h>
#import <Foundation/NSFileHandle.h>
#import <Foundation/NSFileManager.h>

#import <Foundation/NSAutoreleasePool.h>
#import <Foundation/NSData.h>

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    NSFileHandle *inFile, *outFile;
    NSData  *buffer;

    // Открытие файла testfile для чтения

    inFile = [NSFileHandle fileHandleForReadingAtPath: @"testfile"]; if (inFile == nil) {
        NSLog (@"Open of testfile for reading failed"); (Невозможно открыть testfile для чтения)
        return 1;
    }

    // Создание выходного файла, если это нужно
    [[NSFileManager defaultManager] createFileAtPath: @"testout"
        contents: nil attributes: nil];

    // Теперь открытие выходного файла для записи

    outFile = [NSFileHandle fileHandleForWritingAtPath: @"testout"];

    if (outFile == nil) {
        NSLog (@"Open of testout for writing failed");
            (Невозможно открыть testfile для записи)
        return 2;
    }

    // Усечение выходного файла, поскольку он может содержать данные

    [outFile truncateFileAtOffset: 0];

    // Чтение данных из inFile и запись в outFile

    buffer = [inFile readDataToEndOfFile];

    [outFile writeData: buffer];

    // Закрытие обоих файлов

    [inFile closeFile];
    [nutFilfi nloseFilfi];

    // Проверка содержимого файла

    NSLog(@"%@", [NSString StringWithContentsOfFile: @"testout" encoding:
        NSUTF8StringEncoding error: nil]);

    [pool drain];
    return 0;
}
```
Вывод программы 16.7
```
This is a test file with some data in it. (Это тестовый файл с некоторыми данными.)
Here’s another line of data. (Это еще одна строка данных.)
And a third. (И третья.)
```
Метод readDataToEndOfFile: читает данные порциями не более UINT_MAX байт, что определено в <limits.h> и равно FFFFFFFF,6. Этого вполне достаточно для приложения, которое требуется написать. Мы можем также разбить эту работу для чтения и записи небольшими порциями и задать цикл для единовременной пересылки полного буфера между файлами с помощью метода readDataOfLength:. Например, размер буфера можно задать равным 8192 (8 кбайт) или 131072 (128 кбайт). Как правило, размер равен степени 2, поскольку базовая операционная система обычно выполняет свои операции ввода-вывода именно такими порциями данных. Вы можете опробовать различные значения, чтобы определить, что лучше в вашей системе.

Если метод чтения обнаруживает конец файла без чтения каких-либо данных, он возвращает пустой объект NSData (то есть буфер, не содержащий никаких данных). Мы можем применять к буферу метод length и проверять его на равенство нулю, чтобы определить, остались ли какие-то данные для чтения из файла.

Если мы открываем файл для изменения, смешение устанавливается на начало файла. Это смешение можно изменить путем поиска внутри файла и затем выполнить в файле операции чтения или записи. Например, для поиска 10-го байта в файле с описателем databaseHandle можно написать в сообщении следующее выражение.
```
[databaseHandle seekToFileOffset: 10];
```
Для указания относительных позиций в файле нужно получитьтекущее сме-щение в файле и затем добавлять или вычитать из него относительное смещение. Например, чтобы пропустить следующие 128 байтов в файле, нужно написать следующее.
```
[databaseHandle seekToFileOffet:
[databaseHandle offsetlnFile] + 128];
```
Для смещения на пять целых данных в файле можно написать следующее.
```
[databaseHandle seekToFileOffet:
[databaseHandle offsetlnFile] - 5 * sizeof (int)];
```
Программа 16.8 добавляет содержимое одного файла ко второму. Второй файл открывается для записи, выполняется поиск конца этого файла и затем содержимое первого файла записывается во второй.
```
// Добавление содержимого файла "fileA" в конец файла "fileB"
#import <Foundation/NSObject.h>
#import <Foundation/NSString.h>

#import <Foundation/NSFileHandle.h>
#import <Foundation/NSFileManager.h>
#import <Foundation/NSAutoreleasePool.h>
#import <Foundation/NSData.h>

int main (int argc, char *argv[])
{
    NSAutoreleasePool * poo) = [[NSAutoreleasePool alloc] init];
    NSFileHandle    *inFile, *outFile;
    NSData  *buffer;

    // Открытие файла fileA для чтения

    inFile = [NSFileHandle fileHandleForReadingAtPatti: @"fileA*']; if (inFile == nil) {
        NSLog (@"Open of fileA for reading failed");
        return 1;
    }

    // Открытие файла fileB для изменения

    outFile = [NSFileHandle fileHandleForWritingAtPath: @"fileB"]; if (outFile == nil) {
        NSLog (@"Open of fileB for writing failed");
        return 2;
    }

    // Поиск конца outFile

    [outFile seekToEndOfFile];

    // Чтение inFile и запись его содержимого в outFile

    buffer = [inFile readDataToEndOfFile];
    [outFile writeData: buffer];

    // Закрытие обоих файлов

    [inFile closeFile];
    [outRle closeFile];

    [pool drain];
    return 0;
}
```
Содержимое FileA перед запуском программы 16.8
```
This is line 1 in the first file. (Это строка 1 в первом файле)
This is line 2 in the first file. (Это строка 2 в первом файле)
```
Содержимое FileB перед запуском программы 16.8
```
This is line 1 in the second file. (Это строка 1 во втором файле)
This is line 2 in the second file. (Это строка 2 во втором файле)
```
Вывод программы 16.8
```
Contents of fileB (Содержимое fileB)
This is line 1 in the second file.
This is line 2 in the second file.
This is line 1 in the first file.
This is line 2 in the first file.
```
Вывод программы показывает, что содержимое первого файла успешно до-бавлено в конец второго файла. seekToEndOfFile возвращает текущее смещение файла после выполнения поиска. В данном случае мы игнорируем эту инфор-мацию, но она позволяет получить размер файла.

## Упражнения
1. Внесите изменения в программу копирования (программа 16.6), чтобы она допускала более одного исходного файла для копирования в папку, аналогично стандартной команде UNIX ср. Например, команда
    ```
    $ copy copyl .m filel .т file2.m progs
    ```
    должна копировать три файла (copyl.m, filel.m и file2.m) в папку progs. Предусмотрите, что если указано более одного файла, то последним аргументом на самом деле является существующая папка.
2. Напишите средство командной строки с именем myfind, которое принимает два аргумента. Первый из них указывает начальную папку для поиска, а вто-рой- имя файла, который нужно найти. Например, командная строка
    ```
    $ myfind /Users proposai.doc
    /Users/stevekochan/MyDocuments/proposals/proposal.doc
    $
    ```
    начинает поиск в файловой системе с /Users, чтобы найти файл proposal.doc. Выведите полный путь к файлу, если он найден (в том виде, как показано выше), или соответствующее сообщение, если он не найден.
3. Напишите вашу собственную версию стандартных средств UNIX basename и dirname.
4. Используя класс NSProcessInfo, напишите программу, которая выводит всю информацию, возвращаемую каждым из ее методов-получателей (getter).
5. Используя функцию NSTemporaryOirectory из NSPathUtilities.h и метод NSProcessInfo globallyUniqueString, описанные в этой главе, добавьте в NSString категорию с именем TempFiles и определите в ней метод с именем temporaryFileName, который возвращает при каждом вызове новое уникальное имя файла.
6. Внесите изменения в программу I6.7, чтобы в файле выполнялись чтение и запись kBufSize байт, причем kBufSize нужно определить в начале вашей программы. Обязательно проверьте эту профамму на больших файлах (размером больше kBufSize байт).
7. Откройте файл, считывайте его содержимое по 128 байт и выводите эти данные на терминал. Используйте метод FileHandle fileHandleWithSlandardOutput, чтобы получить описатель для вывода на терминал.