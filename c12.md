# Глава 12. Препроцессор
Препроцессор содержит средства, упрощающие чтение, разработку и встраивание программ в различные системы. Препроцессор позволяет настроить язык Objective-C в соответствии с конкретным программным приложением или вашим стилем программирования.

Препроцессор — это составная часть процесса компиляции Objective-C. Он распознает специальные операторы и обрабатывает их, прежде чем будет выполнен анализ самой программы. Операторы препроцессора идентифицируются знаком «решетка» (#), который должен быть первым символом строки, отличным от пробела. Синтаксис операторов препроцессора несколько отличаюется от обычных операторов Objective-C. Мы начнем с описания оператора #define.

## 12.1. Оператор # define
Оператор #define позволяет присваивать символические имена программным константам. Оператор препроцессора
```
#define TRUE 1
```
определяет имя TRUE и делает его эквивалентным значению 1. Затем имя TRUE можно использовать в любом месте программы, где могла бы использоваться константа 1. Там, где появляется это имя, препроцессор автоматически подставляет вместо него значение 1. Например, следующий оператор Objective-C использует определенное имя TRUE.
```
gameOver = TRUE;
```
Этот оператор присваивает значение TRUE переменной gameOver. Вам не обязательно помнить, какое конкретное значение вы определили для TRUE. Приведенный выше оператор будет присваивать 1 переменной gameOver. Оператор препроцессора
```
#define FALSE О
```
определяет имя FALSE и делает его эквивалентным значению 0. Например, оператор
```
gameOver = FALSE;
```
присваивает значение FALSE переменной gameOver, а оператор
```
if ( gameOver == FALSE)
```
сравнивает значение gameOver с определенным значением FALSE.

Определенное таким образом имя не является переменной, поэтому вы не можете присвоить ему значение, если результатом подстановки значения не янляется переменная. Если в программе используется определенное имя, препроцессор автоматически подставляет то, что представлено в правой части оператора «define. Это аналогично операции поиска и замены втекстозом редакторе; в данном случае препроцессор заменяет все экземпляры определенного имени соответствующим текстом.

Отметим, что оператор «define имеет специальный синтаксис: для присваивания TRUE значения 1 не используется знак равенства. Кроме того, в конце оператора нет точки с запятой.

Операторы «define часто помещают ближе к началу программы, после операторов «import или «include, хотя они могут присутствовать в любом месте программы. Однако имя должно быть определено до того, как оно будет использовано. Определенные таким образом имена отличаются по своему поведению от переменных: не существует такого понятия, как локальный «define». После определения имени его можно использовать в любом месте программы. Большинство программистов помещают операторы define в header-файлы (*.h), чтобы использовать их в нескольких исходных файлах.

В следующем примере напишем два метода для поиска площади и длины окружности объекта типа Circle. Поскольку в обоих методах требуется использовать константу, значение которой трудно запомнить, имеет смысл определить значение этой константы в начале программы и затем применять его в каждом методе.

Поэтому мы можем включить в программу следующую строку:
```
#define PI 3.141592654
```
Теперь эту константу можно использовать в обоих методах класса Circle (в предположении, что класс Circle содержит переменную экземпляра с именем radius).
```
-(double) area
{
    return PI * radius * radius;
}

-(double) circumference
{
    return 2.0 * PI * radius;
}
```
Назначение константы для символического имени освобождает вас от необходимости помнить значение константы. Кроме того, если потребуется изменить значение этой константы, то это нужно будет сделать только в одном месте программы: в операторе #define. В противном вам придется выполнить поиск по всей программе и явно изменить значение константы.

Во всех приведенных примерах операторов define использовались прописные буквы (TRUE, FALSE и PI). Это было сделано, чтобы визуально отличить определенное значение от переменной. Некоторые программисты записывают все определенные имена прописными буквами, чтобы сразу различать, что перед ними: переменную, объект, имя класса или определенное имя. Перед определенным именем принято ставить букву к. В этом случае прописными буквами обозначаются не все символы, например, kMaximumValues и kSignificantDigits.

Применение определенного имени для значения константы упрощает расширение программы. Для массивов вместо конкретного указания размера массива, который нужно выделить в памяти, можно определить нужное значение:
```
#define МAXIМUM_DATA_VALUES 1000
```
Теперь на этом определенном значении можно основывать все ссылки на размер массива (например, чтобы выделить место для этого массива в памяти) и допустимые индексные значения.

Кроме того, если профамма использует MAXIMUM DATA VALUES во всех случаях, где нужно указать размер массива, то чтобы изменить размер массива, достаточно изменить только это определение.

### Более сложные типы определений
Определение имени может включать не только простое константное значение. Это может быть и выражение и почти все, что можно предположить!

Ниже имя TW0_PI определяется как произведение 2.0 на 3.141592654:
```
#define 7W0_PI 2.0 * 3.141592654
```
После этого определенное имя можно использовать в любом месте программы, где требуется выражение 2.0 * 3.141592654. Например, оператор return в методе circumference из предыдущего примера можно заменить оператором
```
return TWO_PI * radius;
```
Если в профамме на Objective-C встречается определенное имя, то все, что находится справа от этого определенного имени в операторе «define, подставляется вместо этого имени. Так, если препроцессор встречает имя TW0_PI в приведенном выше операторе return, он подставляет вместо этого имени то, что находится справа от этого имени в операторе «define, то есть 2.0 * 3.141592654.

Теперь вы понимаете, почему оператор #define нельзя закончить точкой с запятой. Если вы сделаете это, точка с запятой будет подставлена в том месте, где встретится соответствующее определенное имя. Если определить PI с помощью оператора
```
#define PI 3.141592654;
```
и затем написать
```
return 2.0 * PI * r;
```
препроцессор заменит этот экземпляр определенного имени PI на 3.141592654;.

Тогда после подстановки компилятору нужно будет обработать оператор
```
return 2.0*3.141592654; * г;
```
что даст синтаксическую ошибку. Ставить точку с запятой после операторов define можно только в тех случаях, когда это действительно нужно.

Определение для препроцессора может не быть допустимым выражением Objective-C, но результирующее выражение в программе должно быть допусти­ мым. Например, вы можете задать определения:
```
#define AND &&
#define OR ||
```
А затем писать такие выражения, как
```
if ( х > 0 AND х < 10)
```
и
```
if ( у == 0 OR у == value )
```
Можно даже использовать «define для оператора проверки равенства:
```
#define EQUALS ==
```
И затем написать выражение
```
if (у EQUALS 0 OR у EQUALS value )
```
Это позволяет избежать ошибки в тех случаях, когда для проверки равенства используют один знак равенства.

Возможности оператора «define велики, но практика надежного программирования не приветствует такие способы переопределения синтаксиса базового языка. Кроме того, это затрудняет другим людям понимание вашего кода.

Это еще не все. Поскольку определенное значение может ссылаться на другое определенное значение, следующие две строки «define допустимы.
```
#define PI 3.141592654
#define TWO_PI 2.0 * PI
```
Имя TWO_PI определяется со ссылкой на предыдущее определенное ими PI, что избавляет от необходимости повторно писать значение 3.141592654.

Обратный порядок этих определений тоже допустим.
```
#define TWO PI 2.0 * PI
#define PI 3.141592654
```
Определенные значения можно использовать в определениях, если все, что нужно, определено на тот момент, когда соответствующее определенное имя используется в программе.

Разумное использование операторов #define позволяет сократить количество комментариев в программе. Рассмотрим оператор
```
if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0)
```
В выражении проверяется, високосный ли год записан в переменной year.

Рассмотрим оператор #define и оператор if.
```
#define IS_LEAP_YEAR year % 4 == 0 && year % 100 != 0 \
                    ||year % 400 == 0
if (IS_LEAP_YEAR)
```
Обычно препроцессор предполагает, что определение целиком содержится в одной строке. Символом переноса строки (т.е. продолжения оператора) для препроцессора является обратный слэш. Этот символ игнорируется при подстановке. Если строк продолжения несколько, то каждая строка должна заканчиваться обратным слэшем.

Последний оператор if намного понятнее, чем предыдущий. Конечно, данное определение позволяет проверить на високосный год только переменную year, но мы можем написать определение, с помощью которого можно проверить на високосный год любое выражение. Для этого нужно включить в определение один или несколько аргументов.

IS_LEAP_YEAR можно определить с аргументом у следующим образом.
```
#define IS_LEAP_YEAR(y) у % 4 == 0 && у % 100 != 0 \
                        || у % 400 == 0
```
В отличие от определения метода, мы не определяем тип аргумента у, поскольку здесь выполняется просто подстановка текста, а не вызов функции. Отметим, что в определении имени с использованием аргументов не допускаются пробелы между определенным именем и левой круглой скобкой перед списком аргументов.

Используя это определение, напишем оператор
```
if ( IS_LEAP_YEAR (year))
```
Оператор проверяет, является ли значение для year високосным годом. Можно написать аналогичное выражение для nextYear.
```
if ( IS_LEAP YEAR (nextYear))
```
В этом операторе определение для IS_LEAP_YEAR непосредственно подставляется в оператор if с заменой аргумента у на nextYear. В результате компилятор будет обрабатывать следующий оператор.
```
if ( nextYear % 4 == 0 && nextYear % 100 != О |j nextYear % 400 == 0)
```
Определения часто с одним или несколькими аргументами то называют макросами. В следующем макросе представлен квадрат его аргумента.
```
#define SQUARE(x) х * х
```
В определении для SQUARE необходимо учитывать возможность следующей ошибки. Исходя из нашего описания, оператор
```
у = SQUARE (v);
```
присваивает у значение V<sup>2</sup>. Но в операторе
```
у = SQUARE (v+1);
```
переменной не присваивается значение (v + 1)<sup>2</sup>, как ожидалось. Поскольку в определении этого макроса препроцессор выполняет подстановку текста вместо аргумента, здесь получится следующее выражение:
```
у = v + 1 * v + 1;
```
Чтобы решить проблему, нужно использовать в определении макроса SQUARE круглые скобки.
```
#define SQUARE(x) ( (х) * (х))
```
Определение может показаться несколько странным, но помните, что х будет заменяться подставляемым выражением. Теперь оператор
```
у = SQUARE (v+ 1);
```
будет правильно обработан как
У = ((v+ 1) * (v+ 1));
Следующий макрос позволяет создавать новые дроби из нашего класса Fraction.
```
#define MakeFract(x.y) ([[Fraction alloc] initWith: x over: y]])
```
Теперь для сложения дробей nl/dl и n2/d2 можно писать такие выражения, как
```
myFract = MakeFract (1, 3); // Создание дроби 1/3
```
или
```
sum = [MakeFract (nl, d1) add: MakeFract (n2, d2)];
```
Макросы удобны для работы с условными выражениями. В следующей строке определяется макрос с именем МАХ, определяющий максимальное из двух значений.
```
#define MAX(a,b) { ((а) > (Ь)) ? (а): (Ь))
```
С помощью этого макроса можно писать такие операторы, как
```
limit = МАХ (х + у, minValue);
```
Переменной limit присваивается максимальное из двух значений: х + у и minValue. Все определение МАХ заключено в круглые скобки, чтобы правильно обрабатывать такие выражения, как
```
МАХ (х, у)* 100
```
Каждый аргумент тоже заключен в круглые скобки, чтобы правильно обрабатывать такие выражения, как
```
МАХ (х & у, z)
```
Оператор & — это побитовый оператор AND, и он имеет меньший приоритет, чем оператор > в данном макросе. Без этих круглых скобок оператор > обрабатывался бы раньше побитового AND, что давало бы неверный результат.

В следующем макросе проверяется, является ли символ строчной буквой.
```
#define IS_LOWER_CASE(x) ( ((х) >= 'а') && <(х) <= ’z') )
```
С помощью этого макроса можно писать такие выражения, как
```
if ( IS_LOWER_CASE (с))
```
Этот макрос можно даже использовать в определении другого макроса, чтобы преобразовывать символ из нижнего регистра в верхний (делать строчную букву прописной), не изменяя другие символы.
```
#define T0_UPPER(x) ( IS_LOWER_CASE (х) ? (х) -'a' + 'A' : (х))
```
Здесь мы снова работаем со стандартным набором символов ASCII. В части II, когда будут описываться объекты-строки, вы увидите, как выполнять преобразование символов из одного регистра в другой для международных наборов символов (Unicode).

### Оператор #
Если поместить символ # перед параметром в определении макроса, препроцессор создаст строку-константу в стиле С из аргумента макроса при его вызове. Например, определение
```
#define str(x) # х
```
при последующем вызове
```
str (testing)
```
будет раскрыто препроцессором как
```
"testing"
```
Например, вызов printf
```
printf (str ("Программировать на Objective-C интересно""));
```
эквивалентен
```
printf ("Программировать на Objective-C интересно");
```
Препроцессор заключает в кавычки фактический аргумент макроса. Препроцессор сохраняет в аргументе все кавычки и обратные слэши. Поэтому вызов
```
str ("hello")
```
даст в результате
```
"\"hello\""
Более близкий к практике пример оператора # представляет следующее определение макроса.
```
#define printint(var) printf (# var " = %i\n", var)
```
Этот макрос используется для вывода значен ия целой переменной. Если count — переменная целого типа со значением 100, то оператор
```
printint (count);
```
будет раскрыт как
```
printf ("count" " = %i\n", count);
```
Компилятор выполнит конкатенацию двух смежных литеральных строк, чтобы создать одну строку. Поэтому после конкатенации оператор примет следующий вид.
```
printf ("count = %i\n", count);
```

### Оператор ##
В определении макроса оператор ## сливает два маркера. Он ставится перед именем параметра макроса (или после него). Препроцессор берет фактический аргумент, указанный при вызове макроса, и создает один маркер из этого аргумента и из маркера, который следует за ## или предшествует ##.

Предположим, что у нас имеется список переменных от х1 до хЮО. Мы можем написать макрос с вызовом printx, который принимает в качестве аргумента значение от 1 до 100 и выводит значение соответствующей переменной.
```
#define printx(n) printf ("%i\n", x ## n)
```
Часть x ## n указывает, что нужно взять маркеры, стоящие перед и после ## (соответственно букву х и аргумент п), и создать из них один маркер. Поэтому вызов
```
printx (20);
```
будет раскрываться следующим образом,
```
printf ("%i\n", х20);
```
В макросе printx можно использовать ранее определенный макрос printint, чтобы выводить имя переменной вместе с ее значением.
```
#define printx(n) printint(x ## n)
```
Вызов
```
printx (10);
```
сначала раскрывается как
```
printint (x10);
```
затем как
```
printf ("x10" "= %i\n", х10);
```
и, наконец, так:
```
printf ("х10 = %i\n", хЮ);
```

## 12.2. Оператор #import
Программируя на Objective-C, вы постепенно разработаете для своих программ собственный набор макросов. Чтобы не вводить их в каждую новую программу, вы можете собрать все определения в один файл и включать свои макросы в программу с помощью оператора #import. Эти файлы обычно имеют расширение имени .h и называются заголовочными (header) или включаемыми (include) файлами.

Предположим, что мы пишем набор программ для метрических преобразований. Нам нужно задать операторы «define для констант, которые требуются при выполнении этих преобразований.
```
#define INCHES PER CENTIMETER 0.394 (дюйм/см)
#define CENTIMETERS_PER_INCH (1 / INCHES_PER_CENTIMETER) (см/дюйм)
#define QUARTS_PER_LITER 1.057 (кварта/литр)
#define LITERS_PER_QUART (1 / QUARTS_PER_L!TER) (литр/кварта)
#define OUNCES PER GRAM 0.035 (унция/г)
#define GRAMS_PER_OUNCE (1 / OUNCES_PER_GRAM) (г/унция|
```
Мы ввели эти определения в файл с именем metric.h. Чтобы использовать определения из файла metric.h, в программе достаточно ввести следующую директиву препроцессора:
```
#import "metric.h"
```
Этот оператор должен появиться до ссылки на любые операторы «define, содержащиеся в файле metric.h. Обычно его помешают в начале исходного файла. Препроцессор ищет указанный файл в системе и копирует содержимое этого файла в то место программы, где находится оператор «import. Таким образом, любые операторы из этого файла обрабатываются так, как если бы они были непосредственно введены в программу в этом месге.

Кавычки, в которые заключено имя файла, показывают препроцессору, что файл нужно искать водном или нескольких файловых каталогах (папках). Обычно поиск начинается с каталога, содержащего исходный файл, но в Xcode можно указать конкретные места для поиска, изменив настройки проекта (ProjectSettings).

Если заключить имя файла в угловые скобки (< и >)
```
#import <Foundation/Foundation.h>
```
то препроцессор будет искать include-файл только в специальном «системном» каталоге (или каталогах) header-файлов, но в текущем каталоге поиск выполняться не будет. И в этом случае при работе в Xcode можно изменить каталоги, выбрав в меню Project, Edit Project Settings (Изменить настройки проекта).

**Примечание.** При компиляции программ для этого раздела книги файл Foundation.h был импортирован из следующего каталога на моем компьютере: /Developer$/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/Foundation.framework/Versions/C/Headers.

Покажем на примере конкретной программы, как работают include-файлы. Введем шесть приведенных выше операторов #define в файл с именем metric.h. Затем введем и запустим программу 12.1.
```
/* Пример использования оператора #import
Примечание. В этой программе предполагается, что определения
заданы в файле с именем metric.h (галлон = 4 кварты) */

#import <Foundation/Foundation.h>
#import <metric.h>
int main (int argc, char *argv[])

{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    float liters, gallons;

    NSLog (@"*** Liters to Gallons ***");
    NSLog (@*Enter the number of liters:");
    scanf ("%f", Sliters);

    gallons = liters * QUARTS_PER_UTER / 4.0;
    NSLog (@"%g liters = %g gallons", liters, gallons);

    [pool drain];
    return 0;
}
```
Вывод программы 12.1
```
*** Liters to Gallons *** (Литры в галлоны)
Enter the number of liters: (Введите количество литров)
55.75
55.75 liters = 14.7319 gallons. (55.75 литров = 14.7319 галлонов)
```
В программе 12.1 используется только одно определенное значение
(QUARTS_PER_LITER) из include-файла metric.h. Тем не менее, это вполне показательный пример: после ввода в файл metric.h определения доступны в любой программе, где применяется соответствующий оператор «import.

Одним из наиболее важных преимуществ использования файла импорта является возможность централизовать все определения, что гарантирует использование в программах одного и того же значения. Кроме того, ошибки в include-файле достаточно исправить только в одном месте, не изменяя все программы, использующие это значение. Любую программу, в которой используется неверное значение, достаточно перекомпилировать, не редактируя.

Другие системные include-файлы содержат объявления для различных функций, хранящихся в базовой системной библиотеке С. Например, файл limits.h содержит системно-зависимые значения, которые задают размеры символьных и целых типов данных. Максимальный размер типа int определяется вну три этою файла именем INT_MAX, максимальный размер unsigned long int определяется с помощью ULONG^MAX, и т.д.

Файл float.h задает информацию о типах данных с плавающей точкой: FLTMAX указывает максимальное число с плавающей точкой, a FLT_DIG — число десятичных цифр для точности типа float.

Файл string.h содержит объявления для библиотечных процедур копирования, сравнения и конкатенации, которые выполняют операции с символьными строками. Если вы работаете исключительно со строчными классами Foundation (см. главу 15), то эти процедуры вам не потребуются.

## 12.3. Условная компиляция
Препроцессор Objective-C позволяет работать с условной компиляцией (conditional compilation).

Условная компиляция обычно применяется для создания одной программы, которую можно компилировать для выполнения в различных компьютерных системах. Она часто используется для включения или отключения в программе различных операторов, например, операторов отладки, которые выводят значения переменных или отслеживают последовательность выполнения программы.

### Операторы #ifdef, #endif, #else и #ifndef
К сожалению, программа может основываться на системно-зависимых параметрах, которые различны для разных процессоров (например, Power PC или Intel) в разных версиях операционной системы (например, Tiger или Leopard).

Для большой программы, содержащей много таких зависимостей от оборудования или программного обеспечения вам пришлось бы изменять много операторов типа define.

Чтобы свести к минимуму эту проблему, вы можете включить в программу значения определений операторов типа define для разных машин, используя средства условной компиляции препроцессора. Например, в следующих операторах для DATADIR определяется значение "/uxnl/data", если ранее был определен символ MAC_0S_X, в противном случае присваивается значение "\usr\data".
```
#ifdef MAC_0S_X
#   define DATADIR "/uxnl/data"
#else
#   define DATADIR "\usr\data"
#endif
```
После символа #, начинающего оператор препроцессора, можно помещать один или несколько пробелов.

Операторы #ifdef, #else и #endif действуют в соответствии с их именами. Если символ, указанный в строке #ifdef, уже определен (с помощью оператора #define или из командной строки при компиляции программы), компилятор обрабатывает последующие строки до #else, #elrf или ftendif; в противном случае они игнорируются.

Чтобы определить символ POWER_PC для препроцессора, достаточно оператора
```
#define P0WER_PC 1
```
или
```
#define POWER.PC.
```
Как видно из примера, после определенного имени не требуется текста, чтобы выполнить проверку #ifdef. Компилятор также позволяет определить имя для препроцессора, если программа компилируется с использованием специальной опции в команде компилятора. В командной строке
```
gcc -framework Foundation -D P0WER_PC program.m -
```
для препроцессора определяется имя P0WER_PC, чтобы все операторы #ifdef POWER PC внутри программы program.m давали значение TRUE (отметим, что -D POWER PC следует ввести в командной строке до указания имя программы). Это средство позволяет определять имена без редактирования исходной программы.

В Xcode для добавления новых определенных имен и указания их значений нужно выбрать Add User-Defined Setting (Добавить пользовательское значение) в Project Settings (Настройки проекта).

После оператора #ifndef следуют такие же строки, как после оператора #ifdef. В нем последующие строки обрабатываются в том случае, если указанный символ не определен.

Как уже говорилось, условная компиляция полезна для отладки программ. Можно включить в программу много вызовов printf для вывода промежуточных результатов и отслеживания последовательности выполнения. Для запуска этих операторов можно выполнить их условную компиляцию в программе, если определено некоторое имя, например DEBUG. Следующую последовательность операторов можно использовать для вывода значений некоторых переменных, только если программа была откомпилирована с определением имени DEBUG.
```
#ifdef DEBUG
    NSLog (@"User name = %s, id = %i", userName, userid);
#endif
```
В вашей программе может быть много таких отладочных операторов. При отладке программу можно компилировать с определением имени DEBUG, чтобы выполнялась компиляция отладочных операторов. Если программа работает правильно, ее можно перекомпилировать без определения DEBUG. Это позволяет сократить размер программы, поскольку все отладочные операторов не будут компилироваться.

### Операторы препроцессора #if и #elif
Оператор препроцессора #if представляет более общий подход к управлению условной компиляцией. Этот оператор позволяет проверить, равно ли нулю константное выражение. Если результат выражения не равен нулю, последующие строки до Seise, telif или tendif обрабатываются; в противном случае они пропускаются.

Рассмотрим следующие строки из файла Foundation NSString.h.
```
#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_0S_X_VERSI0N _10_5
#define NSMaximumStringLength (INT MAX-1)
#endif
```
Здесь сравниваю тся значения определенных переменных MAC_OS_X_VERSION_MIN_REQUIRED и MAC_OS_X_VERSIONJO_5. Если первое значение меньше второго, то обрабатывается следующий оператор tdefine; в противном случае он пропускается. Это позволяет задать максимальную длину строки, равную максимальному размеру целого типа минус 1, если программа компилируется в системе MAC OS X 10.5 или последующих версиях.

В строках с #if применяется также специальный оператор
```
defined (имя)
```
Следующие наборы операторов дают одинаковый результат:
```
#if defined (DEBUG)
    ...
#endif
```
и
```
#ifdef DEBUG
    ...
#endif
```
Следующие операторы включены в файл NSObjcRuntime.h, чтобы определить имя NSJNI INF (если оно не было определено раньше) в зависимости от конкретного компилятора.
```
#if defined(NSJNUNE)
    #if defined(_GNUC_)
        #define NSJNUNE static _inline_attribute_((always_inline))
    #elif defined(_MWERKS_J || defined(_cplusplus)
        #define NSJNUNE static inline
    #elif defined(MSC_VER)
        #define NS_INUNE static_inline
    #elif defined(_"wiN32_)
        #define NS_INUNE static_inline_
    #endif
#endif
```
Ниже приводится еще один типичный случай применения #if.
```
#if defined (DEBUG) && DEBUG
    ...
#endif
```
Операторы между #if и #cndif будут обрабатываться в том случае, если имя DEBUG определено и имеет ненулевое значение.

### Оператор #undef
Сделать определенное имя неопределенным позволяет оператор #undef. Чтобы удалить определение имени, нужно написать строку
```
#undef имя
```
Следующий оператор удаляет определение POWER_PC.
```
#undef POWER_PC
```
Последующие операторы #ifdef P0WER_PC или #if defined (POWER_PC) будут давать значение FALSE.
На этом заканчивается наше описание возможностей препроцессора. В приложении В приводятся дополнительные операторы препроцессора, которые не были описаны здесь.


Упражнения
1. Найдите на своей машине файлы limits.h и float.h. Посмотрите, что находится в этих файлах. Если в эти файлы включены другие файлы, просмотрите и их.
2. Определите макрос с именем MIN, который дает минимальное из двух значений. Напишите программу, которая проверяет определение этого макроса.
3. Определите макрос с именем МАХЗ, который дает максимальное из трех значений. Напишите программу, которая проверяет это определение.
4. Напишите макрос с именем IS_UPPER_CASE, который выдает ненулевое значение, если символ является прописной буквой.
5. Напишите макрос с именем IS_ALPHABETIC, который выдает ненулевое значение, если символ является буквой. Сделайте так, чтобы в этом макросе использовались макрос IS_LOWER CASE, определенный в данной главе, и макрос IS_UPPER_CASE, определенный в упражнении 4.
6. Напишите макрос с именем IS_DIGfT, который выдает ненулевое значение, если символ является цифрой от 0 до 9. Используйте этот макрос в определении другого макроса с именем IS_SPECIAL, который выдает ненулевое значение, если символ является специальным символом (то есть не буквой и не цифрой). Обязательно используйте макрос IS_ALPHABET1C из упражнения 5.
7. Напишите макрос с именем ABSOLUTE VALUE, который вычисляет абсолютное значение своего аргумента. Этот макрос должен правильно вычислять такие выражения, как
    ```
    ABSOLUTE_VALUE (х + delta)
    ```
8.  Рассмотрим определение макроса printint из этой главы
    ```
    #define printx(n) printf ("%i\n", x ## n)
    ```
    Можно ли использовать следующие строки для вывода значений 100 переменных отх1 до хЮО? Почему?
    ```
    for (i = 1; i <= 100; ++i) printx (i);
    ```