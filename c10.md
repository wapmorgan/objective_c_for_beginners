# Глава 10. Более подробно о переменных и типах данных
В этой главе мы поговорим об области действия переменных, методах инициализации для объектов и типах данных. В главе 7 мы кратко обсуждали область
действия переменных экземпляра, статические и локальные переменные. Теперь мы более подробно поговорим о статических переменных и введем понятие глобальных и внешних переменных. Для компилятора Objective-C можно
задавать директивы, позволяющие контролировать область действия переменных экземпляра. В этой главе мы рассмотрим их.

Перечислимый (enumerated) тип данных позволяет определять имя для типа
данных, которое будет использоваться только для хранения заданного списка
значений. В языке Objective-C оператор typedef позволяет вам назначать собственное имя встроенному или производному типу данных. В этой главе мы описываем действия компилятора по преобразованию типов данных при оценке выражений.

## 10.1. Инициализация классов
Мы уже встречали такой набор действий, когда выделяется память для нового
экземпляра объекта, а затем выполняется его инициализация:
```
Fraction *myFract = [[Fraction alloc] init];
```
После вызова этих методов обычно выполняется присваивание некоторых
значений новому объекту:
```
[myFract setTo: 1 over: 3];
```
Процесс инициализации объекта, после которого ему присваиваются начальные значения, часто объединяют в один метод. Например, можно определить
метод initWith::, который инициализирует объект типа fraction (дробь) и присваивает
два (неименованных) заданных аргумента его числителю (numerator) и знаменателю (denominator).

Класс, который содержит много методов и переменных экземпляра, обычно имеет несколько методов инициализации. Например, класс NSArray из
Foundation framework содержит шесть методов инициализации.
```
initWithArray:
initWithArrayxopyltems:
initWithContentsOfFile:
initWithContentsOfURL:
initWithObjects:
initWithObjects:count:
```
Массиву (array) можно выделить память и затем инициализировать его, например, с помощью следующей последовательности:
```
myArray = [[NSArray alloc] initWithArray: myOtherArray];
```
Принято, что все инициализаторы в классе обычно начинаются с init. Инициализаторы NSArray следуют этому правилу. При написании инициализаторов
вы можете придерживаться одной из двух стратегий.

Если ваш класс содержит более одного инициализатора, один из них должен
быть вашим назначенным (designated ) инициализатором, и все остальные методы
инициализации должны его использовать. Обычно это более сложный метод
инициализации (и принимает больше всего параметров). При создании назначенного инициализатора основной код инициализации объединяется в одном
методе. При создании подкласса можно затем замещать назначенный инициализатор, чтобы обеспечить правильную инициализацию новых экземпляров.
Необходимо следить за тем, чтобы правильно инициализировались любые
наследуемые переменные экземпляра. Наиболее простой способ —вызывать
сначала назначенный метод инициализации из родительского класса, который
обычно называется init, а после этого инициализировать свои собственные переменные экземпляра.

Исходя из этого, метод инициализации initWith:: для класса Fraction может выглядеть следующим образом.
```
-(Fraction *) initWith: (int) n: (int) d
{
self = [super init];
if (self)
[self setTo: n over: d];
return self;
}
```
Этот метод вызывает сначала родительский инициализатор, которым является метод init из NSObject (напомним, что это родительский класс для Fraction).

Вы должны присвоить результат self, поскольку инициализатор имеет право
изменять или перемещать объект в памяти.

После инициализации super (и ее успешного завершения, что указывается
ненулевым возвращаемым значением) используется метод setTo:over:, чтобы задать числитель (numerator) и знаменатель (denominator) дроби (Fraction). Как и
для других методов инициализации, предполагается, что вы возвращаете инициализированный объект.

В программе 10.1 выполняется проверка нового метода инициализации initWith::.
Программа 10.1
```
#import "Fraction.h"
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Fraction *a, *b;
a = [[Fraction alloc] initWith: 1: 3];
b = [[Fraction alloc] initWith: 3: 7];
[a print];
[b print];
[a release];
[b release];
[pool drain];
return 0;
}
```
Вывод программы 10.1
```
1/3
3/7
```
Когда программа начинает выполнение, она передает метод вызова инициализации всем нашим классам. Если имеется класс и связанный с ним подкласс, родительский класс получает это сообщение первым. Это сообщение
передается каждому классу только один раз, и оно гарантированно отправляется до того, как любые другие сообщения будут переданы классу. Ваша цель в
этот момент — выполнение инициализации любого класса. Например, вам может потребоваться инициализация некоторых статических переменных, связанных с данным классом.

## 10.2. Снова об области действия
На область действия переменных в программе можно влиять разными способами: с переменными экземпляра или с обычными переменными, определенными вне или внутри функций. Ниже мы будем использовать термин модуль
(module ) при ссылке на любое число определений методов или функций, содержащихся в одном исходном файле.

### Директивы для управления областью действия переменных экземпляра
Вы уже знаете, что переменные экземпляра имеют область действия, которая
ограничивается методами экземпляра, определенными для данного класса.
Поэтому любой метод экземпляра может выполнять доступ к свои переменным экземпляра по имени без дополнительных действий.
Вы также знаете, что переменные экземпляра наследуются подклассом. Д оступ к переменным экземпляра тоже можно выполнять по имени из любого
метода, определенного в этом подклассе. И в этом случае специальные действия тоже не требуются.

Перед переменными экземпляра при объявлении в секции interface можно
помещать четыре директивы, чтобы более точно управлять их областью действия.
* @protected. Методы, определенные в данном классе и любых подклассах, могут выполнять непосредственный доступ к последующим переменным экземпляра. Это вариант по умолчанию.
* @private. Методы, определенные в данном классе (но не в подклассах), могут выполнять непосредственный доступ к последующим переменным экземпляра.
* @public. Методы, определенные в данном классе и любых классах или модулях, могут выполнять непосредственный доступ к последующим переменным экземпляра.
* @package. Для 64-битных образов доступ к переменной экземпляра может выполняться в любом месте образа, который реализует данный класс.

Если вам нужно определить класс с именем Printer, содержащий две частные
переменные экземпляра с именами pageCount и tonerLevel, которые доступны только методам из класса Printer, то вы можете использовать следующую секцию
interface.
```
@interface Printer: NSObject
{
@ private
int pageCount;
int tonerLevel;
@ protected
// другие переменные экземпляра
}
@end
```
Доступ к этим двум переменным экземпляра нельзя выполнить из любого
подкласса класса Printer, поскольку они сделаны частными (private).

Эти специальные директивы действуют как переключатели: все переменные,
которые появляются после одной из этих директив (пока не появится правая
фигурная скобка, которая являются концом объявлений этих переменных), имеют
указанную область действия, если не использована другая директива. В приведенном примере директива @protected гарантирует, что следующие после нее переменные экземпляра будут доступны для методов подклассов и класса Printer.

Директива @public делает переменные экземпляра доступными для других
методов или функций с помощью оператора-указателя (->), который описывается в главе 13. Такой доступ к переменным экземпляра не допускается практикой надежного программирования, поскольку он нарушает концепцию инкапсуляции данных (то есть скрытие классом своих переменных экземпляра).

### Внешние переменные
Если написать
```
int gMoveNumber = 0;
```
в начале программы — вне любого метода, определения класса или функции, —
то ее значение можно использовать из любого места данного модуля. В этом
случае gMoveNumber определяется как гло б а ль н а я переменная. Обычно принято
использовать букву g как первую букву глобальной переменной, чтобы обозначить для читателя программы ее область действия.

На самом деле такое определение переменной gMoveNumber делает ее значение доступным из других файлов. Приведенный оператор определяет переменную gMoveNumber не только как глобальную переменную, но и как внешнюю глобальную переменную.

Внешней (external) переменной является переменная, чье значение может
изменяться другими методами или функциями. Внутри модуля, из которого
требуется доступ к этой переменной, она объявляется обычным образом, перед
ее объявлением ставится ключевое слово extern. Это указывает системе, что требуется доступ к глобально определенной переменной из другого файла. Ниже
показан пример объявления переменной gMoveNumber как внешней переменной.
```
extern int gMoveNumber;
```
Модуль, в котором появилось это объявление, может выполнять доступ к
переменной gMoveNumber и изменять ее значение. Другие модули тоже могут
выполнять доступ к значению gMoveNumber, используя в своем файле аналогичное объявление extern.

При работе с внешними переменными соблюдайте следующее важное правило. Такая переменная должна быть определена среди ваших исходных файлов. Она должна быть объявлена вне любого метода или функции, и перед ней
не должно быть ключевого слова extern, например,
Дополнительно такой переменной может быть присвоено начальное значение, как показано выше.

Второй способ определения внешней переменной — это объявление переменной вне любой функции с ключевым словом extern перед этим объявлением и явным присваиванием начального значения этой переменной, например,
```
extern int gMoveNumber = 0;
```
Однако при таком способе компилятор предупредит вас, что вы объявили
переменную как extern и одновременно присвоили ей значение. Использование
слова extern делает его объявлением, а не определением для переменной, а объявление не вызывает выделения памяти для переменной — это происходит в результате определения. В приведенном примере это правило нарушается, поскольку объявление интерпретируется как определение (поскольку переменной
присваивается начальное значение).

При работе с внешними переменными можно объявлять переменную как
extern во многих местах, но определить ее можно только один раз.
Рассмотрим программу как пример использования внешних переменных.
Мы определили класс с именем Foo и ввели следующий код в файл main.m:
```
#import "Foo.h"
int gGlobalVar = 5;
int main (int argc, char *argc[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Foo *myFoo = [[Foo alloc] init];
NSLog (@"%i", gGlobalVar);
[myFoo setgGlobalVar: 100]
NSLog (@"%i", gGlobalVar);
[myFoo release];
[pool drain];
return 0;
}
```
Определение глобальной переменной gGlobalVar в этой программе делает ее
значение доступным для любого метода (или функции), где используется соответствующее объявление extern. Предположим, что используется метод класса
Foo с именем setgGlobalVar:.
```
-(void) setgGlobalVar: (int) val
{
extern int gGlobalVar;
gGlobalVar = val;
}
```
Программа выведет следующие результаты.
```
5
100
```
Таким образом, метод setgGlobalVar: может выполнять доступ к внешней переменной gGlobalVar и изменять ее значение.

В тех случаях, когда доступ к значению gGlobalVar требуется многим методам,
проще включить объявление extern только один раз в начале файла. Но если доступ к этой переменной требуется одному методу или небольшому числу методов,
то имеет смысл включать объявления extern в каждый из таких методов; это сделает программу более организованной и ограничит использование конкретной переменной теми функциями, в которых она действительно требуется. Отметим,
что если переменная определена внутри файла, содержащего код, который выполняет доступ к этой переменной, то отдельные объявления extern не требуются.

### Статические переменные
Только что показанный пример нарушает принцип инкапсуляции данных и практику надежного объектно-ориентированного программирования. Но вам может
потребоваться работа с переменными, значения которых должны быть доступны
для вызова из различных методов. Может показаться, что нет смысла делать переменную gGlobalVar переменной экземпляра в классе Foo, надежнее «скрыть» ее в
классе Foo путем ограничения доступа к ней методами-установщиками (setter) и
методами-получателями (getter), определенными для этого класса.

Теперь вы знаете, что любая переменная, определенная вне метода, является не только глобальной, но и внешней переменной. Но существует много ситуаций, когда нужно определить переменную, которая является глобальной, но
не является внешней. Иначе говоря, вам нужно определить глобальную переменную, которая будет локальной для определенного модуля (файла). Имеет
смысл определять такую переменную, если доступ к ней требуется только тем
методам, которые содержатся в конкретном определении класса. Это можно
сделать, определив переменную как статическую (static) внутри файла, содержащего секцию implementation для конкретного класса.

Если следующий оператор помещен вне любого метода (или функции), то
значение gGlobalVar будет доступно из любой последующей точки файла, содержащей это определение, но будет недоступно из методов или функций, содержащихся в других файлах.
```
static int gGlobalVar = 0;
```
Напомним, что методы класса не имеют доступа к переменным экземпляра
(подумайте, почему это относится к данному случаю). Но вам может потребоваться, чтобы какой-либо метод класса имел доступ к переменным и мог задавать их значения. В качестве простого примера можно указать метод класса,
выделяющий память для объектов (alloc), который должен следить за числом
объектов. Это можно сделать, создав статическую переменную внутри файла
секции implementation для этого класса. Метод, выделяющий память для объектов, может выполнять непосредственный доступ к этой переменной, поскольку она не будет переменной экземпляра. Пользователям данного класса необязательно знать об этой переменной. Поскольку она определена как статическая
переменная в файле секции implementation, ее область действия будет ограничена этим файлом, поэтому пользователи не будут иметь непосредственного
доступа к этой переменной и концепция инкапсуляции данных не будет нарушена. Вы можете написать метод для считывания значения этой переменной,
если требуется доступ извне этого класса.

В программе 10.2 определение класса Fraction расширяется за счет добавления двух новых методов. Метод класса allocF выделяется память для нового объекта типа Fraction и следит за числом дробей (объектов Fraction), которые он выделил, а метод count возвращает значение этого счетчика. Метод count тоже является
методом класса. Его можно было бы реализовать как метод экземпляра, но лучше запросить класс, сколько экземпляров он выделил, вместо передачи сообщения определенному экземпляру этого класса.

Ниже приводятся объявления для двух новых методов класса, добавленные
в файл Fraction.h.
```
+(Fraction *) allocF;
+(int) count;
```
Отметим, что здесь не замещается наследуемый метод alloc; вместо этого определяется наш собственный метод выделения памяти. В этом методе будет
использоваться наследуемый метод alloc. Следующий код нужно поместить в
файл секции implementation Fraction.m.
```
static int gCounter;
@implementation Fraction
+(Fraction *) allocF
{
extern int gCounter;
++gCounter;
return [Fraction alloc];
}
+(int) count
{
extern int gCounter;
return gCounter;
}
// здесь находятся другие методы из класса Fraction
@end
```
**Примечание.** В практике надежного программирования не принято замещать
метод alloc, поскольку он работает с физическим местоположением в памяти.
Не следует вмешиваться в работу системы на этом уровне.

Объявление static для переменной gCounter делает ее доступной для любого
метода, определенного в секции implementation, но при этом она недоступна
вне этого файла. Метод allocF просто наращивает значение переменной gCounter
и затем использует метод alloc для создания новой дроби (Fraction), возвращая
результат. Метод count просто возвращает значение счетчика (gCounter), не давая
пользователю непосредственный доступ к этой переменной.

Напомним, что объявления extern не требуются в этих методах, поскольку
переменная gCounter определена внутри этого файла. Это просто помогает читателю метода понять, что выполняется доступ к переменной, определенной вне
метода. Префикс g в имени переменной предназначен для той же цели, поэтому большинство программистов обычно не включают объявления extern.
В программе Ю.2 выполняется тестирование этих методов.
```
#import "Fraction.h"
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Fraction *a, *b, *c;
NSLog (@"Fractions allocated: %i", [Fraction count]);
a = [[Fraction allocF] init];
b = [[Fraction allocF] init];
c = [[Fraction allocF] init];
NSLog (@"Fractions allocated: %i", [Fraction count]);
[a release];
[b release];
[c release];
[pool drain];
return 0;
}
```
Вывод программы 10.2
```
Fractions allocated: 0 (Выделено объектов Fraction)
Fractions allocated: 3
```
Когда начинается выполнение этой программы, значение gCounter автоматически задается равным 0 (напомним, что вы можете замещать наследуемый
метод инициализации класса, если хотите выполнить специальную инициализацию класса в целом, например, присвоить статическим переменным некоторые ненулевые значения). После выделения (и последующей инициализации)
трех объектов типа Fraction с помощью метода allocF метод count считывает переменную counter, значение которой действительно стало равным 3. Вы можете
добавить метод-установщик (setter) для этого класса, если хотите выполнять
сброс счетчика или задавать для него определенное значение, но в данном случае это не требуется.

## 10.3. Описатели хранения для класса
Вы уже познакомились с описателями хранения для класса, которые можно
помещать перед именами переменных. Здесь мы рассмотрим другие описатели, которые предоставляют компилятору информацию о предполагаемом использовании переменной в программе.

### auto
Это ключевое слово используется для объявления автоматической локальной
переменной (в противоположность статической). Это описатель по умолчанию
для объявления переменной внутри функции или метода, но никто не использует его в явном виде.
```
auto int index;
```
Это объявление переменной index как автоматической локальной переменной; это означает, что для нее выполняется автоматическое выделение памяти
при входе в блок (которым может быть заключенная в фигурные скобки последовательность операторов, метод или функция) и автоматическое освобождение при выходе из этого блока. Поскольку это происходит по умолчанию внутри блока, оператор
```
int index;
```
эквивалентен оператору
```
auto int index;
```
В отличие от статических переменных, которые имеют по умолчанию начальные значения 0, автоматические переменные остаются неопределенными,
пока вы не присвоите им значения в явном виде.

### const
Компилятор позволяет связывать атрибут const с переменными, значения которых не будут изменяться. Иначе говоря, он сообщает компилятору, что указанные переменные имеют постоянное значение при выполнении программы. Если
попытаться присвоить значение переменной, объявленной с атрибутом const,
после инициализации, или попытаться выполнить ее наращивание или уменьшение, компилятор выдаст предупреждающее сообщение. Ниже в переменной
pi используется атрибут const:
```
const double pi = 3.141592654;
```
Он указывает компилятору, что программа не будет изменять эту переменную. Естественно, значение такой переменной должно быть инициализировано при ее определении.

Определение переменной с атрибутом const указывает читателю, что программа не будет изменять значение этой переменной.

### volatile
Это описатель, противоположный const. Он в явном виде указывает компилятору, что соответствующая переменная будет изменять свое значение. Он включен в язык Objective-C, чтобы компилятор не оптимизировал операторы, которые кажутся избыточными, и выполнял повторную проверку переменной, когда
ее значение, казалось бы, не изменяется. Типичный пример — порт ввода-вывода, (I/O) (подробнее см. главу 13).

Предположим, что у вас имеется адрес выходного порта, хранящегося в программе в переменной с именем outPort. Записать в этот порт два символа, например 0 и N, можно с помощью следующего кода.
```
*outPort = 'O’;
*outPort = ’N’;
```
В первой строке указывается, что символ 0 нужно сохранить по адресу памяти, указанному переменной outPort. Во второй строке указывается, что символ N нужно сохранить по тому же адресу. Оптимизирующий компилятор может заметить, что это две последовательные записи по одному адресу, и
поскольку outPort между ними не изменяется, может просто удалить первый оператор из программы. Чтобы этого не произошло, нужно объявить переменную
outPort с атрибутом volatile, например:
```
volatile char *outPort;
```

## 10.4. Перечислимые типы данных
Язык Objective-C позволяет задавать диапазон значений, которые могут быть
присвоены переменной. Определение перечислимого типа данных инициируется с помощью ключевого слова enum. Сразу после этого ключевого слова еле-
дует имя перечислимого типа данных и затем список идентификаторов (заключенных в фигурные скобки), которые определяют допустимые значения для
этого типа. В следующем операторе определяется тип данных flag:
```
enum flag { false, true };
```
Теоретически этому типу данных внутри программы могут быть присвоены
только значения true и false. К сожалению, компилятор Objective-C не выдает
предупреждающего сообщения, если это правило нарушается.

Чтобы объявить переменную типа enum flag, нужно снова использовать ключевое слово enum, после которого следует имя перечислимого типа и список
переменных. Например, в следующем операторе определяются две переменные типа flag: endOfData и matchFound.
```
enum flag endOfData, matchFound;
```
Единственные значения, которые могут быть присвоены этим переменным —
true и false. Следующие операторы являются допустимыми.
```
endOfData = true;
if ( matchFound == false )
```
Если вам нужно, чтобы определенное целое значение было связано с идентификатором перечисления, это целое значение можно присвоить идентификатору, когда определяется тип данных. Идентификаторам перечисления, которые появляются затем в списке, будут присвоены последовательные целые
значения, начиная с указанного целого значения, увеличенного на I.

В следующем определении перечислимый тип данных direction определяется
со значениями up, down, left и right.
```
enum direction { up, down, left = 10, right}; (вверх, вниз, влево, вправо)
```
Компилятор присвоит значение 0 идентификатору up, поскольку он представлен первым в списке, присвоит 1 идентификатору down, поскольку он является следующим в списке, присвоит 10 идентификатору left, поскольку здесь явно
задано это значение, и присвоит 11 идентификатору right, поскольку это увеличенное на 1 значение предыдущего идентификатора в списке.

Идентификаторы перечисления могут иметь одинаковое значение. Например, если в строке
```
enum boolean { no = 0, false = 0, yes = 1, true = 1 };
```
булевой переменной типа enum присваивается значение по или false, то ей присваивается значение 0; если присваивается значение yes или true, то присваивается значение 1.

Ниже приводится еще один пример определения перечислимого типа данных. В нем определяется тип enum month с допустимыми значениями, которые
могут быть присвоены переменной этого типа — названиями месяцев.
```
enum month { january = 1, february, march, april, may, june, july,
august, September, October, november, december};
```
Компилятор Objective-C интерпретирует идентификаторы перечисления как
целые константы. Переменной thisMonth будет присвоено значение 2 (а не а не
название месяца february), если программа содержит следующие две строки:
enum month thisMonth;
```
thisMonth = february;
```
В программе 10.3 используются перечислимые типы данных. В ней читается номер месяца, а затем выполняется оператор switch, чтобы определить, какой
месяц был введен. Напомним, что перечислимые значения интерпретируются
как целые константы, поэтому они являются допустимыми case-значениями.

Переменной days присваивается число дней в указанном месяце, и ее значение
выводится после выхода из оператора switch. Для февраля (February) введена
специальная проверка.
```
// вывод числа дней месяца
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
enum month { january = 1, february, march, april, may, june,
july, august, September, October, november,
d ecem b er};
enum month amonth;
int days;
NSLog (@"Enter month number:");
scant ("%i", &amonth);
switch (amonth) {
case january:
case march:
case may:
case july:
case august:
case October:
case december:
days = 31;
break;
case april:
case june:
case September:
case november:
days = 30;
break;
case february:
days = 28;
break;
default:
NSLog (@>"bad month number");
days = 0;
break;
}
if ( days != 0)
NSLog (@"Number of days is %i", days);
if ( amonth == february)
NSLog (@"...or 29 if it’s a leap year");
[pool drain];
return 0;
}
```
Вывод программы 10.3
```
Enter month number: (Введите номер месяца)
5
Number of days is 31 (Число дней = 31)
Вывод программы 10.3 (повторный запуск)
Enter month number:
2
Number of days is 28 ...or 29 if it's a leap year
(Число дней = 28 ... или 29, если это високосный год)
```
Вы можете явно присвоить целое значение переменной перечислимого типа
данных; это делается с помощью оператора приведения типа (type cast). Н апример, если monthValue является переменной целого типа, имеющей значение
6, то следующее выражение является допустимым.
```
lastMonth = (enum month) (monthValue • 1);
```
Если вы не используете оператор приведения типа, компилятор, к сожалению, нс реагирует на это.

При использовании программ с перечислимыми типами данных старайтесь
не полагаться на то, что перечислимые значения интерпретируются как целые
числа. Вместо этого их следует рассматривать как отдельные типы данных. Перечислимый тип данных позволяет связывать символическое имя с целым чис-
лом. Если вам потребуется изменить значение этого числа, вам придется изменить его только в том месте, где определено перечисление. Если вы делаете предположения, основанные на фактическом значении перечислимого типа данных, то теряете преимущество перечисления.

При определении перечислимого типа данных имя типа данных может не
указываться, и переменные могут быть объявлены как конкретный перечислимый тип данных, если этот тип определен.

Оператор
```
enum { east, west, south, north } direction;
```
определяет неименованный перечислимый тип данных со значениями east, west,
south и north (восток, запад, юг и север) и объявляет переменную (direction) этого
типа.

Определение перечислимого типа данных в блоке ограничивает область действия этого определения данным блоком. С другой стороны, определение перечислимого типа данных в начале программы (вне какого-либо блока) делает
определение глобальным для данного файла.

Определяя перечислимый тип данных, вы должны проследить, чтобы идентификаторы перечисления были уникальными по отношению к именам других
переменных и идентификаторам перечисления, определенным в той же области действия.

## 10.5. Оператор typedef
Objective-C позволяет назначать для типа данных альтернативное имя. Для этого используется оператор typedef. В следующей строке определяется имя Counter
(счетчик) как эквивалент типа данных Objective-C int.
```
typedef int Counter;
```
Затем можно объявить переменные с типом Counter, как в следующей строке.
```
Counter j, n;
```
Компилятор Objective-C будет интерпретировать это как объявление обычных целых переменных j и п. Определение j и п посредством typedef указывает
назначение переменных в программе. Объявление в традиционной форме с
типом int оставило бы их назначение непонятным.Ниже с помощью typedef определяется тип с именем NumberObject для объектов типа Number.
```
typedef Number *NumberObject;
```
Переменные, которые объявляются затем с типом NumberObject, как в строке
NumberObject myValuel, myValue2, myResult;
будут интерпретироваться так, как если бы они были объявлены обычным образом:
```
Number *myValue1, *myValue2, *myResult;
```
Чтобы определить имя нового типа с помощью typedef, нужно выполнить
следующую процедуру.

1. Написать такое же объявление, как при объявлении переменной нужного типа.
2. Там, где должно быть имя объявляемой переменной, поместить имя нового
типа.
3. Перед всем этим поставить слово typedef.

Для примера определим тип с именем Direction (Направление) как перечислимый тип данных со значениями east, west, north и south (восток, запад, юг и
север), напишем определение этого перечислимого типа данных и подставим
имя Direction там, где обычно ставится имя переменной. Перед всем этим нужно
поместить ключевое слово typedef.
```
typedef enum { east, west, south, north } Direction;
После этого можно объявлять переменные с типом Direction:
Direction stepl, step2;
Foundation framework содерж ит следую щ ее определение typedef для
NSComparisonResult в одном из заголовочных файлов.
enum NSComparisonResult {
NSOrderedAscending = -1, NSOrderedSame, NSOrderedDescending
};
typedef NSInteger NSComparisonResult;
```
Некоторые методы в Foundation framework, которые выполняют сравнение
(comparison), возвращают значение этого типа. Например, метод сравнения
строк Foundation с именем compare: возвращает значение типа NSComparisonResult
после сравнения двух строк, которые являются объектами NSString. Этот метод
объявляется следующим образом.
```
-(NSComparisonResult) compare: (NSString *) string;
```
Чтобы проверить равенство двух объектов NSString с именами userName и
savedName, можно включить в программу следующую строку.
```
if ( [userName compare: savedName] == NSOrderedSame) {
// Имена совпадают
}
```
На самом деле здесь проверяется, равен ли нулю результат метода compare:

## 10.6. Преобразования типов данных
В главе 4 говорилось о том, что иногда при оценке выражений система неявным образом выполняет преобразования. Там рассматривался случай с типами
данных float и int. Операция, включающая типы float и int, выполнялась как операция с плавающей точкой, и элемент данных целого типа автоматически преобразовывался в элемент с плавающей точкой.

Там же было показано, как использовать оператор приведения типа, чтобы
явно определить преобразование. Пусть total и п являются целыми переменными. В строке
```
average = (float) total / n;
```
значение переменной total преобразуется в тип float до выполнения операции,
что гарантирует выполнение деления как операции с плавающей точкой.

### Правила преобразования
Компилятор Objective-C соблюдает строгие правила при оценке выражений,
состоящих из разл ичных типов данных.

Ниже описывается порядок, в котором выполняются преобразования при оценке двух операндов в выражении.
1. Если один из операндов имеет тип long double, второй операнд преобразуется в long double, результат имеет такой же тип.
2. Если один из операндов имеет тип double, второй операнд преобразуется в double, результат имеет такой же тип.
3. Если один из операндов имеет тип float, второй операнд преобразуется в тип float, результат имеет такой же тип.
4. Если один из операндов имеет тип Bool, char, short int или bit field1 или перечислимый тип данных, то он преобразуется в тип int.
5. Если один из операндов имеет тип long long int, второй операнд преобразуется в long long int, результат имеет такой же тип.
6. Если один из операндов имеет тип long int, второй операнд преобразуется в long int, результат имеет такой же тип.
7. Если мы дошли до этого шага, то оба операнда имеют тип int, результат имеет такой же тип.

Это упрощенная версия шагов преобразования операндов в выражении.
Правила усложняются, если включены операнды без знака (unsigned). Полный
список правил см. в Приложении В.

Из этой последовательности шагов понятно, что если достигнут шаг, где говорится «результат имеет такой же тип», процесс преобразования закончен.

В качестве примера рассмотрим, в каком порядке выполняется оценка следующего выражения. В нем f имеет тип float, i — тип int, I — long int, s — переменная
типа short int.
```
f * i + I / s
```
1 В главе 13 кратко описывается тип bit field.

Рассмотрим сначала умножение f на i, то есть умножение переменной типа
float на переменную типа int. Из шага 3 известно, что поскольку f имеет тип float,
второй операнд (i) будет тоже преобразован в тип float, и такой же тип будет иметь
результат операции умножения.

Затем I делится на s, то есть выполняется деление переменной типа long int на
short int. Из шага 4 известно, что short int преобразуется в int. Переходим к шагу 6.
Поскольку один из операндов (1) имеет тип long int, второй операнд преобразуется в long int, и результат будет иметь такой же тип. Таким образом, это деление
дает значение типа long int, причем дробная часть отбрасывается.

И, наконец, шаг 3 указывает, что поскольку один из операндов выражения
имеет тип float (как результат умножения f * i), второй операнд будет преобразован в тип float, и результат будет иметь такой же тип. Таким образом, после деления I на s результат операции будет преобразован в тип float и затем прибавлен к
произведению f на i. Поэтому конечный результат этого выражения будет иметь
тип float.

Вы всегда можете использовать оператор приведения типа для явных преобразований, управляя оценкой конкретного выражения.

Например, если вы не хотите, чтобы при делении I на s в предыдущем выражении отбрасывалась дробная часть, то можете выполнить приведение одного
из этих операндов к типу float, чтобы выполнить деление с плавающей точкой:
```
f * i + (float) I / s
```
В этом выражении I будет преобразована в тип float до операции деления,
поскольку оператор приведения типа имеет более высокий приоритет, чем оператор деления. Поскольку один из операндов деления будет теперь иметь тип
float, другие операнды будут автоматически преобразованы в тип float, и такой
же тип будет иметь результат.

### Расширение для знака
Если переменная типа signed int или signed short преобразуется в тип int или тип
большего размера, то в результате преобразования слева тоже появляется описатель signed. Поэтому переменная типа short int, которая имеет значение -5, будет иметь значение -5 после преобразования в long int. Но если целая переменная
с описателем unsigned преобразуется в тип int или тип большего размера, то расширение для знака не происходит (как и можно было ожидать).

На некоторых машинах (например, с процессорами Intel, которые используются в современных семействах компьютеров Macintosh, или с процессорами ARM, которые используются в iPhone и iTouch) символы интерпретируются
как значения со знаком. Это означает, что если символ (character) преобразуется в целый тип, то происходит расширение для знака. Если используются символы из стандартного набора символов ASCII, это не создает проблем. Но если
значение символа не является частью этого стандартного набора символов, для
его знака может быть выполнено расширение, если символ преобразуется в целый тип. Например, на компьютерах Мае символьная константа '\377’ преобразуется в значение -1, потому что это значение является отрицательным, если
рассматривать его как 8-битное значение со знаком (signed).

Objective-C позволяет объявлять символьные переменны е без знака
(unsigned), что позволяет избежать этой потенциальной проблемы — переменная unsigned char не получает расширения для знака при преобразовании в целый
тип; ее значение всегда больше или равно нулю. Для обычного 8-битного символа символьная переменная со знаком имеет диапазон значений от -128 до +127
включительно. Символьная переменная без знака имеет диапазон значений от
О до 255 включительно.

Если ваши символьные переменные должны получать расширение для знака, вы можете объявить такие переменные с типом signed char. В главе 15 вы узнаете о многобайтных символах Unicode. Это предпочтительный способ работы со строками.

## Упражнения
1. Используя класс Rectangle из главы 8, добавьте метод-инициализатор в соответствии со следующим объявлением.
    ```
    -(Rectangle *) initWithWidth: (int) w: andHeight: (int) h;
    ```
2. С учетом того, что мы назвали метод, разработанный в упражнении 1, назначенным (designated) инициализатором для класса Rectangle, и основываясь на определениях классов Square и Rectangle из главы 8, добавьте методинициализатор в класс Square в соответствии со следующим объявлением.
    ```
    -(Square *) initWithSide: (int) side;
    ```
3. Добавьте счетчик (counter) к методу add: класса Fraction, чтобы вычислять количество вызовов этого метода. Каким образом вы можете считывать значение этого счетчика?
4. Используя typedef и перечислимые типы данных, определите тип с именем Day (День) с возможными значениями Sunday, Monday, Tuesday, Wednesday, Thursday, Friday и Saturday (Воскресенье, Понедельник, Вторник, Среда, Четверг, Пятница и Суббота).
5. Используя typedef, определите тип с именем FractionObj, который позволяет писать следующие операторы.
    ```
    FractionObj И = [[Fraction alloc] init],
    f2 = [[Fraction alloc] init];
    ```
6. Используя определения
    ```
    float f = 1.00;
    short int i = 100;
    long int I = 500L;
    double d = 15.00;
    ```
    и семь шагов, описанных выше для преобразования операндов в выражениях, определите тип и значение следующих выражений.
    ```
    f + i
    l/d
    i / l + f
    1 * i
    f / 2
    i / (d + f)
    1 / (i * 2.0)
    I + i / (double) I
    ```
7. Напишите программу, которая определяет, выполняется ли на вашей машине расширение для знака у переменных signed char.