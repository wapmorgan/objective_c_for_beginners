# Глава 10. Более подробно о переменных и типах данных
В этой главе мы поговорим об области действия переменных, методах инициа­
лизации для объектов и типах данных. В главе 7 мы кратко обсуждали область
действия переменных экземпляра, статические и локальные переменные. Те­
перь мы более подробно поговорим о статических переменных и введем поня­
тие глобальных и внешних переменных. Для компилятора Objective-C можно
задавать директивы, позволяющие контролировать область действия перемен­
ных экземпляра. В этой главе мы рассмотрим их.

Перечислимый (enumerated) тип данных позволяет определять имя для типа
данных, которое будет использоваться только для хранения заданного списка
значений. В языке Objective-C оператор typedef позволяет вам назначать собствен­
ное имя встроенному или производному типу данных. В этой главе мы описы­
ваем действия компилятора по преобразованию типов данных при оценке вы­
ражений.

## 10.1. Инициализация классов
Мы уже встречали такой набор действий, когда выделяется память для нового
экземпляра объекта, а затем выполняется его инициализация:
```
Fraction *myFract = [[Fraction alloc] init];
```
После вызова этих методов обычно выполняется присваивание некоторых
значений новому объекту:
```
[myFract setTo: 1 over: 3];
```
Процесс инициализации объекта, после которого ему присваиваются началь­
ные значения, часто объединяют в один метод. Например, можно определить
метод initWith::, который инициализирует объект типа fraction (дробь) и присваивает
два (неименованных) заданных аргумента его числителю (numerator) и знамена­
телю (denominator).

Класс, который содержит много методов и переменных экземпляра, обыч­
но имеет несколько методов инициализации. Например, класс NSArray из
Foundation framework содержит шесть методов инициализации.
```
initWithArray:
initWithArrayxopyltems:
initWithContentsOfFile:
initWithContentsOfURL:
initWithObjects:
initWithObjects:count:
```
Массиву (array) можно выделить память и затем инициализировать его, на­
пример, с помощью следующей последовательности:
```
myArray = [[NSArray alloc] initWithArray: myOtherArray];
```
Принято, что все инициализаторы в классе обычно начинаются с init. Ини­
циализаторы NSArray следуют этому правилу. При написании инициализаторов
вы можете придерживаться одной из двух стратегий.

Если ваш класс содержит более одного инициализатора, один из них должен
быть вашим назначенным (designated ) инициализатором, и все остальные методы
инициализации должны его использовать. Обычно это более сложный метод
инициализации (и принимает больше всего параметров). При создании назна­
ченного инициализатора основной код инициализации объединяется в одном
методе. При создании подкласса можно затем замещать назначенный инициа­
лизатор, чтобы обеспечить правильную инициализацию новых экземпляров.
Необходимо следить за тем, чтобы правильно инициализировались любые
наследуемые переменные экземпляра. Наиболее простой способ —вызывать
сначала назначенный метод инициализации из родительского класса, который
обычно называется init, а после этого инициализировать свои собственные пе­
ременные экземпляра.

Исходя из этого, метод инициализации initWith:: для класса Fraction может выг­
лядеть следующим образом.
```
-(Fraction *) initWith: (int) n: (int) d
{
self = [super init];
if (self)
[self setTo: n over: d];
return self;
}
```
Этот метод вызывает сначала родительский инициализатор, которым явля­
ется метод init из NSObject (напомним, что это родительский класс для Fraction).

Вы должны присвоить результат self, поскольку инициализатор имеет право
изменять или перемещать объект в памяти.

После инициализации super (и ее успешного завершения, что указывается
ненулевым возвращаемым значением) используется метод setTo:over:, чтобы за­
дать числитель (numerator) и знаменатель (denominator) дроби (Fraction). Как и
для других методов инициализации, предполагается, что вы возвращаете ини­
циализированный объект.

В программе 10.1 выполняется проверка нового метода инициализации initWith::.
Программа 10.1
```
#import "Fraction.h"
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Fraction *a, *b;
a = [[Fraction alloc] initWith: 1: 3];
b = [[Fraction alloc] initWith: 3: 7];
[a print];
[b print];
[a release];
[b release];
[pool drain];
return 0;
}
```
Вывод программы 10.1
```
1/3
3/7
```
Когда программа начинает выполнение, она передает метод вызова иници­
ализации всем нашим классам. Если имеется класс и связанный с ним под­
класс, родительский класс получает это сообщение первым. Это сообщение
передается каждому классу только один раз, и оно гарантированно отправляет­
ся до того, как любые другие сообщения будут переданы классу. Ваша цель в
этот момент — выполнение инициализации любого класса. Например, вам мо­
жет потребоваться инициализация некоторых статических переменных, свя­
занных с данным классом.

## 10.2. Снова об области действия
На область действия переменных в программе можно влиять разными спосо­
бами: с переменными экземпляра или с обычными переменными, определен­
ными вне или внутри функций. Ниже мы будем использовать термин модуль
(module ) при ссылке на любое число определений методов или функций, содер­
жащихся в одном исходном файле.

### Директивы для управления областью действия переменных экземпляра
Вы уже знаете, что переменные экземпляра имеют область действия, которая
ограничивается методами экземпляра, определенными для данного класса.
Поэтому любой метод экземпляра может выполнять доступ к свои перемен­
ным экземпляра по имени без дополнительных действий.
Вы также знаете, что переменные экземпляра наследуются подклассом. Д о­
ступ к переменным экземпляра тоже можно выполнять по имени из любого
метода, определенного в этом подклассе. И в этом случае специальные дей­
ствия тоже не требуются.

Перед переменными экземпляра при объявлении в секции interface можно
помещать четыре директивы, чтобы более точно управлять их областью действия.
* @protected. Методы, определенные в данном классе и любых подклассах, могут выполнять непосредственный доступ к последующим переменным экземпляра. Это вариант по умолчанию.
* @private. Методы, определенные в данном классе (но не в подклассах), могут выполнять непосредственный доступ к последующим переменным экземпляра.
* @public. Методы, определенные в данном классе и любых классах или модулях, могут выполнять непосредственный доступ к последующим переменным экземпляра.
* @package. Для 64-битных образов доступ к переменной экземпляра может выполняться в любом месте образа, который реализует данный класс.

Если вам нужно определить класс с именем Printer, содержащий две частные
переменные экземпляра с именами pageCount и tonerLevel, которые доступны толь­
ко методам из класса Printer, то вы можете использовать следующую секцию
interface.
```
@interface Printer: NSObject
{
@ private
int pageCount;
int tonerLevel;
@ protected
// другие переменные экземпляра
}
@end
```
Доступ к этим двум переменным экземпляра нельзя выполнить из любого
подкласса класса Printer, поскольку они сделаны частными (private).

Эти специальные директивы действуют как переключатели: все переменные,
которые появляются после одной из этих директив (пока не появится правая
фигурная скобка, которая являются концом объявлений этих переменных), имеют
указанную область действия, если не использована другая директива. В приве­
денном примере директива @protected гарантирует, что следующие после нее пе­
ременные экземпляра будут доступны для методов подклассов и класса Printer.

Директива @public делает переменные экземпляра доступными для других
методов или функций с помощью оператора-указателя (->), который описыва­
ется в главе 13. Такой доступ к переменным экземпляра не допускается практи­
кой надежного программирования, поскольку он нарушает концепцию инкап­
суляции данных (то есть скрытие классом своих переменных экземпляра).

### Внешние переменные
Если написать
```
int gMoveNumber = 0;
```
в начале программы — вне любого метода, определения класса или функции, —
то ее значение можно использовать из любого места данного модуля. В этом
случае gMoveNumber определяется как гло б а ль н а я переменная. Обычно принято
использовать букву g как первую букву глобальной переменной, чтобы обозна­
чить для читателя программы ее область действия.

На самом деле такое определение переменной gMoveNumber делает ее значе­
ние доступным из других файлов. Приведенный оператор определяет перемен­
ную gMoveNumber не только как глобальную переменную, но и как внешнюю глобальную переменную.

Внешней (external) переменной является переменная, чье значение может
изменяться другими методами или функциями. Внутри модуля, из которого
требуется доступ к этой переменной, она объявляется обычным образом, перед
ее объявлением ставится ключевое слово extern. Это указывает системе, что тре­
буется доступ к глобально определенной переменной из другого файла. Ниже
показан пример объявления переменной gMoveNumber как внешней переменной.
```
extern int gMoveNumber;
```
Модуль, в котором появилось это объявление, может выполнять доступ к
переменной gMoveNumber и изменять ее значение. Другие модули тоже могут
выполнять доступ к значению gMoveNumber, используя в своем файле аналогич­
ное объявление extern.

При работе с внешними переменными соблюдайте следующее важное пра­
вило. Такая переменная должна быть определена среди ваших исходных фай­
лов. Она должна быть объявлена вне любого метода или функции, и перед ней
не должно быть ключевого слова extern, например,
Дополнительно такой переменной может быть присвоено начальное значе­
ние, как показано выше.

Второй способ определения внешней переменной — это объявление пере­
менной вне любой функции с ключевым словом extern перед этим объявлени­
ем и явным присваиванием начального значения этой переменной, например,
```
extern int gMoveNumber = 0;
```
Однако при таком способе компилятор предупредит вас, что вы объявили
переменную как extern и одновременно присвоили ей значение. Использование
слова extern делает его объявлением, а не определением для переменной, а объяв­
ление не вызывает выделения памяти для переменной — это происходит в ре­
зультате определения. В приведенном примере это правило нарушается, по­
скольку объявление интерпретируется как определение (поскольку переменной
присваивается начальное значение).

При работе с внешними переменными можно объявлять переменную как
extern во многих местах, но определить ее можно только один раз.
Рассмотрим программу как пример использования внешних переменных.
Мы определили класс с именем Foo и ввели следующий код в файл main.m:
```
#import "Foo.h"
int gGlobalVar = 5;
int main (int argc, char *argc[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Foo *myFoo = [[Foo alloc] init];
NSLog (@"%i", gGlobalVar);
[myFoo setgGlobalVar: 100]
NSLog (@"%i", gGlobalVar);
[myFoo release];
[pool drain];
return 0;
}
```
Определение глобальной переменной gGlobalVar в этой программе делает ее
значение доступным для любого метода (или функции), где используется соот­
ветствующее объявление extern. Предположим, что используется метод класса
Foo с именем setgGlobalVar:.
```
-(void) setgGlobalVar: (int) val
{
extern int gGlobalVar;
gGlobalVar = val;
}
```
Программа выведет следующие результаты.
```
5
100
```
Таким образом, метод setgGlobalVar: может выполнять доступ к внешней пере­
менной gGlobalVar и изменять ее значение.

В тех случаях, когда доступ к значению gGlobalVar требуется многим методам,
проще включить объявление extern только один раз в начале файла. Но если дос­
туп к этой переменной требуется одному методу или небольшому числу методов,
то имеет смысл включать объявления extern в каждый из таких методов; это сдела­
ет программу более организованной и ограничит использование конкретной пе­
ременной теми функциями, в которых она действительно требуется. Отметим,
что если переменная определена внутри файла, содержащего код, который вы­
полняет доступ к этой переменной, то отдельные объявления extern не требуются.

### Статические переменные
Только что показанный пример нарушает принцип инкапсуляции данных и прак­
тику надежного объектно-ориентированного программирования. Но вам может
потребоваться работа с переменными, значения которых должны быть доступны
для вызова из различных методов. Может показаться, что нет смысла делать пе­
ременную gGlobalVar переменной экземпляра в классе Foo, надежнее «скрыть» ее в
классе Foo путем ограничения доступа к ней методами-установщиками (setter) и
методами-получателями (getter), определенными для этого класса.

Теперь вы знаете, что любая переменная, определенная вне метода, являет­
ся не только глобальной, но и внешней переменной. Но существует много си­
туаций, когда нужно определить переменную, которая является глобальной, но
не является внешней. Иначе говоря, вам нужно определить глобальную пере­
менную, которая будет локальной для определенного модуля (файла). Имеет
смысл определять такую переменную, если доступ к ней требуется только тем
методам, которые содержатся в конкретном определении класса. Это можно
сделать, определив переменную как статическую (static) внутри файла, содер­
жащего секцию implementation для конкретного класса.

Если следующий оператор помещен вне любого метода (или функции), то
значение gGlobalVar будет доступно из любой последующей точки файла, содер­
жащей это определение, но будет недоступно из методов или функций, содер­
жащихся в других файлах.
```
static int gGlobalVar = 0;
```
Напомним, что методы класса не имеют доступа к переменным экземпляра
(подумайте, почему это относится к данному случаю). Но вам может потребо­
ваться, чтобы какой-либо метод класса имел доступ к переменным и мог зада­
вать их значения. В качестве простого примера можно указать метод класса,
выделяющий память для объектов (alloc), который должен следить за числом
объектов. Это можно сделать, создав статическую переменную внутри файла
секции implementation для этого класса. Метод, выделяющий память для объек­
тов, может выполнять непосредственный доступ к этой переменной, посколь­
ку она не будет переменной экземпляра. Пользователям данного класса необя­
зательно знать об этой переменной. Поскольку она определена как статическая
переменная в файле секции implementation, ее область действия будет ограни­
чена этим файлом, поэтому пользователи не будут иметь непосредственного
доступа к этой переменной и концепция инкапсуляции данных не будет нару­
шена. Вы можете написать метод для считывания значения этой переменной,
если требуется доступ извне этого класса.

В программе 10.2 определение класса Fraction расширяется за счет добавле­
ния двух новых методов. Метод класса allocF выделяется память для нового объек­
та типа Fraction и следит за числом дробей (объектов Fraction), которые он выде­
лил, а метод count возвращает значение этого счетчика. Метод count тоже является
методом класса. Его можно было бы реализовать как метод экземпляра, но луч­
ше запросить класс, сколько экземпляров он выделил, вместо передачи сооб­
щения определенному экземпляру этого класса.

Ниже приводятся объявления для двух новых методов класса, добавленные
в файл Fraction.h.
```
+(Fraction *) allocF;
+(int) count;
```
Отметим, что здесь не замещается наследуемый метод alloc; вместо этого оп­
ределяется наш собственный метод выделения памяти. В этом методе будет
использоваться наследуемый метод alloc. Следующий код нужно поместить в
файл секции implementation Fraction.m.
```
static int gCounter;
@implementation Fraction
+(Fraction *) allocF
{
extern int gCounter;
++gCounter;
return [Fraction alloc];
}
+(int) count
{
extern int gCounter;
return gCounter;
}
// здесь находятся другие методы из класса Fraction
@end
```
**Примечание.** В практике надежного программирования не принято замещать
метод alloc, поскольку он работает с физическим местоположением в памяти.
Не следует вмешиваться в работу системы на этом уровне.

Объявление static для переменной gCounter делает ее доступной для любого
метода, определенного в секции implementation, но при этом она недоступна
вне этого файла. Метод allocF просто наращивает значение переменной gCounter
и затем использует метод alloc для создания новой дроби (Fraction), возвращая
результат. Метод count просто возвращает значение счетчика (gCounter), не давая
пользователю непосредственный доступ к этой переменной.

Напомним, что объявления extern не требуются в этих методах, поскольку
переменная gCounter определена внутри этого файла. Это просто помогает чита­
телю метода понять, что выполняется доступ к переменной, определенной вне
метода. Префикс g в имени переменной предназначен для той же цели, поэто­
му большинство программистов обычно не включают объявления extern.
В программе Ю.2 выполняется тестирование этих методов.
```
#import "Fraction.h"
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Fraction *a, *b, *c;
NSLog (@"Fractions allocated: %i", [Fraction count]);
a = [[Fraction allocF] init];
b = [[Fraction allocF] init];
c = [[Fraction allocF] init];
NSLog (@"Fractions allocated: %i", [Fraction count]);
[a release];
[b release];
[c release];
[pool drain];
return 0;
}
```
Вывод программы 10.2
```
Fractions allocated: 0 (Выделено объектов Fraction)
Fractions allocated: 3
```
Когда начинается выполнение этой программы, значение gCounter автома­
тически задается равным 0 (напомним, что вы можете замещать наследуемый
метод инициализации класса, если хотите выполнить специальную инициали­
зацию класса в целом, например, присвоить статическим переменным некото­
рые ненулевые значения). После выделения (и последующей инициализации)
трех объектов типа Fraction с помощью метода allocF метод count считывает пере­
менную counter, значение которой действительно стало равным 3. Вы можете
добавить метод-установщик (setter) для этого класса, если хотите выполнять
сброс счетчика или задавать для него определенное значение, но в данном слу­
чае это не требуется.

## 10.3. Описатели хранения для класса
Вы уже познакомились с описателями хранения для класса, которые можно
помещать перед именами переменных. Здесь мы рассмотрим другие описате­
ли, которые предоставляют компилятору информацию о предполагаемом ис­
пользовании переменной в программе.

### auto
Это ключевое слово используется для объявления автоматической локальной
переменной (в противоположность статической). Это описатель по умолчанию
для объявления переменной внутри функции или метода, но никто не исполь­
зует его в явном виде.
```
auto int index;
```
Это объявление переменной index как автоматической локальной перемен­
ной; это означает, что для нее выполняется автоматическое выделение памяти
при входе в блок (которым может быть заключенная в фигурные скобки после­
довательность операторов, метод или функция) и автоматическое освобожде­
ние при выходе из этого блока. Поскольку это происходит по умолчанию внут­
ри блока, оператор
```
int index;
```
эквивалентен оператору
```
auto int index;
```
В отличие от статических переменных, которые имеют по умолчанию на­
чальные значения 0, автоматические переменные остаются неопределенными,
пока вы не присвоите им значения в явном виде.

### const
Компилятор позволяет связывать атрибут const с переменными, значения кото­
рых не будут изменяться. Иначе говоря, он сообщает компилятору, что указан­
ные переменные имеют постоянное значение при выполнении программы. Если
попытаться присвоить значение переменной, объявленной с атрибутом const,
после инициализации, или попытаться выполнить ее наращивание или умень­
шение, компилятор выдаст предупреждающее сообщение. Ниже в переменной
pi используется атрибут const:
```
const double pi = 3.141592654;
```
Он указывает компилятору, что программа не будет изменять эту перемен­
ную. Естественно, значение такой переменной должно быть инициализирова­
но при ее определении.

Определение переменной с атрибутом const указывает читателю, что програм­
ма не будет изменять значение этой переменной.

### volatile
Это описатель, противоположный const. Он в явном виде указывает компиля­
тору, что соответствующая переменная будет изменять свое значение. Он вклю­
чен в язык Objective-C, чтобы компилятор не оптимизировал операторы, кото­
рые кажутся избыточными, и выполнял повторную проверку переменной, когда
ее значение, казалось бы, не изменяется. Типичный пример — порт ввода-вы­
вода, (I/O) (подробнее см. главу 13).

Предположим, что у вас имеется адрес выходного порта, хранящегося в про­
грамме в переменной с именем outPort. Записать в этот порт два символа, напри­
мер 0 и N, можно с помощью следующего кода.
```
*outPort = 'O’;
*outPort = ’N’;
```
В первой строке указывается, что символ 0 нужно сохранить по адресу па­
мяти, указанному переменной outPort. Во второй строке указывается, что сим­
вол N нужно сохранить по тому же адресу. Оптимизирующий компилятор мо­
жет заметить, что это две последовательные записи по одному адресу, и
поскольку outPort между ними не изменяется, может просто удалить первый опе­
ратор из программы. Чтобы этого не произошло, нужно объявить переменную
outPort с атрибутом volatile, например:
```
volatile char *outPort;
```

## 10.4. Перечислимые типы данных
Язык Objective-C позволяет задавать диапазон значений, которые могут быть
присвоены переменной. Определение перечислимого типа данных иницииру­
ется с помощью ключевого слова enum. Сразу после этого ключевого слова еле-
дует имя перечислимого типа данных и затем список идентификаторов (заклю­
ченных в фигурные скобки), которые определяют допустимые значения для
этого типа. В следующем операторе определяется тип данных flag:
```
enum flag { false, true };
```
Теоретически этому типу данных внутри программы могут быть присвоены
только значения true и false. К сожалению, компилятор Objective-C не выдает
предупреждающего сообщения, если это правило нарушается.

Чтобы объявить переменную типа enum flag, нужно снова использовать клю­
чевое слово enum, после которого следует имя перечислимого типа и список
переменных. Например, в следующем операторе определяются две перемен­
ные типа flag: endOfData и matchFound.
```
enum flag endOfData, matchFound;
```
Единственные значения, которые могут быть присвоены этим переменным —
true и false. Следующие операторы являются допустимыми.
```
endOfData = true;
if ( matchFound == false )
```
Если вам нужно, чтобы определенное целое значение было связано с иден­
тификатором перечисления, это целое значение можно присвоить идентифи­
катору, когда определяется тип данных. Идентификаторам перечисления, ко­
торые появляются затем в списке, будут присвоены последовательные целые
значения, начиная с указанного целого значения, увеличенного на I.

В следующем определении перечислимый тип данных direction определяется
со значениями up, down, left и right.
```
enum direction { up, down, left = 10, right}; (вверх, вниз, влево, вправо)
```
Компилятор присвоит значение 0 идентификатору up, поскольку он пред­
ставлен первым в списке, присвоит 1 идентификатору down, поскольку он явля­
ется следующим в списке, присвоит 10 идентификатору left, поскольку здесь явно
задано это значение, и присвоит 11 идентификатору right, поскольку это увели­
ченное на 1 значение предыдущего идентификатора в списке.

Идентификаторы перечисления могут иметь одинаковое значение. Напри­
мер, если в строке
```
enum boolean { no = 0, false = 0, yes = 1, true = 1 };
```
булевой переменной типа enum присваивается значение по или false, то ей при­
сваивается значение 0; если присваивается значение yes или true, то присваива­
ется значение 1.

Ниже приводится еще один пример определения перечислимого типа дан­
ных. В нем определяется тип enum month с допустимыми значениями, которые
могут быть присвоены переменной этого типа — названиями месяцев.
```
enum month { january = 1, february, march, april, may, june, july,
august, September, October, november, december};
```
Компилятор Objective-C интерпретирует идентификаторы перечисления как
целые константы. Переменной thisMonth будет присвоено значение 2 (а не а не
название месяца february), если программа содержит следующие две строки:
enum month thisMonth;
```
thisMonth = february;
```
В программе 10.3 используются перечислимые типы данных. В ней читает­
ся номер месяца, а затем выполняется оператор switch, чтобы определить, какой
месяц был введен. Напомним, что перечислимые значения интерпретируются
как целые константы, поэтому они являются допустимыми case-значениями.

Переменной days присваивается число дней в указанном месяце, и ее значение
выводится после выхода из оператора switch. Для февраля (February) введена
специальная проверка.
```
// вывод числа дней месяца
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
enum month { january = 1, february, march, april, may, june,
july, august, September, October, november,
d ecem b er};
enum month amonth;
int days;
NSLog (@"Enter month number:");
scant ("%i", &amonth);
switch (amonth) {
case january:
case march:
case may:
case july:
case august:
case October:
case december:
days = 31;
break;
case april:
case june:
case September:
case november:
days = 30;
break;
case february:
days = 28;
break;
default:
NSLog (@>"bad month number");
days = 0;
break;
}
if ( days != 0)
NSLog (@"Number of days is %i", days);
if ( amonth == february)
NSLog (@"...or 29 if it’s a leap year");
[pool drain];
return 0;
}
```
Вывод программы 10.3
```
Enter month number: (Введите номер месяца)
5
Number of days is 31 (Число дней = 31)
Вывод программы 10.3 (повторный запуск)
Enter month number:
2
Number of days is 28 ...or 29 if it's a leap year
(Число дней = 28 ... или 29, если это високосный год)
```
Вы можете явно присвоить целое значение переменной перечислимого типа
данных; это делается с помощью оператора приведения типа (type cast). Н а­
пример, если monthValue является переменной целого типа, имеющей значение
6, то следующее выражение является допустимым.
```
lastMonth = (enum month) (monthValue • 1);
```
Если вы не используете оператор приведения типа, компилятор, к сожале­
нию, нс реагирует на это.

При использовании программ с перечислимыми типами данных старайтесь
не полагаться на то, что перечислимые значения интерпретируются как целые
числа. Вместо этого их следует рассматривать как отдельные типы данных. Пе­
речислимый тип данных позволяет связывать символическое имя с целым чис-
лом. Если вам потребуется изменить значение этого числа, вам придется изме­
нить его только в том месте, где определено перечисление. Если вы делаете пред­
положения, основанные на фактическом значении перечислимого типа дан­
ных, то теряете преимущество перечисления.

При определении перечислимого типа данных имя типа данных может не
указываться, и переменные могут быть объявлены как конкретный перечисли­
мый тип данных, если этот тип определен.

Оператор
```
enum { east, west, south, north } direction;
```
определяет неименованный перечислимый тип данных со значениями east, west,
south и north (восток, запад, юг и север) и объявляет переменную (direction) этого
типа.

Определение перечислимого типа данных в блоке ограничивает область дей­
ствия этого определения данным блоком. С другой стороны, определение пе­
речислимого типа данных в начале программы (вне какого-либо блока) делает
определение глобальным для данного файла.

Определяя перечислимый тип данных, вы должны проследить, чтобы иден­
тификаторы перечисления были уникальными по отношению к именам других
переменных и идентификаторам перечисления, определенным в той же облас­
ти действия.

## 10.5. Оператор typedef
Objective-C позволяет назначать для типа данных альтернативное имя. Для это­
го используется оператор typedef. В следующей строке определяется имя Counter
(счетчик) как эквивалент типа данных Objective-C int.
```
typedef int Counter;
```
Затем можно объявить переменные с типом Counter, как в следующей строке.
```
Counter j, n;
```
Компилятор Objective-C будет интерпретировать это как объявление обыч­
ных целых переменных j и п. Определение j и п посредством typedef указывает
назначение переменных в программе. Объявление в традиционной форме с
типом int оставило бы их назначение непонятным.Ниже с помощью typedef оп­
ределяется тип с именем NumberObject для объектов типа Number.
```
typedef Number *NumberObject;
```
Переменные, которые объявляются затем с типом NumberObject, как в строке
NumberObject myValuel, myValue2, myResult;
будут интерпретироваться так, как если бы они были объявлены обычным об­
разом:
```
Number *myValue1, *myValue2, *myResult;
```
Чтобы определить имя нового типа с помощью typedef, нужно выполнить
следующую процедуру.

1. Написать такое же объявление, как при объявлении переменной нужного типа.
2. Там, где должно быть имя объявляемой переменной, поместить имя нового
типа.
3. Перед всем этим поставить слово typedef.

Для примера определим тип с именем Direction (Направление) как перечис­
лимый тип данных со значениями east, west, north и south (восток, запад, юг и
север), напишем определение этого перечислимого типа данных и подставим
имя Direction там, где обычно ставится имя переменной. Перед всем этим нужно
поместить ключевое слово typedef.
```
typedef enum { east, west, south, north } Direction;
После этого можно объявлять переменные с типом Direction:
Direction stepl, step2;
Foundation framework содерж ит следую щ ее определение typedef для
NSComparisonResult в одном из заголовочных файлов.
enum NSComparisonResult {
NSOrderedAscending = -1, NSOrderedSame, NSOrderedDescending
};
typedef NSInteger NSComparisonResult;
```
Некоторые методы в Foundation framework, которые выполняют сравнение
(comparison), возвращают значение этого типа. Например, метод сравнения
строк Foundation с именем compare: возвращает значение типа NSComparisonResult
после сравнения двух строк, которые являются объектами NSString. Этот метод
объявляется следующим образом.
```
-(NSComparisonResult) compare: (NSString *) string;
```
Чтобы проверить равенство двух объектов NSString с именами userName и
savedName, можно включить в программу следующую строку.
```
if ( [userName compare: savedName] == NSOrderedSame) {
// Имена совпадают
}
```
На самом деле здесь проверяется, равен ли нулю результат метода compare:

## 10.6. Преобразования типов данных
В главе 4 говорилось о том, что иногда при оценке выражений система неяв­
ным образом выполняет преобразования. Там рассматривался случай с типами
данных float и int. Операция, включающая типы float и int, выполнялась как опе­
рация с плавающей точкой, и элемент данных целого типа автоматически пре­
образовывался в элемент с плавающей точкой.

Там же было показано, как использовать оператор приведения типа, чтобы
явно определить преобразование. Пусть total и п являются целыми переменны­
ми. В строке
```
average = (float) total / n;
```
значение переменной total преобразуется в тип float до выполнения операции,
что гарантирует выполнение деления как операции с плавающей точкой.

### Правила преобразования
Компилятор Objective-C соблюдает строгие правила при оценке выражений,
состоящих из разл ичных типов данных.

Ниже описывается порядок, в котором выполняются преобразования при оценке двух операндов в выражении.
1. Если один из операндов имеет тип long double, второй операнд преобразуется в long double, результат имеет такой же тип.
2. Если один из операндов имеет тип double, второй операнд преобразуется в double, результат имеет такой же тип.
3. Если один из операндов имеет тип float, второй операнд преобразуется в тип float, результат имеет такой же тип.
4. Если один из операндов имеет тип Bool, char, short int или bit field1 или перечислимый тип данных, то он преобразуется в тип int.
5. Если один из операндов имеет тип long long int, второй операнд преобразуется в long long int, результат имеет такой же тип.
6. Если один из операндов имеет тип long int, второй операнд преобразуется в long int, результат имеет такой же тип.
7. Если мы дошли до этого шага, то оба операнда имеют тип int, результат имеет такой же тип.

Это упрощенная версия шагов преобразования операндов в выражении.
Правила усложняются, если включены операнды без знака (unsigned). Полный
список правил см. в Приложении В.

Из этой последовательности шагов понятно, что если достигнут шаг, где го­
ворится «результат имеет такой же тип», процесс преобразования закончен.

В качестве примера рассмотрим, в каком порядке выполняется оценка сле­
дующего выражения. В нем f имеет тип float, i — тип int, I — long int, s — переменная
типа short int.
```
f * i + I / s
```
1 В главе 13 кратко описывается тип bit field.

Рассмотрим сначала умножение f на i, то есть умножение переменной типа
float на переменную типа int. Из шага 3 известно, что поскольку f имеет тип float,
второй операнд (i) будет тоже преобразован в тип float, и такой же тип будет иметь
результат операции умножения.

Затем I делится на s, то есть выполняется деление переменной типа long int на
short int. Из шага 4 известно, что short int преобразуется в int. Переходим к шагу 6.
Поскольку один из операндов (1) имеет тип long int, второй операнд преобразу­
ется в long int, и результат будет иметь такой же тип. Таким образом, это деление
дает значение типа long int, причем дробная часть отбрасывается.

И, наконец, шаг 3 указывает, что поскольку один из операндов выражения
имеет тип float (как результат умножения f * i), второй операнд будет преобразо­
ван в тип float, и результат будет иметь такой же тип. Таким образом, после деле­
ния I на s результат операции будет преобразован в тип float и затем прибавлен к
произведению f на i. Поэтому конечный результат этого выражения будет иметь
тип float.

Вы всегда можете использовать оператор приведения типа для явных пре­
образований, управляя оценкой конкретного выражения.

Например, если вы не хотите, чтобы при делении I на s в предыдущем выра­
жении отбрасывалась дробная часть, то можете выполнить приведение одного
из этих операндов к типу float, чтобы выполнить деление с плавающей точкой:
```
f * i + (float) I / s
```
В этом выражении I будет преобразована в тип float до операции деления,
поскольку оператор приведения типа имеет более высокий приоритет, чем опе­
ратор деления. Поскольку один из операндов деления будет теперь иметь тип
float, другие операнды будут автоматически преобразованы в тип float, и такой
же тип будет иметь результат.

### Расширение для знака
Если переменная типа signed int или signed short преобразуется в тип int или тип
большего размера, то в результате преобразования слева тоже появляется опи­
сатель signed. Поэтому переменная типа short int, которая имеет значение -5, бу­
дет иметь значение -5 после преобразования в long int. Но если целая переменная
с описателем unsigned преобразуется в тип int или тип большего размера, то рас­
ширение для знака не происходит (как и можно было ожидать).

На некоторых машинах (например, с процессорами Intel, которые исполь­
зуются в современных семействах компьютеров Macintosh, или с процессора­
ми ARM, которые используются в iPhone и iTouch) символы интерпретируются
как значения со знаком. Это означает, что если символ (character) преобразует­
ся в целый тип, то происходит расширение для знака. Если используются сим­
волы из стандартного набора символов ASCII, это не создает проблем. Но если
значение символа не является частью этого стандартного набора символов, для
его знака может быть выполнено расширение, если символ преобразуется в це­
лый тип. Например, на компьютерах Мае символьная константа '\377’ преобра­
зуется в значение -1, потому что это значение является отрицательным, если
рассматривать его как 8-битное значение со знаком (signed).

Objective-C позволяет объявлять символьные переменны е без знака
(unsigned), что позволяет избежать этой потенциальной проблемы — перемен­
ная unsigned char не получает расширения для знака при преобразовании в целый
тип; ее значение всегда больше или равно нулю. Для обычного 8-битного сим­
вола символьная переменная со знаком имеет диапазон значений от -128 до +127
включительно. Символьная переменная без знака имеет диапазон значений от
О до 255 включительно.

Если ваши символьные переменные должны получать расширение для зна­
ка, вы можете объявить такие переменные с типом signed char. В главе 15 вы уз­
наете о многобайтных символах Unicode. Это предпочтительный способ ра­
боты со строками.

## Упражнения
1. Используя класс Rectangle из главы 8, добавьте метод-инициализатор в соответствии со следующим объявлением.
    ```
    -(Rectangle *) initWithWidth: (int) w: andHeight: (int) h;
    ```
2. С учетом того, что мы назвали метод, разработанный в упражнении 1, назначенным (designated) инициализатором для класса Rectangle, и основываясь на определениях классов Square и Rectangle из главы 8, добавьте методинициализатор в класс Square в соответствии со следующим объявлением.
    ```
    -(Square *) initWithSide: (int) side;
    ```
3. Добавьте счетчик (counter) к методу add: класса Fraction, чтобы вычислять количество вызовов этого метода. Каким образом вы можете считывать значение этого счетчика?
4. Используя typedef и перечислимые типы данных, определите тип с именем Day (День) с возможными значениями Sunday, Monday, Tuesday, Wednesday, Thursday, Friday и Saturday (Воскресенье, Понедельник, Вторник, Среда, Четверг, Пятница и Суббота).
5. Используя typedef, определите тип с именем FractionObj, который позволяет писать следующие операторы.
    ```
    FractionObj И = [[Fraction alloc] init],
    f2 = [[Fraction alloc] init];
    ```
6. Используя определения
    ```
    float f = 1.00;
    short int i = 100;
    long int I = 500L;
    double d = 15.00;
    ```
    и семь шагов, описанных выше для преобразования операндов в выражениях, определите тип и значение следующих выражений.
    ```
    f + i
    l/d
    i / l + f
    1 * i
    f / 2
    i / (d + f)
    1 / (i * 2.0)
    I + i / (double) I
    ```
7. Напишите программу, которая определяет, выполняется ли на вашей машине расширение для знака у переменных signed char.