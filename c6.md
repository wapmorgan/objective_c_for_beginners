# Глава 6. Принятие решений

В любом языке программирования имеется возможность принятия решений. В языке программирования Objective-C имеются несколько конструкций для принятия решений.
* Оператор if
* Оператор switch
* Условный оператор

## 6.1. Оператор if
В общем виде оператор if имеет следующий формат.
```
if ( выражение)
    программный оператор
```
Представим, что нам нужно преобразовать утверждение «Если нет дождя, я пойду купаться» в операторы языка Objective-C. Используя показанный выше формат, это можно «записать» следующим образом.
```
if ( нет дождя )
    я пойду купаться
```
Оператор if используется, чтобы выполнить программный оператор в зависимости от указанных условий (или операторы, если они заключены в фигурные скобки). Аналогичным образом, в программном операторе
```
if ( count > MAXIMUMSONGS )
[playlist maxExceeded];
```
сообщение maxExceeded отправляется playlist (список воспроизведения), только если значение переменной count больше значения MAXIMUM SONGS, иначе этот оператор игнорируется.

Рассмотрим пример. Предположим, что вам нужно написать программу, которая принимает целое значение, введенное с клавиатуры, и затем выводит абсолютное значение этого целого числа. Проще всего вычислить абсолютное значение числа — взять его с противоположным знаком, если оно меньше нуля. Фраза «если оно меньше нуля» означает, что программа должна принять решение. Для этого можно использовать оператор if, как показано в программе 6.1.
```
// Вычисление абсолютного значения целого числа
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    int number;

    NSLog (@"Type in your number: ");
    scanf("%i", &number);

    if ( number < 0 )
    number = -number;

    NSLog (@"The absolute value is %i", number);

    [pool drain];
    return 0;
}
```
Вывод программы 6.1
```
Type in your number: (Введите свое число)
-100
The absolute value is 100 (Абсолютное значение равно 100)
```
Вывод программы 6.1 (повторный запуск)
```
Type in your number:
2000
The absolute value is 2000
```
Эта программа запускалась два раза, чтобы проверить правильность ее работы. Мы проверили оба возможных результата принятия решений.

После вывода сообщения для пользователя и сохранения введенного целого значения в переменной number программа проверяет, не является ли значение number отрицательным. Если да, то выполняется следующий программный оператор, который изменяет знак number на противоположный. Если значение number не меньше нуля, этот оператор автоматически пропускается. (В этом случае не нужно изменять знак на противоположный.) Затем выполняется вывод значения number и завершается выполнение программы.

Рассмотрим еще одну программу с оператором if. Мы добавим в класс Fraction еще метод convertToNum. Этот метод будет представлять значение дроби в виде вещественного числа — выполнять деление числителя (numerator) на знаменатель (denominator). Результат будет возвращаться как значение двойной точности (double). Так, для дроби 1/2 нужно возвращать значение 0.5.

Для такого метода можно использовать, например, следующее объявление
```
-(double) convertToNum;
```
Его определение можно записать в следующем виде:
```
-(double) convertToNum
{
    return numerator / denominator;
}
```
Хорошо, но недостаточно. При таком определении этот метод имеет две серьезные проблемы. Первая относится к работе с арифметическими преобразованиями. Напомним, что numerator и denominator — это целые переменные экземпляра. А что происходит при делении целых значений? Оно выполняется как целое деление! Если нужно преобразовать дробь 1/2, то представленный код даст значение нуль! Это легко исправить с помощью оператора приведения типа, преобразующего один или оба операнда в значение с плавающей точкой до операции деления:
```
(double) numerator / denominator
```
Поскольку этот оператор имеет относительно высокий приоритет, значение numerator преобразуется в тип double до выполнения деления. Вам не обязательно преобразовывать denominator, достаточно сделать это для одного из операндов.

Вторая проблема заключается в том, что нужно проверять деление на нуль (вы должны всегда выполнять эту проверку). Ниже показана модифицированная версия метода convertToNum.
```
-(double) convertToNum
{
    if (denominator != 0)
        return (double) numerator / denominator;
    else
        return 0.0;
}
```
Мы решили возвращать значение 0.0, если знаменатель дроби равен нулю. Можно использовать и другие варианты (например, вывод сообщения об ошибке, создание исключительного состояния и т.д.).

Введем этот метод в программе 6.2.
```
#import <Foundation/Foundation.h>

@interface Fraction: NSObject
{
    int numerator;
    int denominator;
}

-(void) print;
-(void) setNumerator: (int) n;
-(void) setDenominator: (int) d;
-(int) numerator;
-(int) denominator;
-(double) convertToNum;
@end

@implementation Fraction
-(void) print
{
    NSLog (@" %i/%i", numerator, denominator);
}

-(void) setNumerator: (int) n
{
    numerator = n;
}

-(void) setDenominator: (int) d
{
    denominator = d;
}

-(int) numerator
{
    return numerator;
}

-(int) denominator
{
    return denominator;
}

-(double) convertToNum
{
    if (denominator != 0)
        return (double) numerator / denominator;
    else
        return 0.0;
}
@end

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    Fraction *aFraction = [[Fraction alloc] init];
    Fraction *bFraction = [[Fraction alloc] init];

    [aFraction setNumerator: 1]; // 1-я дробь 1/4
    [aFraction setDenominator: 4];

    [aFraction print];
    NSLog (@" =");
    NSLog (@"%g", [aFraction convertToNum]);

    [bFraction print]; // значение не было присвоено
    NSLog (@" =");
    NSLog (@"%g", [bFraction convertToNum]);
    [aFraction release];
    [bFraction release];

    [pool drain];
    return 0;
}
```
Вывод программы 6.2
```
1/4
0.25
0/0
=
0
```
После присваивания aFraction значения 1/4 используется метод convertToNum, чтобы преобразовать эту дробь в десятичное значение. Затем это значение выводится как 0.25.

Во втором случае значение bFraction не задано явным образом, поэтому его числителю и знаменателю присваивается значение 0, что происходит по умолчанию для переменных экземпляра. Это объясняет результат метода print, а оператор if в методе convertToNum возвращает значение 0.

### Конструкция if-else
Если нужно сказать, является ли число четным или нечетным, вы, скорее всего, определите это по последней цифре числа. Если эта цифра равна 0, 2,4,6 или 8, значит, число является четным.

На компьютере это можно сделать проще: достаточно проверить, делится ли это число на 2 без остатка. Если да, то число является четным, иначе оно является нечетным.

Вы уже видели, как использовать оператор взятия по модулю (%) для вычисления остатка отделения одного целого числа на другое. Его удобно использовать, чтобы определить, делится ли число на 2 без остатка. Если остаток от деления на 2 равен 0, значит, это четное число, если нет — нечетное.

Напишем программу, которая определяет, является ли целое значение, которое вводит пользователь, четным или нечетным, и выводит соответствующее значение на терминал (см. программу 6.3).
```
// Программа, определяющая, является ли число четным или нечетным
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    int number_to_test, remainder;

    NSLog (@"Enter your number to be tested:");
    scanf ("%i", &number_to_test);

    remainder = number_to_test % 2;

    if ( remainder == 0 )
        NSLog (@"The number is even.");
    if ( remainder != 0 )
        NSLog (@"The number is odd.");
    [pool drain];
    return 0;
}
```
Вывод программы 6.3
```
Enter your number to be tested: (Введите ваше число для проверки)
2455
The number is odd. (Число является нечетным)
```
Вывод программы 6.3 (повторный запуск)
```
Enter your number to be tested:
1210
The number is even. (Число является четным)
```
После ввода числа вычисляется остаток отделения на 2. Первый оператор if проверяет, равно ли нулю значение этого остатка. Если да, то выводится сообщение «The number is even.» (Число является четным).

Второй оператор if проверяет значение этого остатка на неравенство нулю. Если да, то выводится сообщение, что число является нечетным.

Если выполняется первый оператор if, то второй оператор не должен выполняться, и наоборот. При написании программ концепция «иначе» («else») требуется настолько часто, что почти во всех современных языках программирования введена специальная конструкция для этой ситуации. В Objective-C это конструкция if-else, которая имеет следующий формат.
```
if (выражение)
    программный оператор 1
else
    программный оператор 2
```

На самом деле if-else является просто расширением общего формата оператора if. Если результатом оценки выражения является значение TRUE, то выполняется программный оператор /; иначе выполняется программный оператор 2. Во всех случаях выполняется программный оператор 1 или программный оператор 2, но не оба оператора.

Оператор if-else можно вставить в предыдущую программу, заменив два оператора if на один оператор if-else. Эта новая конструкция в некоторой степени упрощает программу и делает ее более удобной для чтения.
```
// Программа, определяющая, является ли число четным или нечетным (Версия 2)
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    int number_to_test, remainder;

    NSLog (@"Enter your number to be tested:");
    scanf ("%i", &number_to_test);

    remainder = number_to_test % 2;

    if ( remainder == 0 )
        NSLog (@"The number is even.");
    else
        NSLog (@"The number is odd.");
    [pool drain];
    return 0;
}
```
Вывод программы 6.4
```
Enter your number to be tested: (Введите ваше число для проверки)
1234
The number is even. (Число является нечетным)
```
Вывод программы 6.4 (повторный запуск)
```
Enter your number to be tested:
6551
The number is odd. (Число является четным)
```
He забывайте, что двойной знак равенства (==) - это проверка на равенство, а одинарный знак равенства — это оператор присваивания. Если случайно использовать оператор присваивания внутри оператора if, то может возникнуть множество проблем.

### Составные операции сравнения
До сих пор в операторах if использовались простые операции сравнения между двумя числами. В программе 6.1 сравнивалось значение числа с нулем, а в программе 6.2 выполнялось сравнение с нулем знаменателя дроби. Иногда необ­
ходимы более сложные проверки. Предположим, что нужно вычислить коли­
чество экзаменационных оценок в диапазоне от 70 по 79. В данном случае нуж­
но сравнить значение оценки не с одним пределом, а с двумя (70 и 79), чтобы
проверить, попадает ли она в указанный диапазон.
В Objective-C имеется механизм для составных операторов сравнения этого
типа. Составная операция сравнения (compound relational test) — это несколько
операций сравнения, объединенных логическим оператором AND или 0R. Эти
операторы представлены парой символов && или || (два вертикальных штриха).
Н апример, следующий оператор увеличивает значение переменной
grades_70_to_79 (оценки от 70 по 79), только если значение grade (оценка) больше
или равно 70 и меньше или равно 79).
if ( grade >= 70 && grade <= 79 )
++grades_70_to_79;
А следующий оператор вызывает выполнение оператора NSLog, если index
меньше 0 или больше 99.
if ( index < 0 || index > 99 )
NSLog (@"Error - index out of range"); (Ошибка - индекс вне диапазона)
Составные операторы можно использовать в Objective-C для формирования
очень сложных выражений. Не злоупотребляйте этим. Более простые выраже­
ния всегда проще читать и отлаживать.При формировании составных выраже­
ний сравнения можно неограниченно использовать круглые скобки, чтобы по­
высить удобство чтения выражений и избежать осложнений из-за ошибочных
предположений о старшинстве операторов в выражении. (Оператор && имеет
более низкий приоритет, чем любой арифметический оператор или оператор
отношения, но более высокий приоритет, чем оператор ||.) Пробелы также по­
вышают удобочитаемость выражения. Дополнительные пробелы вокруг опе­
раторов && и || визуально отделяют эти операторы от выражений, которые они
связывают.
Чтобы показать использование составных операций сравнения на конкрет­
ном примере, мы напишем программу, которая проверяет, является ли опреде­
ленный год високосным, если он делится на 4 без остатка. Год, который делит­
ся на 100, не является високосным годом, если он не делится также на 400.
Необходимо продумать, как проверять эти условия. Во-первых, можно со­
считать остатки (remainder) отделения года на 4, 100 и 400 и присвоить эти зна­
чения соответствующим переменным, например, rem_4, remJOO и rem_400. Затем
можно проверить эти переменные, чтобы выяснить, отвечают ли эти остатки
критериям високосного года.
Можно сказать, что год является високосным, если он делится без остатка
на 4 и не делится на 100, либо он делится без остатка на 400. На всякий случай
убедитесь, что это определение эквивалентно предыдущему определению. Те­
перь, когда мы переформулировали определение, его реализация в виде про­
граммного оператора становится достаточно простой.
if ( (rem_4 == 0 && remJOO != 0) || rem_400 == 0 )
NSLog (@"lt’s a leap year."); ("Это високосный год")
Круглые скобки вокруг следующего подвыражения не обязательны.
rem_4 == 0 && remJOO != О
Оно будет оцениваться в таком порядке в любом случае, поскольку опера­
тор && имеет более высокий приоритет, чем ||.
В этом примере подходит и следующая проверка.
if ( rem_4 == 0 && ( remJOO != О || remJOO == 0 ))
Можно добавить перед этим оператором if несколько операторов объявле­
ния переменных и ввод пользователем значения года с терминала. Это програм­
ма 6.5, которая определяет, является ли год високосным.
Программа 6.5
// Эта программа определяет, является ли год високосным
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int year, rem_4, remJOO, remJOO;
NSLog (@"Enter the year to be tested:");
scant ("%i", &year);
rem J = year % 4;
remJOO = year % 100;
remJOO = year % 400;
if ( (rem 4 == 0 && remJOO != 0) || remJOO == 0 )
NSLog ((ant’s a leap year.");
else
NSLog (@"Nope, it’s not a leap year.");
[pool drain];
return 0;
}
Вывод программы 6.5
Enter the year to be tested: (Введите год для проверки)
1955
Nope, it’s not a leap year. (Нет, это не високосный год)
Вывод программы 6.5 (повторный запуск)
Enter the year to be tested:
2000
It’s a leap year. (Это високосный год)
Вывод программы 6.5 (повторный запуск)
Enter the year to be tested:
1800
Nope, it’s not a leap year. (Нет, это не високосный год)
В приведенных примерах вводится 1955-й год, который не является висо­
косным, поскольку он не делится нацело на 4, 2000-й год, который является
високосным, поскольку он делится нацело на 400, и 1800-й год, который не
является високосным, поскольку он делится нацело на 100, но не на 400. В ка­
честве последнего варианта следует проверить год, который делится нацело на
4, но не на 100. Выполните эту проверку самостоятельно.
Objective-C дает программисту очень высокий уровень гибкости при фор­
мировании выражений. Например, в приведенной выше программе вместо
вычисления промежуточных результатов rem_4, remJOO и rem_400 можно было бы
сделать все непосредственно в операторе if:
if (( year % 4 == 0 && year % 100 != О ) || year % 400 == 0 )
Использование пробелов для разделения отдельных операторов делает это
выражение более удобным для чтения. Если игнорировать эти возможности и
удалить необязательный набор круглых скобок, то получится следующее выра­
жение:
if(year%4==0&&year%100!=0)||year%400==0)
Это выражение действует точно так же, как предыдущее выражение, однако
дополнительные пробелы очень упрощают восприятие составных выражений.

### Вложенные операторы if
При рассмотрении общего формата оператора if мы указывали, что если резуль­
татом оценки выражения в круглых скобках является значение TRUE, то выпол­
няется следующий оператор. Этим программным оператором может быть еще
один оператор if, как в следующих строках.
if ( [chessGame isOver] == NO ) ([игра в шахматы окончена] == НЕТ)
if ( [chessGame whoseTurn] == YOU )([... чей ход] == ВАШ)
[chessGame yourMove]; ([... ваш ход])
Если значение, возвращаемое после отправки сообщения isOver объекту
chessGame, равно N0, то выполняется следующий оператор; в свою очередь, этот
оператор является еще одним оператором if. Этот оператор if сравнивает значе­
ние, возвращаемое методом whoseTurn, со значением YOU. Если эти два значения
равны, то объекту chessGame отправляется сообщение yourMove. Таким образом,
сообщение yourMove отправляется только в том случае, если игра не окончена, и
это ваш ход. Эти операторы можно было бы записать с помощью составной
операции сравнения:
if ( [chessGame isOver] == N0 && [chessGame whoseTurn] == YOU )
[chessGame yourMove];
Обычно с вложенными операторами if используют предложение else, как
показано ниже.
if ( [chessGame isOver] == N0 ) ([игра в шахматы окончена] == НЕТ)
if ( [chessGame whoseTurn] == YOU )([... чей ход] == ВАШ)
[chessGame yourMove]; ([... ваш ход])
else
[chessGame my Move]; ([... мой ход])
Сначала все выполняется, как и раньше, но если игра не окончена и ход не
ваш, то выполняется предложение else. В результате сообщение myMove отправ­
ляется объекту chessGame. Если игра окончена, то пропускается весь следующий
оператор if вместе с присоединенным к нему предложением else.
Предложение else связано с оператором if, который проверяет значение, воз­
вращаемое методом whoseTurn, а не с оператором if, который проверяет, оконче­
на ли игра (chessGame isOver). Общее правило состоит в том, что предложение
else всегда связывается с последним оператором if, не содержащим else.
Можно продвинуться еще на один шаг и добавить предложение else к внеш­
нему оператору if. Это предложение else выполняется, если игра окончена.
if ( [chessGame isOver] == NO ) ([игра в шахматы окончена] == НЕТ)
if ( [chessGame whoseTurn] == YOU )([... чей ход] == ВАШ)
[chessGame yourMove]; ([... ваш ход])
else
[chessGame myMove]; ([...мой ход])
else
[chessGame finish]; (... конец)
Конечно, система может интерпретировать этот оператор и по-другому. На­
пример, если в предыдущем примере удалить первое предложение else, то опера­
тор не будет интерпретироваться в соответствии с показанными отступами.
if ( [chessGame isOver] == NO )
if ( [chessGame whoseTurn] == YOU )
[chessGame yourMove];
else
[chessGame finish];
Вместо этого оператор будет интерпретироваться следующим образом:
if ( [chessGame isOver] == NO )
if ( [chessGame whoseTurn] == YOU )
[chessGame yourMove];
else
[chessGame finish];
Предложение else связывается с последним оператором if, не включающим else.
Можно использовать фигурные скобки, чтобы связать else с внешним if, а не с
внутренним. Фигурные скобки замыкают оператор if, который находится внутри
них. Нужная последовательность задается с помощью следующего оператора.
if ( [chessGame isOver] == NO ) {
if ( [chessGame whoseTurn] == YOU )
[chessGame yourMove];
}
else
[chessGame finish];

### Конструкция else if
Вы уже видели, как действует оператор else при проверке двух возможных усло­
вий. Однако решения, которые приходится реализовать в программировании,
не всегда ограничиваются выбором между двумя вариантами. Рассмотрим про­
грамму, которая выводит -1, если пользователь вводит отрицательное число; О,
если число равно нулю; и 1, если число больше нуля. (Это реализация функции
sign.) Очевидно, что в этом случае нужны три проверки: для отрицательных чи­
сел, чисел, равных нулю, и положительных чисел. Простая конструкция if-else в
данном случае не подходит. Конечно, мы могли бы прибегнуть здесь к трем от­
дельным операторам if, но это решение не всегда можно реализовать, особенно
если проверки не являются взаимоисключающими.
Чтобы справиться с этой ситуацией, можно добавить оператор if к предло­
жению else. Мы уже говорили, что после предложения else может следовать лю­
бой допустимый программный оператор Objective-C, так почему не использо­
вать еще один if?
if (выражение 1 )
программный оператор 1
else
if (выражение 2)
программный оператор 2
else
программный оператор 3
В результате оператор if расширяется — вместо логического решения с двумя
значениями мы получаем логическое решение с тремя значениями. Вы можете
продолжить добавление операторов if к предложениям else в том же стиле, что­
бы получить логическое решение с п значениями.
Эта конструкция так часто используется, что обычно ее называют конст­
рукцией else if и форматируют так.
if (выражение 1 )
программный оператор 1
else if (выражение 2 )
программный оператор 2
else
программный оператор 3
Это способ делает чтение оператора более удобным. В следующей програм­
ме показано использование конструкции else if с реализацией описанной выше
функции sign.
Программа 6.6
// Реализация функции sign
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int number, sign;
NSLog (@"Please type in a number:");
scant ("%i", &number);
if ( number < 0 )
sign = -1;
else if ( number == 0 )
sign = 0;
else // Положительное число
sign = 1;
NSLog (@"Sign = %i", sign);
[pool drain];
return 0;
}
Вывод программы 6.6
Please type in a number: (Введите число)
1121
Sign = 1
Вывод программы 6.6 (повторный запуск)
Please type in a number:
-158
Sign = -1
Вывод программы 6.6 (повторный запуск)
Please type in a number:
О
Sign = О
Если введенное число меньше нуля, переменной sign присваивается значе­
ние -1; если число равно нулю, sign присваивается значение 0; в противном слу­
чае число больше нуля, поэтому sign присваивается значение 1.
В следующей программе символ, введенный с терминала, анализируется и
классифицируется как алфавитный символ (a-z или A-Z), как цифровой символ
(0-9) или как специальный символ (все остальные символы). Для чтения одно­
го символа с терминала при вызове scant используются символы форматирова­
ния %с.
Программа 6.7
// Эта программа классифицирует символ,
// введенный с клавиатуры
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
char c;
NSLog (@"Enter a single character:");
scant ("%c", &c);
it ( (c >= ’a' && c <= 'z') || (c >= ’A' && c <= 7'))
NSLog (@"lt’s an alphabetic character.");
else it ( c >= ’O’ && c <= ’9’ )
NSLog ((gilt's a digit.");
else
NSLog (@"lt’s a special character.");
[pool drain];
return 0;
}
Вывод программы 6.7
Enter a single character: (Введите один символ)
&
It’s a special character. (Это специальный символ)
Вывод программы 6.7 (повторный запуск)
Enter a single character:
8
It’s a digit. (Это цифра)
Вывод программы 6.7 (повторный запуск)
Enter a single character:
В
It’s an alphabetic character. (Это алфавитный символ)
В первой проверке после чтения символа мы определяем, является ли этот
символ алфавитным (в переменной с типа char). Сначала проверяется, попадает
ли этот символ в диапазон строчных букв:
( с >= 'а' && с <= 'z ')
Это выражение имеет значение TRUE, если с находится в диапазоне симво­
лов от ’а’ до У (с — строчная латинская буква). Вторая проверка выполняется с
помощью следующего выражения:
( с >= ’А’ && с <= “Z" )
Это выражение имеет значение TRUE, если с находится в диапазоне симво­
лов от 'А' до 'Т (с — прописная латинская буква). Эти проверки подходят для
символов в кодировке ASCII.
Если переменная с содержит алфавитный символ, проверка проходит ус­
пешно и выводится сообщение «It’s an alphabetic character» (Это алфавитный
символ). В противном случае выполняется предложение else if. Оно определяет,
является ли данный символ цифрой. Отметим, что выполняется сравнение с
символами от '0' до ’9’, а нес цифрами от 0 до 9. Дело в том, что с терминала чита­
ется символ, а запись символов от '0' до '9' в компьютере отличается от чисел
0-9. В кодировке ASCII символ ’0' представляется во внутренней записи числом
48, символ Т — числом 49, и т.д.
Если с — символ цифры, то выводится фраза «It’s a digit» (Это цифра). В про­
тивном случае (если с не является алфавитным символом или символом циф­
ры) выполняется последнее предложение else, и на терминале выводится фраза
«It’s a special character» (Это специальный символ). Затем выполнение програм­
мы завершается.
Хотя в данном случае scant используется для чтения только одного символа,
вы все равно должны нажать клавишу Enter после ввода символа, чтобы ре­
зультат ввода был передан в программу. Обычно при чтении данных с термина­
ла программа «не видит» введенных данных, пока не нажата клавиша Enter.
В следующем примере напишем программу, которая позволяет ввести про­
стое выражение в следующей форме:
число оператор число
Программа выполнит оценку выражения и выведет результаты на терми­
нал. Операторы, которые нужно распознавать, — это обычные оператор сложе­
ния, вычитания, умножения и деления. Мы будем использовать класс Calculator
из программы 4.6 главы 4. Каждое выражение будет передаваться этому каль­
кулятору для вычислений.
В следующей программе используется довольно большой оператор if с не­
сколькими предложениями else if, определяющими, какая операция должна быть
выполнена.
Примечание. Чтобы избежать проблем с внутреннм представлением, лучше ис­
пользовать процедуры из стандартной библиотеки islower и isupper. Для этого
включите в программу строку #import <ctype.h>.
Программа 6.8
// Программа вычисления простых выражений в форме
// число оператор число
// Реализация класса Calculator
#import <Foundation/Foundation.h>
@interface Calculator: NSObject
{
double accumulator;
}
// методы для сумматора (accumulator)
-(void) setAccumulator: (double) value;
-(void) clear;
-(double) accumulator;
// арифметические методы
-(void) add: (double) value;
-(void) subtract: (double) value;
-(void) multiply: (double) value;
-(void) divide: (double) value;
@end
@implementation Calculator
-(void) setAccumulator: (double) value
{
accumulator = value;
}
-(void) clear
{
accumulator = 0;
}
-(double) accumulator
{
return accumulator;
}
-(void) add: (double) value
{
accumulator += value;
}
-(void) subtract: (double) value
{
accumulator -= value;
}
-(void) multiply: (double) value
{
accumulator *= value;
}
-(void) divide: (double) value
{
accumulator /= value;
}
@end
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
double value 1, value2;
char operator;
Calculator *deskCalc = [[Calculator alloc] init];
NSLog (@"Type in your expression.");
scant ("%lf %c %lf", &value1, &operator, &value2);
[deskCalc setAccumulator: valuel];
if ( operator == )
[deskCalc add: value2];
else if ( operator == )
[deskCalc subtract: value2];
else if ( operator =='*')
[deskCalc multiply: value2];
else if ( operator == '/')
[deskCalc divide: value2];
NSLog (@"%.2f", [deskCalc accumulator]);
[deskCalc release];
[pool drain];
return 0;
}
Вывод программы 6.8
Type in your expression. (Введите ваше выражение)
123.5 + 59.3
182.80
Вывод программы 6.8 (повторный запуск)
Type in your expression.
198.7/26
7.64
Вывод программы 6.8 (повторный запуск)
Type in your expression.
89.3 * 2.5
223.25
При обращении к scant указывается, что должны быть считаны три значения
в переменные valuel, operator и value2. Значение типа double можно прочитать с
помощью символов формата %lf. Этот формат считывает значения в перемен­
ную valuel, которая является первым операндом выражения.
Затем считывается оператор. Поскольку оператор представляется символом
или 7 ), а не числом, он читается в символьную переменную operator.
Символы формата %с указывают, что нужно прочитать с терминала следующий
символ. Пробелы внутри строки формата указывают, что при вводе допускает­
ся любое число пробелов. Это позволяет при вводе значений отделять операн­
ды от оператора.
После считывания двух значений и оператора программа сохраняет первое
значение в сумматоре (accumulator) калькулятора. Затем значение operator срав­
нивается с четырьмя возможными операторами. Если найдено допустимое со-
ответствие, калькулятору передается сообщение для выполнения операции. В
последней строке NSLog значение accumulator считывается для вывода. После этого
выполнение программы завершается.
Здесь необходимо сказать несколько слов о законченности программы. Хотя
приведенная программа выполняет поставленную задачу, ее нельзя назвать за­
конченной, поскольку в ней не учитываются ошибки пользователя. Например,
что произойдет, если пользователь ошибся и ввел ? в качестве имени операто­
ра? Программа просто пройдет через оператор if, и на терминале не появится
никаких ошибок, уведомляющих пользователя, что он ввел недопустимое вы­
ражение.
Еще один неучтенный случай — это ввод пользователем нулевого значения
делителя в операции деления. Программа должна проверять этот случай. Оп­
ределение ситуаций, при которых возможен отказ программы или получение
нежелательных результатов, и принятие предупредительных мер — обязатель­
ная часть разработки надежных программ.
Программа 6.8А является модифицированной версией программы 6.8. В ней
учитываются деление на нуль и ввод неизвестного оператора.
Программа 6.8А
// Программа вычисления простых выражений в форме
// число оператор число
#import <Foundation/Foundation.h>
// Здесь нужно вставить секции interface и implementation
// для класса Calculator
int main (int argc, char *argv[])
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
double value 1, value2;
char operator;
Calculator *deskCalc = [[Calculator alloc] init];
NSLog (@"Type in your expression.");
scant ("%lf %c %lf", &value1, &operator, &value2);
[deskCalc setAccumulator: valuel];
if ( operator =='+')
[deskCalc add: value2];
else if ( operator =='-')
[deskCalc subtract: value2];
else if ( operator =='*’ )
[deskCalc multiply: value2];
else if ( operator == ' / ' )
if ( value2 == 0 )
NSLog (@"Division by zero.");
else
[deskCalc divide: value2];
else
NSLog (@"Unknown operator.");
NSLog (@"%.2f", [deskCalc accumulator]);
[deskCalc release];
[pool drain];
return 0;
}
Вывод программы 6.8A
Type in your expression. (Введите ваше выражение)
123.5 + 59.3
182.80
Вывод программы 6.8А (повторный запуск)
Type in your expression.
198.7/0
Division by zero. (Деление на нуль)
198.7
Вывод программы 6.8А (повторный запуск)
Type in your expression.
125 $28
Unknown operator. (Неизвестный оператор)
125
Если введен оператор деления (слэш), то проверяется, не равно ли нулю зна­
чения value2. Если равно, выводится соответствующее сообщение; если нет - вы­
полняется операция деления и выводятся результаты. Обратите внимание, как
в данном случае вложены оператор if и предложения else.
Предложение else в конце программы позволяет «уловить» любые непредус­
мотренные случаи. Поэтому любое значение переменной operator, которое не
совпадает с одним из четырех символов вычислений, приводит к выполнению
предложения else, и на терминал выводится сообщение «Unknown operator»
(Неизвестный оператор).
Более удобный способ обработки ситуации деления на ноль — это выполне­
ние проверки в методе, который работает с операцией деления. Метод divide:
можно модифипировать следующим образом.
-(void) divide: (double) value
{
if (value != 0.0)
accumulator /= value;
else {
NSLog ((@"Division by zero.");
accumulator = 99999999.;
)
}
Для ненулевого значения выполняется деление; для нулевого — выводится
сообщ ен и е, и переменной accumulator п ри сваи вается значение 99999999. Это про­
извольно выбранное значение; можно было присвоить значение 0 или задать
специальную переменную, указывающую состояние ошибки. Лучше включать
обработку особых ситуаций в сам метод, чем полагаться на предусмотритель­
ность программиста при использовании метода.

### Оператор switch
Цепочки if-else гак часто используются при разработке программ, что в язык
Objcctivc-C включен специальный оператор для выполнения именно этой фун­
кции. Это оператор switch. Он имеет следующий формат.
switch (выражение)
{
case valuel:
программный оператор
программный оператор
break;
case value2.
программный оператор
программный оператор
break;
case valuen:
программный оператор
программный оператор
break;
default:
программный оператор
программный оператор
break;
}
Выражение, указанное в круглых скобках, последовательно сравнивается со
значениями valuel, value2, ..., valuer), которые могут быть простыми константами
или константными выражениями. Если найден вариант (case), при котором зна­
чение равно значению выражения, выполняются программные операторы, сле­
дующие после этого предложения case. Если включено несколько таких опера­
торов, то их можно не заключать в фигурные скобки.
Оператор break вызывает прекращение выполнения оператора switch. Не за­
бывайте включать оператор break в конце каждого предложения case, иначе вы­
полнение программы продолжится в следующем предложении case. Иногда это
делают преднамеренно; в таких случаях обязательно включите комментарии,
чтобы предупредить других о ваших целях.
Особый (необязательный) вариант с именем default выполняется в том слу­
чае, если значение выражения не соответствует ни одному из значений, указан­
ных в предложениях case. Это эквивалентно предложению else, которое исполь­
зовалось в предыдущем примере для «улавливания» любых неуказанных
вариантов. На самом деле общую форму оператора switch можно представить в
эквивалентной форме оператора if.
if (выражение == value 1)
{
программный оператор
программный оператор
}
else if (выражение == value2)
{
программный оператор
программный оператор
}
else if (выражение == valuen)
{
программный оператор
программный оператор
>
else
{
программный оператор
программный оператор
}
Мы можем теперь преобразовать большой оператор if из программы 6.8А в
эквивалентный оператор switch. Это показано в программе 6.9.
Программа 6.9
// Программа вычисления простых выражений в форме
// число оператор число
#import <Foundation/Foundation.h>
// Здесь нужно вставить секции interface и implementation
// для класса Calculator
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
double value 1, value2;
char operator;
Calculator *deskCalc = [[Calculator alloc] init];
NSLog (@"Type in your expression.");
scant ("%lf %c %lf, &value1, &operator, &value2);
[deskCalc setAccumulator: valuel];
switch ( operator) {
case
[deskCalc add: value2];
break;
case
[deskCalc subtract: value2];
break;
case
[deskCalc multiply: value2];
break;
case 7 :
[deskCalc divide: value2];
break;
default:
NSLog (@"Unknown operator.");
break;
}
NSLog (@"%.2Г, [deskCalc accumulator]);
[deskCalc release];
[pool drain];
return 0;
}
Вывод программы 6.9
Type in your expression. (Введите ваше выражение)
178.99 - 326.8
-147.81
После считывания выражения значение переменной operator сравнивается
со значениями каждого варианта case. Если найдено соответствие, то выполня­
ются операторы внутри этого варианта case. Затем оператор break выполняет
выход из оператора switch, после чего завершается выполнение программы. Если
ни один из вариантов не соответствует значению переменной operator, то исполь­
зуется вариант по умолчанию default, в котором выводится сообщение «Unknown
operator» (Неизвестный оператор).
Оператор break для варианта default не является необходимым, т.к. после него
в данном операторе switch не выполняется никаких операторов. Однако практи­
ка надежного программирования требует вставки break в конце каждого вари­
анта.
При написании оператора switch помните, что нельзя указывать одинаковые
значения для двух разных предложений case. Однако один набор программных
операторов можно связывать с несколькими case-значениями. Для этого нуж­
но задать список из нескольких case-значений (с ключевым словом case перед
каждым значением и двоеточием после значения) и общий набор программ­
ных операторов. Например, в следующем операторе switch выполняется метод
multiply:, если значение operator указано символом «звездочка» или строчной бук­
вой х.
switch ( operator)
case
case 'x':
[deskCalc multiply: value2];
break;
}

## 6.3. Булевы переменные
Почти все, кто учится программировать, довольно скоро сталкиваются с зада­
чей написания программы, которая создает таблицу простых чисел. Напомним,
что положительное целое число р является простым числом, если оно не делит­
ся нацело ни на одно из других целых чисел, кроме 1 и самого себя. Первым
простым числом является 2. Следующее простое число — 3, так как оно делится
нацело только на 1 и 3; 4 не является простым числом, так как оно делится на­
цело на 2.
Создать таблицу простых чисел можно несколькими способами. Например,
чтобы создать таблицу простых чисел, не превышающих 50, достаточно напря­
мую проверить делимость каждого целого числа р на все целые числа от 2 до р-1.
Если р делится без остатка на одно из этих чисел, значит, р не является простым
числом, иначе оно является простым.
В программе 6.10 создается список простых чисел, не превышающих 50.
Программа 6.10
// Программа создания таблицы простых чисел (prime number)
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int p, d, isPrime;
for ( p = 2; p <= 50; ++p ) {
isPrime = 1;
for ( d = 2; d < p; ++d )
if ( p % d == 0 )
isPrime = 0;
if ( isPrime != 0 )
NSLog (@"%i", p);
[pool drain];
return 0;
}
Вывод программы 6.10
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
Внешний оператор for задает цикл по целым значениям от 2 до 50. Перемен­
ная цикла р представляет текущее значение, для которого выполняется про­
верка, является ли оно простым числом. В первом операторе цикла присваива­
ется значение 1 переменной isPrime. Использование этой переменной будет
описано чуть позже.
Во втором цикле выполняется деление р на целые числа от 2 до р-1. Внутри
этого цикла проверяется остаток от деления р на d. Если остаток равен 0, зна­
чит, р не является простым числом, поскольку оно делится на целое число, от­
личное от 1 и от него самого. Чтобы указать, что р уже не является «кандида­
том» на простое число, переменной isPrime присваивается значение 0.
После окончания внутреннего цикла проверяется значение isPrime. Если оно
не равняется нулю, значит, не найдено целого числа, которое делит р нацело, и
р является простым числом, после чего выводится его значение.
Переменная isPrime принимает всего два значения: 0 или 1. Ее значение равно 1,
пока р еще проверяется на принадлежность к множеству простых чисел. Как толь­
ко находится хотя бы один делитель без остатка, isPrime присваивается значение 0,
чтобы указать, что р не отвечает критерию принадлежности к простым числам.
Такие переменные обычно называют булевыми (Boolean) переменными. Флажок
(признак) обычно принимает одно из двух значений. Кроме того, значение флаж­
ка обычно проверяется хотя бы один раз в программе, чтобы определить, уста­
новлен он (значение TRUE или YES) или сброшен (FALSE или N0), а также выпол­
нить определенное действие в зависимости от результата проверки.
В Objective-C состояниям флажка TRUE и FALSE естественным образом соот­
ветствуют значения 1 и 0. Например, когда в программе 6.10 переменной isPrime
внутри цикла присваивается значение 1, ей фактически присваивается значе­
ние TRUE, указывающее, что р пока считается простым числом («is prime»). Если
при выполнении внутреннего цикла for найден делитель нацело, переменной
isPrime фактически присваивается значение FALSE, чтобы указать, что р не явля­
ется простым числом.
Значение 1 обычно используется для представления значения TRUE (или со­
стояния «оп»), а значение 0 — для представления значения FALSE (или состояния
«off»). Это соответствует одному биту в компьютере. Если бит находится в со­
стоянии «оп» (установлен), его значение равно 1, если он находится в состоя­
нии «off» (сброшен), его значение равно 0. Но в Objective-C имеется более вес­
кая причина для использования именно этих логических значений. В начале
этой главы говорилось, что если удовлетворяются условия, указанные в опера­
торе if, то выполняется следующий за ним программный оператор. В языке
Objective-C это означает условие (состояние) «не ноль». Например,
if ( 100)
NSLog (@"This will always be printed.");
вызывает выполнение оператора NSLog ввиду ненулевого состояния в операто­
ре if (в данном случае — значение 100), то есть удовлетворяется условие «не ноль».
В каждой из программ этой главы мы фактически использовали понятия
«не нуль — условие удовлетворяется» и «нуль — условие не удовлетворяется». В
Objective-C при оценке выражения отношения ему присваивается значение 1,
если соответствующее условие удовлетворяется, и 0, если условие не удовлет­
воряется. Поэтому оценка оператора
if ( number < 0 )
number = -number;
фактически происходит следующим образом. Выполняется оценка выражения
отношения number < 0. Если это условие удовлетворяется (number меньше 0), то
значение выражения равно 1, иначе его значение равно 0.
В операторе if проверяется результат оценки выражения. В случае ненулево­
го результат выполняется следующий оператор. То же самое относится к оцен­
ке условий в операторах for, while и do. Оценка составных выражений отношения
(сравнения) выполняется таким же образом.
while ( char != 'е' && count != 80 )
Если верны оба условия, то результат равен 1, но если неверно хотя бы одно
из условий, результат оценки равен 0. Затем выполняется проверка результатов
оценки. Если результат равен 0, то выполнение цикла while прекращается, иначе
его выполнение продолжается.
Вернемся к программе 6.10 и понятию флажков. В Objective-C допустимо
проверять значение флажка TRUE, например, с помощью следующего выраже­
ния.
if ( isPrime)
Оно эквивалентно следующему выражению.
if ( isPrime != 0 )
Можно проверить значение флажка FALSE с помощью логического операто­
ра отрицания !. В следующем выражении логический оператор отрицания ис­
пользуется, чтобы проверить переменную isPrime на значение FALSE (его можно
прочитать как «если не isPrime»).
if (! isPrime )
В общем виде логическое отрицание выражения записывается как
! выражение
Так, если выражение равно 0, то оператор логического отрицания дает зна­
чение 1. Если оценка выражения не равна 0, то оператор отрицания дает зна­
чение 0.
Оператор логического отрицания может можно использовать для измене­
ния значения флажка, как в следующем выражении.
my_move = ! my_move;
Этот оператор имеет такой же уровень приоритета, как и унарный оператор
«минус», т.е. имеет более высокий приоритет, чем все бинарные арифметичес­
кие операторы и все операторы отношения. В следующем выражении задано
условие на то, чтобы значение переменной х было не меньше значения пере­
менной у, поэтому здесь необходимы круглые скобки.
!(х<у)
Этот оператор можно записать в эквивалентной форме:
х >= у
В Objective-C имеется пара встроенных средств, упрощающих работу с бу­
левыми переменными. Одно из них —специальный тип B00L, который можно
использовать для объявления переменных со значениями true или false. Второе
средство — это встроенные значения YES и N0. Использование этих значений
упрощает написание и чтение программ. Ниже приводится версия программы
6.10, переписанной с использованиемэтих средств.
Примечание. Тип B00L добавляется механизмом, который называется препро­
цессором.
Программа 6.10А
// Программа создания таблицы простых чисел.
// Вторая версия с использованием типа B00L и готовых значений
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int p, d;
BOOL isPrime;
for ( р = 2; р <= 50; ++р ) {
isPrime = YES;
for ( d = 2; d < р; ++d )
if ( p % d == 0 )
isPrime = NO;
if ( isPrime == YES )
NSLog (@»%i«, p);
}
[pool drain];
return 0;
}
Вывод программы 6.10A
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47

## 6.4. Условный оператор
Возможно, самым необычным оператором в языке Objective-C является услов­
ный (conditional) оператор. В отличие от остальных операторов в Objective-C,
которые являются унарными или бинарными, условный оператор является
тернарным, или трехместным (ternary), то есть в нем требуются три операнда. В
этом операторе для обозначений используются два символа: вопросительный знак
(?) и двоеточие (:). Первый операнд ставят перед знаком ?, второй операнд — между
знаками ? и третий операнд ставится после :. Ниже показан формат условного
оператора в общем виде.
условие ? выражение_ 1: выражение_2
В этом описании синтаксиса условие — это выражение (обычно выражение
отношения), которое сначала оценивается системой Objective-C в условном
операторе. Если результатом оценки является значение TRUE (то есть не нуль),
то вычисляется выражение_ 1 и результат вычисления становится результатом дан­
ной операции. Если результатом оценки условия является значение FALSE (то есть
нуль), то вычисляется выражение_2 и результат вычисления становится результа­
том данной операции.
Условное выражение чаще всего используется, чтобы в зависимости от не­
которого условия присвоить переменной одно из двух значений. Например,
предположим, что у нас есть две целые переменные - х и s. Чтобы присвоить s
значение -1, если х меньше 0, или значение х2 в противном случае, можно ис­
пользовать следующий оператор.
s = ( х < 0 ) ? -1 : х * х;
Сначала проверяется условие х < 0. Обычно условие помещается в круглые
скобки, но это не обязательно, поскольку условный оператор имеет очень низ­
кий приоритет - ниже всех остальных операторо, за исключением операторов
присваивания и оператора «запятая».
Если значение х меньше нуля, то вычисляется выражение, непосредственно
следующее за символом ?. Это выражение представлено просто целой констан­
той -1, которая присваивается переменной s, если х меньше нуля.
Если значение х не меньше нуля, то вычисляется выражение, непосредствен­
но следующее за символом оно присваивается переменной s. Таким образом,
если х больше или равно нулю, то переменной s присваивается значение х * х,
или х2.
Еще один пример условного оператора: оператор, где переменной maxvalue
присваивается максимум из двух значений: а и Ь.
max_value = ( а > b ) ? а : b;
Если выражение после : (часть «иначе») содержит еще один условный опе­
ратор, то мы получаем возможности предложения else if. Например, функцию
sign, которая реализована в программе 6.6, можно записать в одной программ­
ной строке с помощью двух условных операторов.
sign = ( number < 0 ) ? -1 : (( number == 0 ) ? 0 : 1);
Если number меньше нуля, то переменной sign присваивается значение -1; если
number равно нулю, то переменной sign присваивается значение 0; иначе ей при­
сваивается значение 1. Круглые скобки вокруг части «иначе» на самом деле не
обязательны. Дело в том, что условный оператор объединяется справа налево,
то есть когда этот оператор используется несколько раз в одном выражении,
например, в
е1 ? е2 : еЗ ? е4 : е5
группирование происходит справа налево и поэтому оценка выполняется сле­
дующим образом:
е1 ? е2 : ( еЗ ? е4 : е5 )
Условные выражения не обязаны стоять в правой части операции присваи­
вания — их можно применять в любой ситуации, где используются выражения.
С помощью оператора NSLog вы можете вывести на дисплей знак (sign) пере­
менной number без присваивания ее какой-либо переменной:
NSLog (@"Sign = %i", ( number < 0 ) ? -1 : ( number == 0 ) ? О : 1);
Условный оператор очень удобно использовать в Objective-C при написа­
нии макросов препроцессора (см. главу 12).

Упражнения
1. Напишите программу, которая запрашивает у пользователя ввод двух целых
значений. Проверьте, делится ли первое число без остатка на второе число,
и выведите на терминал соответствующее сообщение.
2. Программа 6.8А выводит значение, содержащееся в сумматоре, даже если
введен неверный оператор или пользователь пытается выполнить деление
на нуль. Решите эту проблему.
3. Внесите изменения в метод print из класса Fraction, чтобы целые числа выво­
дились в обычном виде (например, дробь 5/1 должна выводиться как 5). Вне­
сите изменения в этот метод, чтобы дроби с делителем, равным 0, выводи­
лись просто как 0.
4. Напишите программу, которая действует как простой калькулятор. Эта про­
грамма должна позволять пользователю вводить выражения в следующей
форме:
число оператор
Программа должна распознавать следующие операторы:
+ - * / S Е
Оператор S указывает, что программа должна присвоить сумматору
(accumulator) введенное число, и оператор Е указывает программе, что нужно за­
кончить выполнение. Арифметические операции выполняются для содержимо­
го сумматора с числом, которое введено для операции как второй операнд. Ниже
приводится пример, показывающий, как должна работать эта программа.
Начало вычислений
10 S Сумматору (Accumulator) присваивается значение
= 10.000000 Содержимое сумматора
2 / Divide by 2
= 5.000000 Содержимое сумматора
55 - Вычитание 55
10
= -50.000000
100.25 S Сумматору присваивается значение 100.25
= 100.250000
4 * Умножение на 4
= 401.000000
0 Е Завершение программы
= 401.000000
End of Calculations. (Конец вычислений)
Сделайте так, чтобы программа обнаруживала деление на 0, а также выпол­
няла проверку на неизвестные операторы. Используйте для своих вычисле­
ний класс Calculator из программы 6.8
5, В программе 5.9 выполняется вывод цифр введенного числа в обратном по­
рядке. Однако эта программа не работает должным образом, если введено
отрицательное число. Определите, что происходит в этом случае, и затем
внесите в программу изменения, чтобы правильно обрабатывались отрица­
тельные числа. Это означает, например, что если введено число -8645, то про­
грамма должна вывести 5468-.
6* Напишите программу, которая читает число, введенное с терминала, и вы­
водит каждую цифру этого числа буквами. Например, если пользователь ввел
932, то программа должна вывести следующее.
девять
три
два
(Выведите слово нуль, если пользователь ввел 0.) Примечание. Это довольно
трудное упражнение!
7. Программа 6.10 в ряде случаев работает неэффективно. Например, это ка­
сается проверки четных чисел. Поскольку любое четное число больше 2 не
может быть простым, программа могла бы пропускать все четные числа и
как возможные простые числа, и как возможные делители. Внутренний цикл
for тоже работает неэффективно, поскольку для р все время выполняется
деление на все значения d от 2 до р-1. Чтобы избежать этой неэффективно­
сти, можно добавить значение isPrime в условия for. Тогда вы можете задать
выполнение цикла for до тех пор, пока не найден делитель и значение d мень­
ше р. Модифицируйте программу 6.10, чтобы внести эти два изменения, за­
тем выполните эту программу, чтобы проверить ее работу.