# Глава 6. Принятие решений

В любом языке программирования имеется возможность принятия решений. В языке программирования Objective-C имеются несколько конструкций для принятия решений.
* Оператор if
* Оператор switch
* Условный оператор

## 6.1. Оператор if
В общем виде оператор if имеет следующий формат.
```
if ( выражение)
    программный оператор
```
Представим, что нам нужно преобразовать утверждение «Если нет дождя, я пойду купаться» в операторы языка Objective-C. Используя показанный выше формат, это можно «записать» следующим образом.
```
if ( нет дождя )
    я пойду купаться
```
Оператор if используется, чтобы выполнить программный оператор в зависимости от указанных условий (или операторы, если они заключены в фигурные скобки). Аналогичным образом, в программном операторе
```
if ( count > MAXIMUMSONGS )
[playlist maxExceeded];
```
сообщение maxExceeded отправляется playlist (список воспроизведения), только если значение переменной count больше значения MAXIMUM SONGS, иначе этот оператор игнорируется.

Рассмотрим пример. Предположим, что вам нужно написать программу, которая принимает целое значение, введенное с клавиатуры, и затем выводит абсолютное значение этого целого числа. Проще всего вычислить абсолютное значение числа — взять его с противоположным знаком, если оно меньше нуля. Фраза «если оно меньше нуля» означает, что программа должна принять решение. Для этого можно использовать оператор if, как показано в программе 6.1.
```
// Вычисление абсолютного значения целого числа
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    int number;

    NSLog (@"Type in your number: ");
    scanf("%i", &number);

    if ( number < 0 )
    number = -number;

    NSLog (@"The absolute value is %i", number);

    [pool drain];
    return 0;
}
```
Вывод программы 6.1
```
Type in your number: (Введите свое число)
-100
The absolute value is 100 (Абсолютное значение равно 100)
```
Вывод программы 6.1 (повторный запуск)
```
Type in your number:
2000
The absolute value is 2000
```
Эта программа запускалась два раза, чтобы проверить правильность ее работы. Мы проверили оба возможных результата принятия решений.

После вывода сообщения для пользователя и сохранения введенного целого значения в переменной number программа проверяет, не является ли значение number отрицательным. Если да, то выполняется следующий программный оператор, который изменяет знак number на противоположный. Если значение number не меньше нуля, этот оператор автоматически пропускается. (В этом случае не нужно изменять знак на противоположный.) Затем выполняется вывод значения number и завершается выполнение программы.

Рассмотрим еще одну программу с оператором if. Мы добавим в класс Fraction еще метод convertToNum. Этот метод будет представлять значение дроби в виде вещественного числа — выполнять деление числителя (numerator) на знаменатель (denominator). Результат будет возвращаться как значение двойной точности (double). Так, для дроби 1/2 нужно возвращать значение 0.5.

Для такого метода можно использовать, например, следующее объявление
```
-(double) convertToNum;
```
Его определение можно записать в следующем виде:
```
-(double) convertToNum
{
    return numerator / denominator;
}
```
Хорошо, но недостаточно. При таком определении этот метод имеет две серьезные проблемы. Первая относится к работе с арифметическими преобразованиями. Напомним, что numerator и denominator — это целые переменные экземпляра. А что происходит при делении целых значений? Оно выполняется как целое деление! Если нужно преобразовать дробь 1/2, то представленный код даст значение нуль! Это легко исправить с помощью оператора приведения типа, преобразующего один или оба операнда в значение с плавающей точкой до операции деления:
```
(double) numerator / denominator
```
Поскольку этот оператор имеет относительно высокий приоритет, значение numerator преобразуется в тип double до выполнения деления. Вам не обязательно преобразовывать denominator, достаточно сделать это для одного из операндов.

Вторая проблема заключается в том, что нужно проверять деление на нуль (вы должны всегда выполнять эту проверку). Ниже показана модифицированная версия метода convertToNum.
```
-(double) convertToNum
{
    if (denominator != 0)
        return (double) numerator / denominator;
    else
        return 0.0;
}
```
Мы решили возвращать значение 0.0, если знаменатель дроби равен нулю. Можно использовать и другие варианты (например, вывод сообщения об ошибке, создание исключительного состояния и т.д.).

Введем этот метод в программе 6.2.
```
#import <Foundation/Foundation.h>

@interface Fraction: NSObject
{
    int numerator;
    int denominator;
}

-(void) print;
-(void) setNumerator: (int) n;
-(void) setDenominator: (int) d;
-(int) numerator;
-(int) denominator;
-(double) convertToNum;
@end

@implementation Fraction
-(void) print
{
    NSLog (@" %i/%i", numerator, denominator);
}

-(void) setNumerator: (int) n
{
    numerator = n;
}

-(void) setDenominator: (int) d
{
    denominator = d;
}

-(int) numerator
{
    return numerator;
}

-(int) denominator
{
    return denominator;
}

-(double) convertToNum
{
    if (denominator != 0)
        return (double) numerator / denominator;
    else
        return 0.0;
}
@end

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    Fraction *aFraction = [[Fraction alloc] init];
    Fraction *bFraction = [[Fraction alloc] init];

    [aFraction setNumerator: 1]; // 1-я дробь 1/4
    [aFraction setDenominator: 4];

    [aFraction print];
    NSLog (@" =");
    NSLog (@"%g", [aFraction convertToNum]);

    [bFraction print]; // значение не было присвоено
    NSLog (@" =");
    NSLog (@"%g", [bFraction convertToNum]);
    [aFraction release];
    [bFraction release];

    [pool drain];
    return 0;
}
```
Вывод программы 6.2
```
1/4
0.25
0/0
=
0
```
После присваивания aFraction значения 1/4 используется метод convertToNum, чтобы преобразовать эту дробь в десятичное значение. Затем это значение выводится как 0.25.

Во втором случае значение bFraction не задано явным образом, поэтому его числителю и знаменателю присваивается значение 0, что происходит по умолчанию для переменных экземпляра. Это объясняет результат метода print, а оператор if в методе convertToNum возвращает значение 0.

### Конструкция if-else
Если нужно сказать, является ли число четным или нечетным, вы, скорее всего, определите это по последней цифре числа. Если эта цифра равна 0, 2,4,6 или 8, значит, число является четным.

На компьютере это можно сделать проще: достаточно проверить, делится ли это число на 2 без остатка. Если да, то число является четным, иначе оно является нечетным.

Вы уже видели, как использовать оператор взятия по модулю (%) для вычисления остатка отделения одного целого числа на другое. Его удобно использовать, чтобы определить, делится ли число на 2 без остатка. Если остаток от деления на 2 равен 0, значит, это четное число, если нет — нечетное.

Напишем программу, которая определяет, является ли целое значение, которое вводит пользователь, четным или нечетным, и выводит соответствующее значение на терминал (см. программу 6.3).
```
// Программа, определяющая, является ли число четным или нечетным
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    int number_to_test, remainder;

    NSLog (@"Enter your number to be tested:");
    scanf ("%i", &number_to_test);

    remainder = number_to_test % 2;

    if ( remainder == 0 )
        NSLog (@"The number is even.");
    if ( remainder != 0 )
        NSLog (@"The number is odd.");
    [pool drain];
    return 0;
}
```
Вывод программы 6.3
```
Enter your number to be tested: (Введите ваше число для проверки)
2455
The number is odd. (Число является нечетным)
```
Вывод программы 6.3 (повторный запуск)
```
Enter your number to be tested:
1210
The number is even. (Число является четным)
```
После ввода числа вычисляется остаток отделения на 2. Первый оператор if проверяет, равно ли нулю значение этого остатка. Если да, то выводится сообщение «The number is even.» (Число является четным).

Второй оператор if проверяет значение этого остатка на неравенство нулю. Если да, то выводится сообщение, что число является нечетным.

Если выполняется первый оператор if, то второй оператор не должен выполняться, и наоборот. При написании программ концепция «иначе» («else») требуется настолько часто, что почти во всех современных языках программирования введена специальная конструкция для этой ситуации. В Objective-C это конструкция if-else, которая имеет следующий формат.
```
if (выражение)
    программный оператор 1
else
    программный оператор 2
```

На самом деле if-else является просто расширением общего формата оператора if. Если результатом оценки выражения является значение TRUE, то выполняется программный оператор /; иначе выполняется программный оператор 2. Во всех случаях выполняется программный оператор 1 или программный оператор 2, но не оба оператора.

Оператор if-else можно вставить в предыдущую программу, заменив два оператора if на один оператор if-else. Эта новая конструкция в некоторой степени упрощает программу и делает ее более удобной для чтения.
```
// Программа, определяющая, является ли число четным или нечетным (Версия 2)
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    int number_to_test, remainder;

    NSLog (@"Enter your number to be tested:");
    scanf ("%i", &number_to_test);

    remainder = number_to_test % 2;

    if ( remainder == 0 )
        NSLog (@"The number is even.");
    else
        NSLog (@"The number is odd.");
    [pool drain];
    return 0;
}
```
Вывод программы 6.4
```
Enter your number to be tested: (Введите ваше число для проверки)
1234
The number is even. (Число является нечетным)
```
Вывод программы 6.4 (повторный запуск)
```
Enter your number to be tested:
6551
The number is odd. (Число является четным)
```
He забывайте, что двойной знак равенства (==) - это проверка на равенство, а одинарный знак равенства — это оператор присваивания. Если случайно использовать оператор присваивания внутри оператора if, то может возникнуть множество проблем.

### Составные операции сравнения
До сих пор в операторах if использовались простые операции сравнения между двумя числами. В программе 6.1 сравнивалось значение числа с нулем, а в программе 6.2 выполнялось сравнение с нулем знаменателя дроби. Иногда необходимы более сложные проверки. Предположим, что нужно вычислить количество экзаменационных оценок в диапазоне от 70 по 79. В данном случае нужно сравнить значение оценки не с одним пределом, а с двумя (70 и 79), чтобы
проверить, попадает ли она в указанный диапазон.
В Objective-C имеется механизм для составных операторов сравнения этого
типа. Составная операция сравнения (compound relational test) — это несколько
операций сравнения, объединенных логическим оператором AND или 0R. Эти
операторы представлены парой символов && или || (два вертикальных штриха).
Н апример, следующий оператор увеличивает значение переменной
grades_70_to_79 (оценки от 70 по 79), только если значение grade (оценка) больше
или равно 70 и меньше или равно 79).
if ( grade >= 70 && grade <= 79 )
++grades_70_to_79;
А следующий оператор вызывает выполнение оператора NSLog, если index
меньше 0 или больше 99.
if ( index < 0 || index > 99 )
NSLog (@"Error - index out of range"); (Ошибка - индекс вне диапазона)
Составные операторы можно использовать в Objective-C для формирования
очень сложных выражений. Не злоупотребляйте этим. Более простые выражения всегда проще читать и отлаживать.При формировании составных выражений сравнения можно неограниченно использовать круглые скобки, чтобы повысить удобство чтения выражений и избежать осложнений из-за ошибочных
предположений о старшинстве операторов в выражении. (Оператор && имеет
более низкий приоритет, чем любой арифметический оператор или оператор
отношения, но более высокий приоритет, чем оператор ||.) Пробелы также повышают удобочитаемость выражения. Дополнительные пробелы вокруг операторов && и || визуально отделяют эти операторы от выражений, которые они
связывают.
Чтобы показать использование составных операций сравнения на конкретном примере, мы напишем программу, которая проверяет, является ли определенный год високосным, если он делится на 4 без остатка. Год, который делится на 100, не является високосным годом, если он не делится также на 400.
Необходимо продумать, как проверять эти условия. Во-первых, можно сосчитать остатки (remainder) отделения года на 4, 100 и 400 и присвоить эти значения соответствующим переменным, например, rem_4, remJOO и rem_400. Затем
можно проверить эти переменные, чтобы выяснить, отвечают ли эти остатки
критериям високосного года.
Можно сказать, что год является високосным, если он делится без остатка
на 4 и не делится на 100, либо он делится без остатка на 400. На всякий случай
убедитесь, что это определение эквивалентно предыдущему определению. Теперь, когда мы переформулировали определение, его реализация в виде программного оператора становится достаточно простой.
if ( (rem_4 == 0 && remJOO != 0) || rem_400 == 0 )
NSLog (@"lt’s a leap year."); ("Это високосный год")
Круглые скобки вокруг следующего подвыражения не обязательны.
rem_4 == 0 && remJOO != О
Оно будет оцениваться в таком порядке в любом случае, поскольку оператор && имеет более высокий приоритет, чем ||.
В этом примере подходит и следующая проверка.
if ( rem_4 == 0 && ( remJOO != О || remJOO == 0 ))
Можно добавить перед этим оператором if несколько операторов объявления переменных и ввод пользователем значения года с терминала. Это программа 6.5, которая определяет, является ли год високосным.
Программа 6.5
// Эта программа определяет, является ли год високосным
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int year, rem_4, remJOO, remJOO;
NSLog (@"Enter the year to be tested:");
scant ("%i", &year);
rem J = year % 4;
remJOO = year % 100;
remJOO = year % 400;
if ( (rem 4 == 0 && remJOO != 0) || remJOO == 0 )
NSLog ((ant’s a leap year.");
else
NSLog (@"Nope, it’s not a leap year.");
[pool drain];
return 0;
}
Вывод программы 6.5
Enter the year to be tested: (Введите год для проверки)
1955
Nope, it’s not a leap year. (Нет, это не високосный год)
Вывод программы 6.5 (повторный запуск)
Enter the year to be tested:
2000
It’s a leap year. (Это високосный год)
Вывод программы 6.5 (повторный запуск)
Enter the year to be tested:
1800
Nope, it’s not a leap year. (Нет, это не високосный год)
В приведенных примерах вводится 1955-й год, который не является високосным, поскольку он не делится нацело на 4, 2000-й год, который является
високосным, поскольку он делится нацело на 400, и 1800-й год, который не
является високосным, поскольку он делится нацело на 100, но не на 400. В качестве последнего варианта следует проверить год, который делится нацело на
4, но не на 100. Выполните эту проверку самостоятельно.
Objective-C дает программисту очень высокий уровень гибкости при формировании выражений. Например, в приведенной выше программе вместо
вычисления промежуточных результатов rem_4, remJOO и rem_400 можно было бы
сделать все непосредственно в операторе if:
if (( year % 4 == 0 && year % 100 != О ) || year % 400 == 0 )
Использование пробелов для разделения отдельных операторов делает это
выражение более удобным для чтения. Если игнорировать эти возможности и
удалить необязательный набор круглых скобок, то получится следующее выражение:
if(year%4==0&&year%100!=0)||year%400==0)
Это выражение действует точно так же, как предыдущее выражение, однако
дополнительные пробелы очень упрощают восприятие составных выражений.

### Вложенные операторы if
При рассмотрении общего формата оператора if мы указывали, что если результатом оценки выражения в круглых скобках является значение TRUE, то выполняется следующий оператор. Этим программным оператором может быть еще
один оператор if, как в следующих строках.
if ( [chessGame isOver] == NO ) ([игра в шахматы окончена] == НЕТ)
if ( [chessGame whoseTurn] == YOU )([... чей ход] == ВАШ)
[chessGame yourMove]; ([... ваш ход])
Если значение, возвращаемое после отправки сообщения isOver объекту
chessGame, равно N0, то выполняется следующий оператор; в свою очередь, этот
оператор является еще одним оператором if. Этот оператор if сравнивает значение, возвращаемое методом whoseTurn, со значением YOU. Если эти два значения
равны, то объекту chessGame отправляется сообщение yourMove. Таким образом,
сообщение yourMove отправляется только в том случае, если игра не окончена, и
это ваш ход. Эти операторы можно было бы записать с помощью составной
операции сравнения:
if ( [chessGame isOver] == N0 && [chessGame whoseTurn] == YOU )
[chessGame yourMove];
Обычно с вложенными операторами if используют предложение else, как
показано ниже.
if ( [chessGame isOver] == N0 ) ([игра в шахматы окончена] == НЕТ)
if ( [chessGame whoseTurn] == YOU )([... чей ход] == ВАШ)
[chessGame yourMove]; ([... ваш ход])
else
[chessGame my Move]; ([... мой ход])
Сначала все выполняется, как и раньше, но если игра не окончена и ход не
ваш, то выполняется предложение else. В результате сообщение myMove отправляется объекту chessGame. Если игра окончена, то пропускается весь следующий
оператор if вместе с присоединенным к нему предложением else.
Предложение else связано с оператором if, который проверяет значение, возвращаемое методом whoseTurn, а не с оператором if, который проверяет, окончена ли игра (chessGame isOver). Общее правило состоит в том, что предложение
else всегда связывается с последним оператором if, не содержащим else.
Можно продвинуться еще на один шаг и добавить предложение else к внешнему оператору if. Это предложение else выполняется, если игра окончена.
if ( [chessGame isOver] == NO ) ([игра в шахматы окончена] == НЕТ)
if ( [chessGame whoseTurn] == YOU )([... чей ход] == ВАШ)
[chessGame yourMove]; ([... ваш ход])
else
[chessGame myMove]; ([...мой ход])
else
[chessGame finish]; (... конец)
Конечно, система может интерпретировать этот оператор и по-другому. Например, если в предыдущем примере удалить первое предложение else, то оператор не будет интерпретироваться в соответствии с показанными отступами.
if ( [chessGame isOver] == NO )
if ( [chessGame whoseTurn] == YOU )
[chessGame yourMove];
else
[chessGame finish];
Вместо этого оператор будет интерпретироваться следующим образом:
if ( [chessGame isOver] == NO )
if ( [chessGame whoseTurn] == YOU )
[chessGame yourMove];
else
[chessGame finish];
Предложение else связывается с последним оператором if, не включающим else.
Можно использовать фигурные скобки, чтобы связать else с внешним if, а не с
внутренним. Фигурные скобки замыкают оператор if, который находится внутри
них. Нужная последовательность задается с помощью следующего оператора.
if ( [chessGame isOver] == NO ) {
if ( [chessGame whoseTurn] == YOU )
[chessGame yourMove];
}
else
[chessGame finish];

### Конструкция else if
Вы уже видели, как действует оператор else при проверке двух возможных условий. Однако решения, которые приходится реализовать в программировании,
не всегда ограничиваются выбором между двумя вариантами. Рассмотрим программу, которая выводит -1, если пользователь вводит отрицательное число; О,
если число равно нулю; и 1, если число больше нуля. (Это реализация функции
sign.) Очевидно, что в этом случае нужны три проверки: для отрицательных чисел, чисел, равных нулю, и положительных чисел. Простая конструкция if-else в
данном случае не подходит. Конечно, мы могли бы прибегнуть здесь к трем отдельным операторам if, но это решение не всегда можно реализовать, особенно
если проверки не являются взаимоисключающими.
Чтобы справиться с этой ситуацией, можно добавить оператор if к предложению else. Мы уже говорили, что после предложения else может следовать любой допустимый программный оператор Objective-C, так почему не использовать еще один if?
if (выражение 1 )
программный оператор 1
else
if (выражение 2)
программный оператор 2
else
программный оператор 3
В результате оператор if расширяется — вместо логического решения с двумя
значениями мы получаем логическое решение с тремя значениями. Вы можете
продолжить добавление операторов if к предложениям else в том же стиле, чтобы получить логическое решение с п значениями.
Эта конструкция так часто используется, что обычно ее называют конструкцией else if и форматируют так.
if (выражение 1 )
программный оператор 1
else if (выражение 2 )
программный оператор 2
else
программный оператор 3
Это способ делает чтение оператора более удобным. В следующей программе показано использование конструкции else if с реализацией описанной выше
функции sign.
Программа 6.6
// Реализация функции sign
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int number, sign;
NSLog (@"Please type in a number:");
scant ("%i", &number);
if ( number < 0 )
sign = -1;
else if ( number == 0 )
sign = 0;
else // Положительное число
sign = 1;
NSLog (@"Sign = %i", sign);
[pool drain];
return 0;
}
Вывод программы 6.6
Please type in a number: (Введите число)
1121
Sign = 1
Вывод программы 6.6 (повторный запуск)
Please type in a number:
-158
Sign = -1
Вывод программы 6.6 (повторный запуск)
Please type in a number:
О
Sign = О
Если введенное число меньше нуля, переменной sign присваивается значение -1; если число равно нулю, sign присваивается значение 0; в противном случае число больше нуля, поэтому sign присваивается значение 1.
В следующей программе символ, введенный с терминала, анализируется и
классифицируется как алфавитный символ (a-z или A-Z), как цифровой символ
(0-9) или как специальный символ (все остальные символы). Для чтения одного символа с терминала при вызове scant используются символы форматирования %с.
Программа 6.7
// Эта программа классифицирует символ,
// введенный с клавиатуры
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
char c;
NSLog (@"Enter a single character:");
scant ("%c", &c);
it ( (c >= ’a' && c <= 'z') || (c >= ’A' && c <= 7'))
NSLog (@"lt’s an alphabetic character.");
else it ( c >= ’O’ && c <= ’9’ )
NSLog ((gilt's a digit.");
else
NSLog (@"lt’s a special character.");
[pool drain];
return 0;
}
Вывод программы 6.7
Enter a single character: (Введите один символ)
&
It’s a special character. (Это специальный символ)
Вывод программы 6.7 (повторный запуск)
Enter a single character:
8
It’s a digit. (Это цифра)
Вывод программы 6.7 (повторный запуск)
Enter a single character:
В
It’s an alphabetic character. (Это алфавитный символ)
В первой проверке после чтения символа мы определяем, является ли этот
символ алфавитным (в переменной с типа char). Сначала проверяется, попадает
ли этот символ в диапазон строчных букв:
( с >= 'а' && с <= 'z ')
Это выражение имеет значение TRUE, если с находится в диапазоне символов от ’а’ до У (с — строчная латинская буква). Вторая проверка выполняется с
помощью следующего выражения:
( с >= ’А’ && с <= “Z" )
Это выражение имеет значение TRUE, если с находится в диапазоне символов от 'А' до 'Т (с — прописная латинская буква). Эти проверки подходят для
символов в кодировке ASCII.
Если переменная с содержит алфавитный символ, проверка проходит успешно и выводится сообщение «It’s an alphabetic character» (Это алфавитный
символ). В противном случае выполняется предложение else if. Оно определяет,
является ли данный символ цифрой. Отметим, что выполняется сравнение с
символами от '0' до ’9’, а нес цифрами от 0 до 9. Дело в том, что с терминала читается символ, а запись символов от '0' до '9' в компьютере отличается от чисел
0-9. В кодировке ASCII символ ’0' представляется во внутренней записи числом
48, символ Т — числом 49, и т.д.
Если с — символ цифры, то выводится фраза «It’s a digit» (Это цифра). В противном случае (если с не является алфавитным символом или символом цифры) выполняется последнее предложение else, и на терминале выводится фраза
«It’s a special character» (Это специальный символ). Затем выполнение программы завершается.
Хотя в данном случае scant используется для чтения только одного символа,
вы все равно должны нажать клавишу Enter после ввода символа, чтобы результат ввода был передан в программу. Обычно при чтении данных с терминала программа «не видит» введенных данных, пока не нажата клавиша Enter.
В следующем примере напишем программу, которая позволяет ввести простое выражение в следующей форме:
число оператор число
Программа выполнит оценку выражения и выведет результаты на терминал. Операторы, которые нужно распознавать, — это обычные оператор сложения, вычитания, умножения и деления. Мы будем использовать класс Calculator
из программы 4.6 главы 4. Каждое выражение будет передаваться этому калькулятору для вычислений.
В следующей программе используется довольно большой оператор if с несколькими предложениями else if, определяющими, какая операция должна быть
выполнена.
Примечание. Чтобы избежать проблем с внутреннм представлением, лучше использовать процедуры из стандартной библиотеки islower и isupper. Для этого
включите в программу строку #import <ctype.h>.
Программа 6.8
// Программа вычисления простых выражений в форме
// число оператор число
// Реализация класса Calculator
#import <Foundation/Foundation.h>
@interface Calculator: NSObject
{
double accumulator;
}
// методы для сумматора (accumulator)
-(void) setAccumulator: (double) value;
-(void) clear;
-(double) accumulator;
// арифметические методы
-(void) add: (double) value;
-(void) subtract: (double) value;
-(void) multiply: (double) value;
-(void) divide: (double) value;
@end
@implementation Calculator
-(void) setAccumulator: (double) value
{
accumulator = value;
}
-(void) clear
{
accumulator = 0;
}
-(double) accumulator
{
return accumulator;
}
-(void) add: (double) value
{
accumulator += value;
}
-(void) subtract: (double) value
{
accumulator -= value;
}
-(void) multiply: (double) value
{
accumulator *= value;
}
-(void) divide: (double) value
{
accumulator /= value;
}
@end
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
double value 1, value2;
char operator;
Calculator *deskCalc = [[Calculator alloc] init];
NSLog (@"Type in your expression.");
scant ("%lf %c %lf", &value1, &operator, &value2);
[deskCalc setAccumulator: valuel];
if ( operator == )
[deskCalc add: value2];
else if ( operator == )
[deskCalc subtract: value2];
else if ( operator =='*')
[deskCalc multiply: value2];
else if ( operator == '/')
[deskCalc divide: value2];
NSLog (@"%.2f", [deskCalc accumulator]);
[deskCalc release];
[pool drain];
return 0;
}
Вывод программы 6.8
Type in your expression. (Введите ваше выражение)
123.5 + 59.3
182.80
Вывод программы 6.8 (повторный запуск)
Type in your expression.
198.7/26
7.64
Вывод программы 6.8 (повторный запуск)
Type in your expression.
89.3 * 2.5
223.25
При обращении к scant указывается, что должны быть считаны три значения
в переменные valuel, operator и value2. Значение типа double можно прочитать с
помощью символов формата %lf. Этот формат считывает значения в переменную valuel, которая является первым операндом выражения.
Затем считывается оператор. Поскольку оператор представляется символом
или 7 ), а не числом, он читается в символьную переменную operator.
Символы формата %с указывают, что нужно прочитать с терминала следующий
символ. Пробелы внутри строки формата указывают, что при вводе допускается любое число пробелов. Это позволяет при вводе значений отделять операнды от оператора.
После считывания двух значений и оператора программа сохраняет первое
значение в сумматоре (accumulator) калькулятора. Затем значение operator сравнивается с четырьмя возможными операторами. Если найдено допустимое со-
ответствие, калькулятору передается сообщение для выполнения операции. В
последней строке NSLog значение accumulator считывается для вывода. После этого
выполнение программы завершается.
Здесь необходимо сказать несколько слов о законченности программы. Хотя
приведенная программа выполняет поставленную задачу, ее нельзя назвать законченной, поскольку в ней не учитываются ошибки пользователя. Например,
что произойдет, если пользователь ошибся и ввел ? в качестве имени оператора? Программа просто пройдет через оператор if, и на терминале не появится
никаких ошибок, уведомляющих пользователя, что он ввел недопустимое выражение.
Еще один неучтенный случай — это ввод пользователем нулевого значения
делителя в операции деления. Программа должна проверять этот случай. Определение ситуаций, при которых возможен отказ программы или получение
нежелательных результатов, и принятие предупредительных мер — обязательная часть разработки надежных программ.
Программа 6.8А является модифицированной версией программы 6.8. В ней
учитываются деление на нуль и ввод неизвестного оператора.
Программа 6.8А
// Программа вычисления простых выражений в форме
// число оператор число
#import <Foundation/Foundation.h>
// Здесь нужно вставить секции interface и implementation
// для класса Calculator
int main (int argc, char *argv[])
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
double value 1, value2;
char operator;
Calculator *deskCalc = [[Calculator alloc] init];
NSLog (@"Type in your expression.");
scant ("%lf %c %lf", &value1, &operator, &value2);
[deskCalc setAccumulator: valuel];
if ( operator =='+')
[deskCalc add: value2];
else if ( operator =='-')
[deskCalc subtract: value2];
else if ( operator =='*’ )
[deskCalc multiply: value2];
else if ( operator == ' / ' )
if ( value2 == 0 )
NSLog (@"Division by zero.");
else
[deskCalc divide: value2];
else
NSLog (@"Unknown operator.");
NSLog (@"%.2f", [deskCalc accumulator]);
[deskCalc release];
[pool drain];
return 0;
}
Вывод программы 6.8A
Type in your expression. (Введите ваше выражение)
123.5 + 59.3
182.80
Вывод программы 6.8А (повторный запуск)
Type in your expression.
198.7/0
Division by zero. (Деление на нуль)
198.7
Вывод программы 6.8А (повторный запуск)
Type in your expression.
125 $28
Unknown operator. (Неизвестный оператор)
125
Если введен оператор деления (слэш), то проверяется, не равно ли нулю значения value2. Если равно, выводится соответствующее сообщение; если нет - выполняется операция деления и выводятся результаты. Обратите внимание, как
в данном случае вложены оператор if и предложения else.
Предложение else в конце программы позволяет «уловить» любые непредусмотренные случаи. Поэтому любое значение переменной operator, которое не
совпадает с одним из четырех символов вычислений, приводит к выполнению
предложения else, и на терминал выводится сообщение «Unknown operator»
(Неизвестный оператор).
Более удобный способ обработки ситуации деления на ноль — это выполнение проверки в методе, который работает с операцией деления. Метод divide:
можно модифипировать следующим образом.
-(void) divide: (double) value
{
if (value != 0.0)
accumulator /= value;
else {
NSLog ((@"Division by zero.");
accumulator = 99999999.;
)
}
Для ненулевого значения выполняется деление; для нулевого — выводится
сообщ ен и е, и переменной accumulator п ри сваи вается значение 99999999. Это произвольно выбранное значение; можно было присвоить значение 0 или задать
специальную переменную, указывающую состояние ошибки. Лучше включать
обработку особых ситуаций в сам метод, чем полагаться на предусмотрительность программиста при использовании метода.

### Оператор switch
Цепочки if-else гак часто используются при разработке программ, что в язык
Objcctivc-C включен специальный оператор для выполнения именно этой функции. Это оператор switch. Он имеет следующий формат.
switch (выражение)
{
case valuel:
программный оператор
программный оператор
break;
case value2.
программный оператор
программный оператор
break;
case valuen:
программный оператор
программный оператор
break;
default:
программный оператор
программный оператор
break;
}
Выражение, указанное в круглых скобках, последовательно сравнивается со
значениями valuel, value2, ..., valuer), которые могут быть простыми константами
или константными выражениями. Если найден вариант (case), при котором значение равно значению выражения, выполняются программные операторы, следующие после этого предложения case. Если включено несколько таких операторов, то их можно не заключать в фигурные скобки.
Оператор break вызывает прекращение выполнения оператора switch. Не забывайте включать оператор break в конце каждого предложения case, иначе выполнение программы продолжится в следующем предложении case. Иногда это
делают преднамеренно; в таких случаях обязательно включите комментарии,
чтобы предупредить других о ваших целях.
Особый (необязательный) вариант с именем default выполняется в том случае, если значение выражения не соответствует ни одному из значений, указанных в предложениях case. Это эквивалентно предложению else, которое использовалось в предыдущем примере для «улавливания» любых неуказанных
вариантов. На самом деле общую форму оператора switch можно представить в
эквивалентной форме оператора if.
if (выражение == value 1)
{
программный оператор
программный оператор
}
else if (выражение == value2)
{
программный оператор
программный оператор
}
else if (выражение == valuen)
{
программный оператор
программный оператор
>
else
{
программный оператор
программный оператор
}
Мы можем теперь преобразовать большой оператор if из программы 6.8А в
эквивалентный оператор switch. Это показано в программе 6.9.
Программа 6.9
// Программа вычисления простых выражений в форме
// число оператор число
#import <Foundation/Foundation.h>
// Здесь нужно вставить секции interface и implementation
// для класса Calculator
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
double value 1, value2;
char operator;
Calculator *deskCalc = [[Calculator alloc] init];
NSLog (@"Type in your expression.");
scant ("%lf %c %lf, &value1, &operator, &value2);
[deskCalc setAccumulator: valuel];
switch ( operator) {
case
[deskCalc add: value2];
break;
case
[deskCalc subtract: value2];
break;
case
[deskCalc multiply: value2];
break;
case 7 :
[deskCalc divide: value2];
break;
default:
NSLog (@"Unknown operator.");
break;
}
NSLog (@"%.2Г, [deskCalc accumulator]);
[deskCalc release];
[pool drain];
return 0;
}
Вывод программы 6.9
Type in your expression. (Введите ваше выражение)
178.99 - 326.8
-147.81
После считывания выражения значение переменной operator сравнивается
со значениями каждого варианта case. Если найдено соответствие, то выполняются операторы внутри этого варианта case. Затем оператор break выполняет
выход из оператора switch, после чего завершается выполнение программы. Если
ни один из вариантов не соответствует значению переменной operator, то используется вариант по умолчанию default, в котором выводится сообщение «Unknown
operator» (Неизвестный оператор).
Оператор break для варианта default не является необходимым, т.к. после него
в данном операторе switch не выполняется никаких операторов. Однако практика надежного программирования требует вставки break в конце каждого варианта.
При написании оператора switch помните, что нельзя указывать одинаковые
значения для двух разных предложений case. Однако один набор программных
операторов можно связывать с несколькими case-значениями. Для этого нужно задать список из нескольких case-значений (с ключевым словом case перед
каждым значением и двоеточием после значения) и общий набор программных операторов. Например, в следующем операторе switch выполняется метод
multiply:, если значение operator указано символом «звездочка» или строчной буквой х.
switch ( operator)
case
case 'x':
[deskCalc multiply: value2];
break;
}

## 6.3. Булевы переменные
Почти все, кто учится программировать, довольно скоро сталкиваются с задачей написания программы, которая создает таблицу простых чисел. Напомним,
что положительное целое число р является простым числом, если оно не делится нацело ни на одно из других целых чисел, кроме 1 и самого себя. Первым
простым числом является 2. Следующее простое число — 3, так как оно делится
нацело только на 1 и 3; 4 не является простым числом, так как оно делится нацело на 2.
Создать таблицу простых чисел можно несколькими способами. Например,
чтобы создать таблицу простых чисел, не превышающих 50, достаточно напрямую проверить делимость каждого целого числа р на все целые числа от 2 до р-1.
Если р делится без остатка на одно из этих чисел, значит, р не является простым
числом, иначе оно является простым.
В программе 6.10 создается список простых чисел, не превышающих 50.
Программа 6.10
// Программа создания таблицы простых чисел (prime number)
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int p, d, isPrime;
for ( p = 2; p <= 50; ++p ) {
isPrime = 1;
for ( d = 2; d < p; ++d )
if ( p % d == 0 )
isPrime = 0;
if ( isPrime != 0 )
NSLog (@"%i", p);
[pool drain];
return 0;
}
Вывод программы 6.10
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
Внешний оператор for задает цикл по целым значениям от 2 до 50. Переменная цикла р представляет текущее значение, для которого выполняется проверка, является ли оно простым числом. В первом операторе цикла присваивается значение 1 переменной isPrime. Использование этой переменной будет
описано чуть позже.
Во втором цикле выполняется деление р на целые числа от 2 до р-1. Внутри
этого цикла проверяется остаток от деления р на d. Если остаток равен 0, значит, р не является простым числом, поскольку оно делится на целое число, отличное от 1 и от него самого. Чтобы указать, что р уже не является «кандидатом» на простое число, переменной isPrime присваивается значение 0.
После окончания внутреннего цикла проверяется значение isPrime. Если оно
не равняется нулю, значит, не найдено целого числа, которое делит р нацело, и
р является простым числом, после чего выводится его значение.
Переменная isPrime принимает всего два значения: 0 или 1. Ее значение равно 1,
пока р еще проверяется на принадлежность к множеству простых чисел. Как только находится хотя бы один делитель без остатка, isPrime присваивается значение 0,
чтобы указать, что р не отвечает критерию принадлежности к простым числам.
Такие переменные обычно называют булевыми (Boolean) переменными. Флажок
(признак) обычно принимает одно из двух значений. Кроме того, значение флажка обычно проверяется хотя бы один раз в программе, чтобы определить, установлен он (значение TRUE или YES) или сброшен (FALSE или N0), а также выполнить определенное действие в зависимости от результата проверки.
В Objective-C состояниям флажка TRUE и FALSE естественным образом соответствуют значения 1 и 0. Например, когда в программе 6.10 переменной isPrime
внутри цикла присваивается значение 1, ей фактически присваивается значение TRUE, указывающее, что р пока считается простым числом («is prime»). Если
при выполнении внутреннего цикла for найден делитель нацело, переменной
isPrime фактически присваивается значение FALSE, чтобы указать, что р не является простым числом.
Значение 1 обычно используется для представления значения TRUE (или состояния «оп»), а значение 0 — для представления значения FALSE (или состояния
«off»). Это соответствует одному биту в компьютере. Если бит находится в состоянии «оп» (установлен), его значение равно 1, если он находится в состоянии «off» (сброшен), его значение равно 0. Но в Objective-C имеется более веская причина для использования именно этих логических значений. В начале
этой главы говорилось, что если удовлетворяются условия, указанные в операторе if, то выполняется следующий за ним программный оператор. В языке
Objective-C это означает условие (состояние) «не ноль». Например,
if ( 100)
NSLog (@"This will always be printed.");
вызывает выполнение оператора NSLog ввиду ненулевого состояния в операторе if (в данном случае — значение 100), то есть удовлетворяется условие «не ноль».
В каждой из программ этой главы мы фактически использовали понятия
«не нуль — условие удовлетворяется» и «нуль — условие не удовлетворяется». В
Objective-C при оценке выражения отношения ему присваивается значение 1,
если соответствующее условие удовлетворяется, и 0, если условие не удовлетворяется. Поэтому оценка оператора
if ( number < 0 )
number = -number;
фактически происходит следующим образом. Выполняется оценка выражения
отношения number < 0. Если это условие удовлетворяется (number меньше 0), то
значение выражения равно 1, иначе его значение равно 0.
В операторе if проверяется результат оценки выражения. В случае ненулевого результат выполняется следующий оператор. То же самое относится к оценке условий в операторах for, while и do. Оценка составных выражений отношения
(сравнения) выполняется таким же образом.
while ( char != 'е' && count != 80 )
Если верны оба условия, то результат равен 1, но если неверно хотя бы одно
из условий, результат оценки равен 0. Затем выполняется проверка результатов
оценки. Если результат равен 0, то выполнение цикла while прекращается, иначе
его выполнение продолжается.
Вернемся к программе 6.10 и понятию флажков. В Objective-C допустимо
проверять значение флажка TRUE, например, с помощью следующего выражения.
if ( isPrime)
Оно эквивалентно следующему выражению.
if ( isPrime != 0 )
Можно проверить значение флажка FALSE с помощью логического оператора отрицания !. В следующем выражении логический оператор отрицания используется, чтобы проверить переменную isPrime на значение FALSE (его можно
прочитать как «если не isPrime»).
if (! isPrime )
В общем виде логическое отрицание выражения записывается как
! выражение
Так, если выражение равно 0, то оператор логического отрицания дает значение 1. Если оценка выражения не равна 0, то оператор отрицания дает значение 0.
Оператор логического отрицания может можно использовать для изменения значения флажка, как в следующем выражении.
my_move = ! my_move;
Этот оператор имеет такой же уровень приоритета, как и унарный оператор
«минус», т.е. имеет более высокий приоритет, чем все бинарные арифметические операторы и все операторы отношения. В следующем выражении задано
условие на то, чтобы значение переменной х было не меньше значения переменной у, поэтому здесь необходимы круглые скобки.
!(х<у)
Этот оператор можно записать в эквивалентной форме:
х >= у
В Objective-C имеется пара встроенных средств, упрощающих работу с булевыми переменными. Одно из них —специальный тип B00L, который можно
использовать для объявления переменных со значениями true или false. Второе
средство — это встроенные значения YES и N0. Использование этих значений
упрощает написание и чтение программ. Ниже приводится версия программы
6.10, переписанной с использованиемэтих средств.
Примечание. Тип B00L добавляется механизмом, который называется препроцессором.
Программа 6.10А
// Программа создания таблицы простых чисел.
// Вторая версия с использованием типа B00L и готовых значений
#import <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int p, d;
BOOL isPrime;
for ( р = 2; р <= 50; ++р ) {
isPrime = YES;
for ( d = 2; d < р; ++d )
if ( p % d == 0 )
isPrime = NO;
if ( isPrime == YES )
NSLog (@»%i«, p);
}
[pool drain];
return 0;
}
Вывод программы 6.10A
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47

## 6.4. Условный оператор
Возможно, самым необычным оператором в языке Objective-C является условный (conditional) оператор. В отличие от остальных операторов в Objective-C,
которые являются унарными или бинарными, условный оператор является
тернарным, или трехместным (ternary), то есть в нем требуются три операнда. В
этом операторе для обозначений используются два символа: вопросительный знак
(?) и двоеточие (:). Первый операнд ставят перед знаком ?, второй операнд — между
знаками ? и третий операнд ставится после :. Ниже показан формат условного
оператора в общем виде.
условие ? выражение_ 1: выражение_2
В этом описании синтаксиса условие — это выражение (обычно выражение
отношения), которое сначала оценивается системой Objective-C в условном
операторе. Если результатом оценки является значение TRUE (то есть не нуль),
то вычисляется выражение_ 1 и результат вычисления становится результатом данной операции. Если результатом оценки условия является значение FALSE (то есть
нуль), то вычисляется выражение_2 и результат вычисления становится результатом данной операции.
Условное выражение чаще всего используется, чтобы в зависимости от некоторого условия присвоить переменной одно из двух значений. Например,
предположим, что у нас есть две целые переменные - х и s. Чтобы присвоить s
значение -1, если х меньше 0, или значение х2 в противном случае, можно использовать следующий оператор.
s = ( х < 0 ) ? -1 : х * х;
Сначала проверяется условие х < 0. Обычно условие помещается в круглые
скобки, но это не обязательно, поскольку условный оператор имеет очень низкий приоритет - ниже всех остальных операторо, за исключением операторов
присваивания и оператора «запятая».
Если значение х меньше нуля, то вычисляется выражение, непосредственно
следующее за символом ?. Это выражение представлено просто целой константой -1, которая присваивается переменной s, если х меньше нуля.
Если значение х не меньше нуля, то вычисляется выражение, непосредственно следующее за символом оно присваивается переменной s. Таким образом,
если х больше или равно нулю, то переменной s присваивается значение х * х,
или х2.
Еще один пример условного оператора: оператор, где переменной maxvalue
присваивается максимум из двух значений: а и Ь.
max_value = ( а > b ) ? а : b;
Если выражение после : (часть «иначе») содержит еще один условный оператор, то мы получаем возможности предложения else if. Например, функцию
sign, которая реализована в программе 6.6, можно записать в одной программной строке с помощью двух условных операторов.
sign = ( number < 0 ) ? -1 : (( number == 0 ) ? 0 : 1);
Если number меньше нуля, то переменной sign присваивается значение -1; если
number равно нулю, то переменной sign присваивается значение 0; иначе ей присваивается значение 1. Круглые скобки вокруг части «иначе» на самом деле не
обязательны. Дело в том, что условный оператор объединяется справа налево,
то есть когда этот оператор используется несколько раз в одном выражении,
например, в
е1 ? е2 : еЗ ? е4 : е5
группирование происходит справа налево и поэтому оценка выполняется следующим образом:
е1 ? е2 : ( еЗ ? е4 : е5 )
Условные выражения не обязаны стоять в правой части операции присваивания — их можно применять в любой ситуации, где используются выражения.
С помощью оператора NSLog вы можете вывести на дисплей знак (sign) переменной number без присваивания ее какой-либо переменной:
NSLog (@"Sign = %i", ( number < 0 ) ? -1 : ( number == 0 ) ? О : 1);
Условный оператор очень удобно использовать в Objective-C при написании макросов препроцессора (см. главу 12).

Упражнения
1. Напишите программу, которая запрашивает у пользователя ввод двух целых
значений. Проверьте, делится ли первое число без остатка на второе число,
и выведите на терминал соответствующее сообщение.
2. Программа 6.8А выводит значение, содержащееся в сумматоре, даже если
введен неверный оператор или пользователь пытается выполнить деление
на нуль. Решите эту проблему.
3. Внесите изменения в метод print из класса Fraction, чтобы целые числа выводились в обычном виде (например, дробь 5/1 должна выводиться как 5). Внесите изменения в этот метод, чтобы дроби с делителем, равным 0, выводились просто как 0.
4. Напишите программу, которая действует как простой калькулятор. Эта программа должна позволять пользователю вводить выражения в следующей
форме:
число оператор
Программа должна распознавать следующие операторы:
+ - * / S Е
Оператор S указывает, что программа должна присвоить сумматору
(accumulator) введенное число, и оператор Е указывает программе, что нужно закончить выполнение. Арифметические операции выполняются для содержимого сумматора с числом, которое введено для операции как второй операнд. Ниже
приводится пример, показывающий, как должна работать эта программа.
Начало вычислений
10 S Сумматору (Accumulator) присваивается значение
= 10.000000 Содержимое сумматора
2 / Divide by 2
= 5.000000 Содержимое сумматора
55 - Вычитание 55
10
= -50.000000
100.25 S Сумматору присваивается значение 100.25
= 100.250000
4 * Умножение на 4
= 401.000000
0 Е Завершение программы
= 401.000000
End of Calculations. (Конец вычислений)
Сделайте так, чтобы программа обнаруживала деление на 0, а также выполняла проверку на неизвестные операторы. Используйте для своих вычислений класс Calculator из программы 6.8
5, В программе 5.9 выполняется вывод цифр введенного числа в обратном порядке. Однако эта программа не работает должным образом, если введено
отрицательное число. Определите, что происходит в этом случае, и затем
внесите в программу изменения, чтобы правильно обрабатывались отрицательные числа. Это означает, например, что если введено число -8645, то программа должна вывести 5468-.
6* Напишите программу, которая читает число, введенное с терминала, и выводит каждую цифру этого числа буквами. Например, если пользователь ввел
932, то программа должна вывести следующее.
девять
три
два
(Выведите слово нуль, если пользователь ввел 0.) Примечание. Это довольно
трудное упражнение!
7. Программа 6.10 в ряде случаев работает неэффективно. Например, это касается проверки четных чисел. Поскольку любое четное число больше 2 не
может быть простым, программа могла бы пропускать все четные числа и
как возможные простые числа, и как возможные делители. Внутренний цикл
for тоже работает неэффективно, поскольку для р все время выполняется
деление на все значения d от 2 до р-1. Чтобы избежать этой неэффективности, можно добавить значение isPrime в условия for. Тогда вы можете задать
выполнение цикла for до тех пор, пока не найден делитель и значение d меньше р. Модифицируйте программу 6.10, чтобы внести эти два изменения, затем выполните эту программу, чтобы проверить ее работу.