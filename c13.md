# Глава 13. Базовые средства из языка С
В этой главе описываются средства языка Objective-C, взятые из базового языка программирования С. Вам необязательно знать их. Такие средства, как функции, структуры, указатели, объединения и массивы лучше изучать по мере необходимости. Поскольку С является процедурным языком, некоторые из этих средств противоречат основам объектно-ориентированного программирования и могут также не согласовываться с некоторыми стратегиями Foundation framework, например, с методологией выделения памяти или работой с символьными строками, содержащими символы из нескольких байтов.
Примечание. На уровне Objective-C существуют способы работы с многобайтными символами, но в Foundation имеется нам нога более удобное решение с помощью собственного класса NSString.
С другой стороны, в некоторых приложениях может потребоваться низкоуровневый подход. Например, при работе с большими массивами данных мо- iyr применяться встроенные структуры данных в виде массивов из Objective-C вместо объектов-массивов из Foundation (см. главу 15). Функции могут оказаться удобным средством для группировки повторяющихся операций и разбиения программы на модули.
Ознакомьтесь с данной главой, чтобы получить общее представление, и вернитесь к ней, когда закончите изучение части II (Foundation Framework), или пропустите ее и перейдите к части II, где описывается Foundation framework. Если вам придется поддерживать чей-то код или вы начнете изучать header- формы Foundation framework, вам могут встретиться некоторые конструкции, описанные в этой главе. Некоторые из типов данных Foundation, такие как NSRange, NSPoinrt и NSRect, требуют элементарного понимания описываемых здесь структур. В таких случаях вы всегда сможно вернуться к этой главе.

## 13.1. Массивы
Язык Objective-C позволяет определить набор упорядоченных элементов данных, который называется массивом (array). В этом разделе описывается определение и управление массивами. В последующих разделах описывается использование массивов совместно с функциями, структурами, символьными строками и указателями.
Предположим, что вам нужно считать набор оценок (grades) и затем выполнить с ними некоторые операции, например, расположить их в порядке возрастания, вычислить среднее значение и найти медиану. Вы не можете выполнить эти операции, пока не введете все оценки.
В Objective-C вы можете определить переменную с именем grades, которая представляет не одно значение оценки, а весь набор оценок. Для ссылки на элементы этого набора используется число, которое называется порядковым номером, или индексом (index или subscript). В математике /-й элемент набора х обозначается как х; в Objective-C он обозначается как
```
x[i]
```
Тем самым, выражение
```
grades[5]
```
соответствует элементу с номером 5 в массиве с именем grades. В Objective-C элементы массива начинаются с номера 0, поэтому
```
grades[0]
```
на самом деле обозначает первый элемент массива.

Отдельный элемент массива можно использовать в любом месте как обычную переменную. Например, элемент массива можно присвоить другой переменной с помощью оператора
```
g = grades[50];
```
Здесь значение, содержащееся в gradesfSO], присваивается переменной д. В общем виде, если i объявлена как целая переменная, оператор
```
g = grades[i];
```
присваивает переменной g значение, содержащееся в элементе с номером i массива grades.

Чтобы сохранить значение в элементе массива, нужно указать этот элемент массива слева от знака равенства. В операторе
```
grades[ 100] = 95;
```
значение 95 сохраняется в элементе с номером 100 массива grades.

Для перебора элементов массива нужно изменять значение переменной, которая используется как индекс массива. Например, в цикле
```
for (i = 0; i < 100; ++i)
    sum += grades[i];
```
выполняется перебор первых 100 элементов массива grades (элементы 0-99), и значение каждой оценки (grade) добавляется к переменной sum. По окончании цикла for переменная sum будет содержать сумму первых 100 значений массива grades (если sum присвоено значение 0 до начала цикла).

Как и с другими типами переменных, необходимо объявить массив, прежде чем использовать его. Объявление массива — это объявление типа элементов, содержащихся в массиве (например, int, float или объект) и максимального числа элементов в массиве.

Определение
```
Fraction *fracts [100];
```
объявляет tracts как массив, содержащий 100 дробей (fraction). Для обозначения элементов этого массива нужно использовать индексы от 0 до 99. Выражение
```
fracts[2] = [fracts[Q] add: fracts[1]];
```
представляет вызов метода add: класса Fraction для сложения первых двух дробей из массива tracts и сохранения результата в третьем элементе массива.

В программе 13.1 создается таблица из первых 15 чисел Фибоначчи. Попытайтесь предсказать ее результаты. Какая связь существует между числами этой таблицы?

```
// Программа генерации первых 15 чисел Фибоначчи
#import <Foundation/Foundation.h>

int main (int arge, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    int Fibonacci [15], i;

    Fibonacci [0] = 0; /* by definition */

    Fibonacci[1] = 1; /* ditto 7

    for ( i = 2; i < 15; ++i)
        Fibonacci[i] = Fibonacci[i-2] + Fibonacci [i-1];

    for ( i = 0; i < 15; ++i)
        NSLog (@"%i", Fibonacci^]);

    [pool drain];
    return 0;
}
```
Вывод программы 13.1
```
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
```
Первые два числа Фибоначчи, которые мы назовем F0 и F, определяются соответственно как 0 и 1. Затем каждое следующее число Фибоначчи F определяется как сумма двух предыдущих чисел Фибоначчи F 2 и F,. Например, F2 вычисляется как сумма значений F0 и F, В приведенной профамме это соответствует вычислению Fibonacci[2] путем сложения значений Fibonacci[0] и Fibonacci[1]. Вычисление выполняется внутри цикла for для значений F0-F14 (то есть от Fibonacci[2] до Fibonacci[14]).

### Инициализация элементов массива
Элементам массива можно назначать начальные значения точно так же, как переменным при их объявлении. Для этого нужно просто перечислить начальные значения массива, начиная с первого элемента. Значения в списке разделяются запятыми, и весь список заключается в фигурные скобки.

В операторе
```
int integers[5] = { 0, 1, 2, 3, 4 };
```
элементу integers[0] присваивается значение 1, integers[1] — значение 1, integers[2] — значение 2, и т.д. Массивы символов инициализируются аналогичным образом. Например, в операторе
```
char letters[5] = {'а', 'b', 'с', 'd', 'е'};
```
определяется массив символов, и пяти элементам этого массива присваиваются соответственно значения 'a', 'b', 'с', 'd' и 'е'.

Вы не обязаны полностью инициализировать весь массив. Если указано меньшее количество начальных значений, инициализируется соответствующее количество элементов; остальные значения задаются равными нулю. Например, в объявлении
```
float sample_data[500] = { 100.0, 300.0, 500.5 };
```
инициализируются первые три значения массива sample_data (соответственно 100.0,300.0 и 500.5), а остальным 497 элементам присваивается значение 0.
Заключая номер элемента в прямоугольные скобки, можно инициализировать определенные элементы массива в любом порядке. Например, в строках,
```
int x = 1233;
int а[] = {[9] = х + 1, [2] = 3, [1] = 2, [0] = 1 };
```
определяется массив а из 10 элементов (по максимальному указанному индексу) и для последнего элемента задается значение х + 1 (1234). Кроме того, происходит инициализация первых трех элементов (значения 1,2 и 3 соответственно).

### Массивы символов
В программе 13.2 показано, как использовать массив символов. Однако здесь есть одна особенность, требующая обсуждения. Вы уже видите ее?
```
#import <Foundation/Foundation.h>

int main (int arge, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    char word[] = {'H', 'e', 'l', 'l', 'o', '!'};
    int i;
    for ( i = 0; i < 6; ++i)
        NSLog word[i]);

    [pool drain];
    return 0;
}
```
Вывод программы 13.2
```
H
e
l
l
о
!
```
Наиболее примечательной особенностью этой программы является объявление массива символов word без указания числа элементов. При определении массива без указания числа элементов размер массива определяется автоматически по числу инициализируемых элементов. Поскольку в программе 13.2 для массива word инициализируются шесть значений, язык Objective-C по умолчанию определяет, что данный массив содержит шесть элементов.

Этот принцип выполняется, если мы инициализируем каждый элемент массива в том месте, где определяется этот массив. В противном случае необходимо явным образом задать размер массива.

Если поместить завершающий нуль-символ ('\0') в конце массива символов, то создастся символьная строка (characterstring). Если в программе 13.2 заменить инициализацию массива word па строку
```
char word[] = {'Н', 'е', 'l', 'l', 'o', '!', '\0'};
```
то в дальнейшем можно выводить эту строку с помощью одного вызова NSLog, например,
```
NSLog (@"%s", word);
```
Символы форматирования %s указывают NSLog, что вывод символов должен продолжаться до тех пор, пока не будет достигнут завершающий нуль-символ. А именно этот символ мы поставили в конце массива word.

### Многомерные массивы
Все массивы, рассмотренные выше, являются линейными, то есть имеют одну размерность. Язык Objective-C позволяет определять массивы любой размер-ности. В этом разделе описываются двумерные массивы.

Типичным примером двумерного массива являются матрицы. Рассмотрим матрицу 4x5.
```
10  5  -3   17  82
9   0   0   8   -7
32  20  1   0   14
0   0   8   7   6
```
В математике для указания элемента матрицы используют два индекса. Если назвать эту матрицу М, то обозначение М.. будет указывать элемент /-й строки, у-го столбца, где / изменяется от 1 до 4 и/ изменяется от 1 до 5. Обозначение М3 2 указывает значение 20, которое находится в третьей строке втором столбце этой матрицы. Аналогичным образом, Л/45 указывает элемент, который находится в четвертой строке пятом столбце (значение 6).

В Objective-C при обозначении элементов двумерной матрицы используются аналогичные обозначения. Но поскольку в Objective-C нумерация начинается с 0, первая строка матрицы имеет номер 0, и первый столбец матрицы тоже имеет номер 0. Поэтому приведенная выше матрица будет иметь следующие обозначения строк и столбцов.
```
Строка (i) Столбец (j)
    0   1   2   3   4
0   10  5   -3  17  82
1   9   0   0   8   -7
2   32  20  1   0   14
3   0   0   8   7   6
```
Применяемое в математике обозначение M<sub>ij</sub>. заменяется в Objective-C обозначением
```
M[i][j]
```
Напомним, что первый индекс указывает номер строки, и второй индекс — номер столбца. Тем самым,
```
sum = М[0][2] + M[2J[4];
```
означает сложение значения из строки 0 столбца 2 (-3) со значением из строки 2 столбца 4 (14) и присваивание результата (11) переменной sum.

Описание двумерных массивов выполняется так же, как для одномерных массивов; например,
```
int М[4][5];
```
означает объявление массива М как двумерного массива, содержащего 4 строки и 5 столбцов (всего 20 элементов). Каждый элемент этого массива должен со-держать целое значение.

Двумерные массивы можно инициализировать аналогично одномерным. Перечисление элементов выполняется по строкам. Чтобы отделить инициали-зацию одной строки от другой, используются фигурные скобки. Таким образом, чтобы определить и инициализировать массив М с элементами из приведенной выше таблицы, можно использовать следующий оператор.
```
int М[4][5] = {
            {10, 5, -3, 17, 82 },
            { 9, 0, 0, 8, -7 },
            {32,20, 1,0, 14},
            { 0, 0, 8,7, 6 }
};
```
Уделите особое внимание синтаксису этого оператора. Отметим, что после каждой закрывающей фигурной скобки (кроме последней) требуется запятая. Использование внутренних пар фигурных скобок не является обязательным. Если они не указаны, инициализация происходит по строкам, поэтому преды-дущий оператор можно было бы написать следующим образом.
```
int М[4][5] = { 10, 5, -3, 17, 82, 9, 0, 0, 8, -7, 32,
                20,1,0, 14, 0, 0, 8, 7,6};
```
Как и в случае одномерных массивов, можно инициализировать не весь мас-сив. Например, в следующем операторе инициализируются только первые три элемента каждой строки матрицы.
```
int М[4][5] = {
            { 10, 5, -3},
            { 9, 0, 0 },
            { 32, 20, 1 },
            { 0, 0, 8 }
};
```
Остальным значениям присваивается значение 0. Отметим, что в данном случае для правильной инициализации необходимы внутренние пары фигурных скобок. Без таких скобок были бы инициализированы первые две строки и первые два элемента третьей строки. (Проверьте это сами.)

## 13.2. Функции
Процедура NSLog, которую мы использовали в каждой профамме этой книги, является примером функции. Каждая программа содержит функцию с именем main. Вернемся к нашей первой программе (программа 2.1), где на терминал выводилась фраза «Программировать на Objective-C интересно».
```
#import <Foundation/Foundation.h>
int main (int arge, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    NSLog (@"Программировать интересно.");
    [pool drain];
    return 0;
}
```
Следующая функция с именем printMessage выводит тот же текст.
```
void printMessage (void)
{
    NSLog (@"Программировать интересно.");
}
```
Единственным отличием между printMessage и функцией main из профаммы 2.1 является первая строка. В первой строке определения функции компилятору сообщаются четыре факта об этой функции.
* Кто может вызывать ее.
* Тип значения, которое она возвращает.
* Ее имя.
* Количество и тип аргументов, которые она принимает.

В первой строке определения функции printMessage компилятору сообщается, что имя функции printMessage и что она не возвращает никакого значения (первое применение ключевого слова void). В отличие от методов, тип возвращаемого значения функции не заключают в круглые скобки. Компилятор выдаст сообщение об ошибке, если вы сделаете это.

После сообщения, что printMessage не возвращает значений, ключевое слово void применяется во второй раз, указывая, что этой функции не передаются ни-какие аргументы.

Напомним, что main — это специальное имя в системе Objective-C, которое указывает, где должно начаться выполнение данной программы, main необхо-димо указывать всегда. Мы можем добавить функцию main к приведенному выше коду, чтобы получить законченную программу (см. программу 13.3).
```
#import <Foundation/Foundation.h>

void printMessage (void)
{
    NSLog (@"Программировать интересно.");
}

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    printMessage();
    [pool drain];
    return 0;
}
```
Вывод программы 13.3
```
Программировать интересно.
```
Программа 13.3 состоит из двух функций; printMessage и main. Поскольку printMessage не принимает никаких аргументов, при ее вызове используется просто пара круглых скобок.

### Аргументы и локальные переменные
В главе 5 мы разрабатывали программы для вычисления треугольных чисел. Здесь мы определим функцию с именем calculateTriangularNumber для генерации треугольного числа и будем вызывать ее. В качестве аргумента функции указы-вается номер треугольного числа. Функция будет вычислять нужное число и выводить результаты. В программе 13.4 показана функция для выполнения этой задачи и процедура main для ее проверки.
```
#import <Foundation/Foundation.h>
// Функция для вычисления п-го треугольного числа
void calculateTriangularNumber {int n)
{
    int i, triangularNumber = 0;

    for (i = 1; i <= n; ++i)
        triangularNumber += i;

    NSLog (@"Triangular number %i is %i", n, triangularNumber);
}

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    calculateTriangularNumber (10);
    calculateTriangularNumber (20);
    calculateTriangularNumber (50);

    [pool drain];
    return 0;
}
```
Вывод программы 13.4
```
Triangular number 10 is 55 (10-е треугольное число равно 55)
Triangular number 20 is 210
Triangular number 50 is 1275
```
Рассмотрим первую строку функции calculateTriangularNumber.
```
void calculateTriangularNumber (int n)
```
Она указывает компилятору, что calculateTriangularNumber — это функция, которая не возвращает никакого значения (ключевое слово void) и которой передается один api-умент с именем п типа int. Отметим еще раз, что тип аргумента нельзя помещать в круглые скобки, как мы привыкли делать при написании методов.

Открывающая фигурная скобка указывает начало определения функции. Поскольку нам нужно вычислять я-е треугольное число, мы должны задать пе-ременную для сохранения значения треугольного числа при его вычислении. Нам нужна также переменная, действующая как индекс цикла. Для этих целей переменные TriangularNumber и i определяются и объявляются с типом int. Их оп-ределение и инициализацию мы выполняем так же, как для других переменных внутри процедуры main в предыдущих программах.

Локальные переменные действуют в функциях так же, как в методах. Если для переменной внутри функции задано начальное значение, это начальное значение присваивается переменной при каждом вызове данной функции.

Переменные, определенные внутри функции, называются автоматическими локальными (automatic local) переменными, поскольку они автоматически «создаются» каждый раз, когда происходит вызов данной функции, а их значения являются локальными по отношению к данной функции.

Статические локальные (Static local) переменные описываются с помощью ключевого слова static, сохраняют свои значения при вызовах функций и имеют начальные значения по умолчанию, равные 0.

Значение локальной переменной доступно только внутри функции, где оп-ределена эта переменная. Ее значение нельзя получить с помошыо непосред-ственного доступа извне этой функции.

Вернемся к нашему примеру. После определения локальных переменных в функции вычисляется треугольное число, и результаты выводятся на терминал. Закрывающая фигурная скобка определяет конец функции.

Внутри процедуры main при первом вызове функции calculateTriangularNumber ей передается в качестве аргумента значение 10. После этого управление передается непосредственно в функцию, где значение 10 становится значением формального параметра п внутри этой функции. Затем функция вычисляет значение 10-го треугольного числа и выводит результат.

При следующем вызове calculateTriangularNumber передается аргумент 20. Значение 20 становится значением формального параметра п внутри функции. Затем функция вычисляет значение 20-го треугольного числа и выводит резуль-тат.

### Возвращение результатов функций
Как и методы, функции могут возвращать значение. Тип значения, возвращае-мого с помощью оператора return, должен быть согласован с типом возвращае-мого значения, объявленного для этой функции. В объявлении функции, которое начинается с
```
float kmh_to_mph (float km_speed)
```
содержится определение функции с именем kmh_to_mph, которая принимает один аргумент типа float с именем km_speed и возвращает значение тоже типа float. Аналогичным образом,
```
int ged (int u, int v)
```
определяет функцию ged (наибольший общий делитель) с целыми аргументами и и v и возвращает целое значение.

Мы перепишем алгоритм определения наибольшего общего делителя, ис-пользуемый в программе 5.7, в форме функции. Этой функции передаются два аргумента в виде двух чисел, для которых нужно определить их наибольший общий делитель (ged, greatest common divisor), см. программу 13.5.
```
#import <Foundation/Foundation.h>

// Эта функция ищет наибольший общий делитель двух
// неотрицательных целых значений и возвращает соответствующий результат

int gcd (int u, int v)
{
    int temp;

        while ( v != 0 )
        {
            temp = u % v;
            u = v;
            v = temp;
        }

    return u;
}

main {)
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; int result;
    result = ged (150, 35);
    NSLog (@"The ged of 150 and 35 is %i", result);

    result - ged (1026, 405);
    NSLog (@nThe ged of 1026 and 405 is %i“, result);

    NSLog (<§>nThe ged of 83 and 240 is %Г, ged (83, 240));
    [pool drain];
    return 0;
}
```
Вывод программы 13.5
```
The gcd of 150 and 35 is 5 (Наибольший общий делитель 150 и 35 равен 5)
The gcd of 1026 and 405 is 27
The gcd of 83 and 240 is 1
```
Функция ged принимает два целых аргумента. Данная функция имеет доступ к этим аргументам через имена формальных параметров и и V. После объявления переменной temp типа int программа выводит на терминал значения аргументов и и v вместе с соответствующим сообщением. Затем функция вычисляет и возвращает наибольший общий делитель этих двух целых чисел.

В строке
```
result = gcd (150, 35);
```
происходит вызов функции gcd с аргументами 150 и 35 и сохранение значения, которое возвращает функция, в переменной result.

Если не указан тип возвращаемого значения функции, компилятор предпо-лагает, что функция возвращает целое значение (если она вообще возвращает значение). Многие программисты не указывают тип возвращаемого значения, если функция должна возвращать целые значения. Однако такой подход про-тиворечит практике надежного программирования. Компилятор предупредит, что для возвращаемого значения задан по умолчанию тип int, но это признак того, что вы делаете что-то неверно!

Тип по умолчанию для возвращаемого значения отличается от методов. Если для метода не указан тип возвращаемого значения, компилятор предполагает, что метод возвращает значение типа id. Но для метола тоже следует указывать тип возвращаемого значения.

### Объявление типов возвращаемых значений и типов аргументов
По умолчанию компилятор Objective-C предполагает тип int для возвращаемого значения. Точнее говоря, если вызывается функция, компилятор предполагает, что эта функция возвращает значение типа int, за исключением следующих случаев.
* Эта функция определена в программе до того, как встретился вызов этой функции.
* Значение, возвращаемое функцией, объявлено до того, как встретился вызов этой функции. Объявление типов возвращаемого значения и аргументов для функции называется объявлением прототипа (prototype).

Объявление функции используется не только для объявления типа возвра-щаемого значения функции, но также для того, чтобы указать компилятору, сколько аргументов и каких типов передавать функции. Это аналогично объяв-лению методов в секции @interface при объявлении нового класса.

Чтобы объявить absoluteValue как функцию, которая возвращает значение типа float и при и и мает один аргумент типа float, можно использовать следующее объявление прототипа.
```
float absoluteValue (float);
```
Достаточно указать только тип аргумента в круглых скобках, но не его имя. Вы можете дополнительно указать после типа «фиктивное» имя, например,
```
float absoluteValue (float х);
```
Это имя не обязательно должно совпадать с именем в определении функции (в любом случае, компиля тор его игнорирует).

Для надежности при объявлении прототипа скопируйте первую строку из фактического объявления функции. Не забудьте поставить в конце точку с за-  пятой. Если функция принимает переменное число параметров (как в случае с NSLog и scant), об этом нужно информировать компилятор. Объявление
```
void NSLog (NSString *format, ...);
```
указывает компилятору, что NSLog принимает объект типа NSString в качестве первого аргумента, после которого следует любое число дополнительных аргу-ментов. NSLog объявляется в специальном файле Foundation/Foundation.h , и поэтому в начале каждой программы мы помещаем строку
```
#import <Foundation/Foundation.h>
```
Без этой строки компилятор может предполагать, что NSLog принимает фиксированное число аргументов, что может привести неверному генерируе-мому коду.

Компилятор автоматически преобразует числовые аргументы в соответствующие типы при вызове функции, если вы поместили определение функции или объявили функцию и ее ар1ументы до этого вызова.

Ниже приводятся некоторые сведения о функциях.
* По умолчанию компилятор предполагает, что функция возвращает значение типа int.
* Определяя функцию с возвращаемым значением типа int, определите ее та-ким же образом.
* Определяя функцию, которая не возвращает никакого значения, определите ее с ключевым словом void.
* Компилятор преобразует аргументы для согласования с аргументами, кото-рые ожидает функция, только если вы ранее определили или объявили эту функцию.
Для надежности объявляйте все функции в своей программе, даже если они определены до их вызова. Лучше всего поместить объявления ваших функций в header-файл и затем просто импортировать этот файл в ваши модули.

Функции по умолчанию являются внешними (external). Область действия по умолчанию для функции устроена так, чтобы ее могли вызывать любые функции или методы, содержащиеся в любых файлах, которые связаны с этой функцией. Вы можете ограничить область действия функции, сделав ее статической. Для этого нужно поместить перед объявлением функции ключевое слово static, как показано ниже.
```
static int ged (int u, int v)
{
    ...
}
```
Статическую функцию могуг вызывать только другие функции или методы, которые находятся в одном файле с определением этой функции.

### Функции, методы и массивы
Чтобы передать функции или методу один элемент массива, его нужно указать как аргумент. Например, если функция squareRoot вычисляет квадратные корни, и мы хотим получить квадратный корень от averages[i] и присвоить результат переменной sq_root_result. то можно написать оператор
```
sq_root_result = squareRoot (averagesfi]);
```
Передача всего массива функции или методу выполняется иначе. При вызове функции или метода нужно указать только имя этого массива (без индексов). Например, если grade_scores был объявлен как массив, содержащий 100 эле-ментов, выражение
```
minimum (grade_scores)
```
будет передавать все 100 элементов, содержащихся в массиве grade_score$, функции с именем minimum. Конечно, функция minimum должна ожидать передачи всего массива как ар|умента и иметь соответствующее объявление формального параметра.

Следующая функция ищет минимальное целое значение в массиве с ука-занным количеством элементов.
```
// Функция для поиска минимума в массиве
int minimum (int values[], int numElements)
{
    int minValue, i;
    minVaiue = values[0];
    for (i = 1; i < numBements; ++i)
        if ( values[i] < minValue )
            minValue = values[i];
    return (minValue);
}
```
В соответствии с определением, функция minimum принимает два аргумента. Первый аргумент — это массив, минимум значений которого мы хотим найти, а второй аргумент — это число элементов в данном массиве. Прямоугольные скобки, которые непосредственно следуют после values в заголовке функции, информируют компилятор Objective-C, что values — это массив с целыми значе-ниями. Компилятору не нужен размер этого массива.

Формальный параметр numElements используется как верхний предел в опе-раторе for. С помощью оператора for выполняется перебор всего массива от элемента values[1] до последнего элемента vaiues[numElements-1].

Если функция или метод изменяет значение элемента массива, это изменение вносится в исходный массив, переданный функции или методу. Это изменение остается в силе даже после того, как функция или метод закончит свое выполнение.

Работа с целым массивом происходит иным образом, чем с простой пере-менной или элементом массива (значения которых функция или метод не может изменить). Мы уже говорили, что при вызове функции или метода значения, передаваемые как аргументы, копируются в соответствующие формальные параметры, но при работе с массивами содержимое всего массива не копируется R массив формального параметра. Вместо этого передается указатель, пока-зывающий, где в памяти компьютера размещен этот массив. Таким образом, любые изменения, внесенные в массив формального параметра, на самом деле вносятся в исходный массив, а нс в копию этого массива. Поэтому при выходе из функции или метода эти изменения остаются действительными.

### Многомерные массивы
Элемент многомерного массива можно передавать функции или методу как обычную переменную или элемент одномерного массива. В строке
```
result = squareRoot (matrix[i][j]);
```
происходит вызов функции squareRoot с передачей в качестве аргумента значе-ния, содержащегося в matrix[i][j].

В качестве аргумента можно передать весь многомерный массив так же, как одномерный массив: нужно просто указать имя самого массива. Например, если матрица measuredValues объявлена как двумерный массив с целыми значениями, то оператор Objective-C
```
scalarMultipiy (measuredValues, constant);
```
можно использовать для вызова функции, которая умножает каждый элемент этой матрицы на значение константы. Из этого, конечно, следует, что сама фун-кция может изменять значения, содержащиеся в массиве measuredValues. Все, что говорилось выше об одномерных массивах, применимо и к многомерным массивам. Изменения, вносимые внутри функции в любой элемент массива фор-мального параметра, являются также изменениями в массиве, который был передан функции.

Мы уже говорили, что в случае объявления одномерного массива как фор-мального параметра нам не нужен конкретный размер массива. Мы просто ис-пользуем пару прямоугольных скобок, чтобы информировать компилятор Objective-C, что параметр является массивом. В случае многомерных массивов это применимо лишь отчасти. Для двумерного массива можно не указывать число строк массива, но объявление должно содержать число столбцов массива. Оба объявления
```
int arrayValues[100][50]
```
и
```
int arrayValues[][50]
```
являются допустимыми для массива формального параметра с именем arrayValues, который содержит 100 строк и 50 столбцов. Однако оба объявления
```
int arrayValues[100][]
```
и
```
int arrayValues[][]
```
не являются допустимыми, поскольку необходимо указать число столбцов мас-сива.

## 13.3. Структуры
Помимо массивов, язык Objective-C содержит еще одно средство группирования элементов — структуры.

Предположим, что нам нужно нам нужно сохранить внутри программы дату (например, 18/07/09), чтобы использовать ее для заголовка результатов программы или для вычислений. Обычный способ сохранения даты — это присвоить месяц целой переменной с именем month, день — целой переменной day и год — целой переменной year. Поэтому здесь вполне подойдут операторы
```
int month = 7, day = 18, year = 2009;
```
Но как быть, если в программе требуется сохранять несколько дат? Следо-вало бы сгруппировать эти наборы из трех переменных.

В языке Objective-C мы можем определить структуру с именем date (дата), которая состоит из трех компонентов, представляющих месяц, день и год. Син-таксис такого определения достаточно очевиден.
```
struct date
{
    int month;
    int day;
    int year;
};
```
Только что определенная структура date содержит три целых компонента с именами month, day и year. Такое определение даты — новый тип переменных, переменные теперь можно объявлять с типом struct date, как в следующем опре делении:
```
struct date today;
```
Мы можем определить переменную такого же типа purchaseDate (дата покупки) с помощью отдельного определения
```
struct date purchaseDate;
```
или просто включить оба определения в одну строку: struct date today, purchaseDate;

В отличие от переменных типа int, float или char, при работе со структурными переменными требуется специальный синтаксис. Для доступа к компоненту структуры нужно указать имя структурной переменной, после которого следует точка (она называется оператором «точка» — dot operator) затем имя компо
нента структуры. Например, чтобы задать значение 21 для компонента day переменной today, нужно написать
```
today.day = 21;
```
Отметим, что между именем переменной, точкой и именем компонента не допускаются пробелы.

Вы можете возразить, что мы уже использовали, казалось бы, такой же опе-ратор для вызова свойства объекта. Вспомним, что оператор
```
myRect.width = 12;
```
вызывает метод-установщика (с именем sefWidth) объекта класса Rectangle, передавая ему значение аргумента 12. Здесь нет никакой путаницы: компилятор сам определяет, что находится справа от оператора «точка», — структура или объект, — и выполняет соответствующую обработку.

Вернемся к примеру struct date, чтобы задать значение 2010 для компонента year в структуре today.
```
today.year = 2010;
```
И, наконец, чтобы проверить, что значение month равно 12, можно исполь-зовать оператор
```
if (today, month == 12 )
    next_month = 1;
```
В программе 13.6 реализуется то, что мы обсуждали выше.
```
#import <Foundation/Foundation.h>
int main (int arge, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    struct date
    {
        int month;
        int day;
        int year;
    };

    struct date today;

    today.month = 9;
    today.day = 25;
    today.year = 2009;

    NSLog (@"Today’s date is %i/%i/%.2i.", today.month,
             today.day, today.year % 100);
    [pool drain];
    return 0;
}
```
Вывод программы 13.6
```
Today’s date is 9/25/09. (Текущая дата - 25.9.09)
```
В первом операторе внутри main определяется структура с именем date, которая состоит из трех целых компонентов: month, day и year. Во втором операторе объявляется переменная today с типом struct date. Таким образом, в первом опе-раторе просто определяется, как выглядит структура даты для компилятора Objective-C, и не требуется никакого резервирования памяти внутри компьютера. Во втором операторе объявляется переменная типа struct date, и здесь происходит резервирование памяти для хранения трех целых компонентов структурной переменной today.

После присваивания значений соответствующий вызов NSLog выводит зна-чения, содержащиеся в этой структуре. Вычисляется остаток отделения today.year на 100, поэтому функция NSLog выводит для года только две цифры. Символы формата %.2i в обращении к NSLog указывают вывод не менее двух символов, в результате чего для года выводится ведущий нуль.

При вычислении выражений компоненты структуры подчиняются таким же правилам, что и обычные переменные в языке Objective-C. Деление целого ком-понента структуры на другое целое значение выполняется как деление целых, например
```
century = today.year /100+ 1;
```
Напишем несложную программу, которая принимает на входе текущую дату и выводит завтрашнюю дату (tomorrow). На первый взгляд это кажется совсем простой задачей. Нужно запросить у пользователя ввод текущей даты и затем вычислить завтрашнюю дату с помощью следующего набора операторов.
```
tomorrow.month = today.month;
tomorrow.day = today.day + 1;
tomorrow.year - today.year;
```
Конечно, для большинства дат это подходит, но два случая будут реализованы неверно.
* Текущая дата приходится на конец месяца.
* Текущая дата приходится на конец года (то есть на 3 1 декабря).
Чтобы определить, приходится ли текущая дата на конец месяца, нужно задать массив целых значений, соответствующих числу дней каждого месяца.

Поиск в этом массиве даст число дней месяца (см. программу 13.7).
```
// Программа определения завтрашней даты

#import <Foundation/Foundation.h>
struct date
{
    int month;
    int day;
    int year;
};

// Функция для вычисления завтрашней даты
struct date dateUpdate (struct date today)
{
    struct date tomorrow;
    int numberOfDays (struct date d);

    if (today.day != numberOfDays (today))
    {
        tomorrow.day = today.day + 1;
        tomorrow.month = today.month;
        tomorrow.year = today.year;
    }
    else if (today.month == 12) // end of year
    {
        tomorrow.day = 1;
        tomorrow.month = 1;
        tomorrow.year = today.year + 1;
    }
    else
    {   // конец месяца
        tomorrow.day = 1;
        tomorrow.month = today.month + 1;
        tomorrow.year = today.year;
    }
    return (tomorrow);
}

// Функция для поиска числа дней в месяце

int numberOfDays (struct date d)
{
    int answer;
    BOOL isLeapYear (struct date d); int daysPerMonth[12] =
        { 31,28, 31, 30, 31, 30, 31, 31,30, 31,30, 31 };

    if (isLeapYear (d) == YES && d.month == 2)
        answer = 29;
    else
        answer = daysPerMonth[d. month - 1];
    return (answer);
}

// Функция, определяющая, является ли год високосным
BOOL isleapYear (struct date d)
{
    if ((d.year % 4 == 0 && d.year % 100 != 0) ||
         d.year % 400 == 0 ) return YES; else
    return NO;
}

int main (int argc, char *argv[])
{
    NSAutoreleasePool * poo! = [[NSAutoreleasePool alloc] init];
    struct date datellpdate (struct date today);
    struct date thisDay, nextDay;

    NSLog (@nEnter today’s date (mm dd yyyy):");
    scanf ("%i%i%i", SthisDay.month, SthisDay.day,
        &thisDay.year);

    nextDay = dateUpdate (thisDay);

    NSLog (@"Tomorrow’s date is %i/%i/%.2i.",nextDay.month,
        nextDay .day, nextDay.year % 100);

    [pool drain];
    return 0;
}
```
Вывод программы 13.7
```
Enter today’s date (mm dd yyyy): (Введите текущую дату (мм дд rrrr)
2 28 2012
Tomorrow’s date is 2/29/12. (Завтрашняя дата)
```
Вывод программы 13.7 (повторный запуск)
```
Enter today’s date (mm dd yyyy):
10 2 2009
Tomorrow’s date is 10/3/09.
```
Вывод программы 13.7 (повторный запуск)
```
Enter today’s date (mm dd yyyy):
12 31 2010
Tomorrow’s date is 1/1/10.
```
Хотя мы не работаем в этой программе с классами, здесь был импортирован файл Foundation.!!, поскольку нам нужен тип B00L и определенные имена YES и N0. Они определены в этом файле.

Отметим, что определение структуры данных представлено в первую очередь и вне какой-либо функции. Определения структур данных действуют аналогично переменным. Если структура определена внутри какой-либо функции, только эта функция «знает» о ее существовании, и тогда это локальное определение структуры. Если структура определена вне любой функции, это определение является глобальным. Глобальное определение структуры позволяет объявлять любые последующие переменные (внутри или вне функции) как структуру этого типа. Определения структур, которые используются в нескольких файлах, обычно централизуются водном header-файле и затем импортируются в те файлы, где нужна эта структура.

Внутри процедуры main объявление
```
struct date dateUpdate (struct date today);
```
указывает компилятору, что функция dateUpdate принимает в качестве аргумента структуру типа date и возвращает структуру такого же типа. Это объявление не обязательно, поскольку компилятор уже «видел» конкретное объявление функции в этом файле, но принято в практике надежного программирования. Если вы в дальнейшем разделите определение этой функции и main на отдельные исходные файлы, объявление будет необходимо.

Как и для обычных переменных (но не для массивов), любые изменения, которые вносятся функцией в значения, содержащиеся в аргументе структуры, не оказывают влияния на исходную структуру. Они влияют только на копию этой структуры, которая создастся при вызове функции.

После ввода даты и ее сохранения в структурной переменной thisDay типа date происходит вызов функции dateUpdate.
```
nextDay = dateUpdate (thisDay);
```
Здесь происходит вызов функции dateUpdate с передачей этой функции струк-туры даты thisDay.

Внутри функции dateUpdate объявление прототипа
```
int numberOfDays (struct date d);
```
информирует компилятор Objective-C, что функция numberOfDays возвращает целое значение и принимает один аргумент типа struct date.

Оператор
```
if (today.day != numberOfDays (today))
```
указывает, что структура today должна передаваться как аргумент функции numberOTOays. Внутри этой функции должно быть соответствующее объявление, информирующее систему, что аргументом должна быть структура, как в следующей строке.
```
int numberOfDays (struct date d)
```
Сначала в функции numberOfDays нужно выполнить проверку на високосный год и определить, не является ли месяц февралем. Для первой проверки вызы-вается другая функция с именем isLeapYear.

Функция isLeapYear вполне понятна; она проверяет год, содержащийся в структуре типа date, которая передается как аргумент, и возвращает значение YES в случае високосного года или N0 в противном случае.

Вы должны понять иерархию вызовов функций в программе 13.7. функция main вызывает dateUpdate, которая вызывает numberOfDays, которая, в свою очередь, вызывает функцию isLeapYear.

### Инициализация структур
Инициализация структур аналогична инициализации массивов: значения ком-понентов просто перечисляются в фигурных скобках с применением запятой в качестве разделителя.

Чтобы инициализировать переменную today структуры типа date, задав зна-чение Июль, 2 число, 20П год, можно использовать оператор
```
struct date today = { 7, 2, 2011 };
```
Как и при инициализации массива, можно указывать значения не для всех компонентов структуры. Например, в операторе
```
struct date today = {7 };
```
задается значение 7 для компонента today.month, но не задаются начальные зна-чения для today.day и today.year. В таких случаях начальные значения по умолча-нию не определены.

Для конкретных компонентов можно выполнять инициализацию в любом порядке, используя в списке инициализации форму записи
```
.компонент = значение
```
например,
```
struct date today = {.month = 7, .day = 2, .year = 2011 };
```
и
```
struct date today = {.year = 2011 };
```
В последнем примере этой структуры задается только значение года, равное 2011. Остальные два компонента не определены.

### Массивы структур
Работа с массивами структур не представляет особых сложностей. Например, в
```
struct date birthdays[15];
```
определяется массив birthdays (дни рождения), содержащий 1 S элементов типа Struct date. Нужный элемент в массиве структур указывается естественным образом. Например, чтобы задать для второго элемента в массиве birthdays дату дня рождения 22 февраля 1996 г., можно написать последовательность
```
birthdays[1].month = 2;
birthdays[1]. day = 22;
birthdays[1].year = 1996;
```
Оператор
```
n = numberOfDays (birthdaysfO]);
```
передает первый элемент этого массива функции numberOfDays, чтобы опреде-лить, сколько дней содержит указанный в дате месяц.

### Структуры внутри структур
Objective-C предоставляет большие возможности в определении структур. На-пример, можно определить структуру, содержащую в качестве своих компонен-тов другие структуры, или определять структуры, содержащие массивы.

Вы уже видели, как логически группировать месяц, день и год (month, day и year) в структуре с именем date. Предположим, что у нас есть аналогичная струк-тура с именем time для группирования часов, минут и секунд (hour, minutes и seconds). В некоторых приложениях может потребоваться логическая группи-ровка структур date и time — например, для списка событий с определенной датой и временем.

Из предыдущего описания следует, что нам нужны удобные средства, объе-диняющие дату и время. Это можно сделать в Objective-C, определив новую структуру (например, date_and_time), компоненты которой содержатся в элементах date и time.

```
struct date_and_time
{
    struct date sdate;
    struct time stime;
};
```
Первый компонент этой структуры имеет тип struct date и называется sdate. Второй компонент структуры date_and_time имеет тип struct time и называется stime. В этом определении структуры date_and_time требуется, чтобы структура date и структура time были предварительно определены для компилятора.

Теперь можно определять переменные типа struct date_and_time:
```
struct date_and_time event;
```
Для указания ссылки на структуру date в переменной event используется тот же синтаксис:
```
event.sdate
```
Мы можем вызвать функцию dateUpdate, указав дату в качестве аргумента, чтобы получить результат в том же месте.
```
event.sdate = dateUpdate (event.sdate);
```
То же самое можно сделать для структуры time, содержащейся в структуре date_and_time.
```
event.stime = timeUpdate (event.stime);
```
Для указания определенного компонента внутри одной из этих структур нужно добавить точку и имя этого компонента:
```
event.sdate.month = 10;
```
В этом операторе задается значение 10 (октябрь) для компонента month структуры date переменной event. В операторе
```
++event.stime.seconds;
```
значение компонента seconds структуры time увеличивается на 1.

Инициализировать переменную event можно уже известным способом:
```
struct date_and_time event =
{{ 12, 17, 1989 }, { 3, 30,0}};
```
Здесь для переменной event задается дата 17 декабря 1989 г. и время 3:30:00.

Массив структур date_and_time можно задать с помощью объявления
```
struct date_and_time events[100];
```
Здесь объявляется, что массив events содержит 100 элементов типа struct date_and_time. Для указания 4-го элемента date_and_time в массиве нужно написать events[3], а для 25-й даты в массиве при обращении к функции dateUpdate нужно написать
```
events[24].sdate = dateUpdate (events[24].sdate);
```
Чтобы записать 12 часов дня в первый элемент этого массива, применяется следующий набор операторов.
```
events[0].stime.hour = 12;
events[0].stime.minutes = 0;
events[0].stime.seconds = 0;
```

### Дополнительно о структурах
Определять структуру можно достаточно гибко. Во-первых, можно объявить переменную с определенным структурным типом одновременно с объявлением структуры. Для этого достаточно включить имя переменной (переменных) с завершающей точкой с запятой в определение структуры. Например, в следую-щем операторе определяется структура date и объявляются переменные todaysDate и purchaseDate этого типа.
```
struct date
{
    int month;
    int day;
    int year;
} todaysDate, purchaseDate;
```
Вы можете присвоить этим переменным начальные значения обычным об-разом. Ниже определяется структура date и переменная todaysDate с указанием начальных значений.
```
struct date
{
    int month;
    int day;
    int year;
} todaysDate = { 9, 25, 2010 };
```
Если все переменные определенного структурного типа определяются вместе с определением структуры, то можно не задавать имя структуры. Ниже оп-ределяется массив с именем dates, содержащий 100 элементов.
```
struct
{
    int month;
    int day;
    int year;
} dates[ 100);
```
Каждый элемент является структурой, содержащей три целых компонента: month, day и year. Поскольку здесь не указывается имя структуры, при последующем объявлении переменных того же типа структуру придется явно определить снова.

### Битовые поля
В Objective-C имеются два способа упаковки информации. Первый способ — это представление данных внутри переменной целого типа и последующий доступ к нужным битам с помощью побитовых операций, описанных в главе 4.

Второй способ — это определение структуры упакованной информации с помощью конструкции Objective-C, которая называется битовым полем (bitfield). Для этого применяется специальный синтаксис в определении структуры, по-зволяющий определять поле битов и присваивать ему имя.

Для определения битовых полей можно определить структуру, например, с именем packedStruct.
```
struct packedStruct
{
    unsigned int f1:1;
    unsigned int f2:1;
    unsigned int f3:1;
    unsigned int type:4;
    unsigned int index:9;
}
```
В соответствии с этим определением, структура packedStruct состоит из пяти компонентов. Первый компонент, Н, имеет тип unsigned int. Обозначение :1 после имени компонента указывает, что компонент будет содержаться в 1 бите. Флаги f2 и f3 определяются аналогичным образом. Компонент type занимает в соответствии с определением 4 бита, а компонент index имеет длину 9 битов.

Компилятор автоматически упаковывает подряд эти битовые поля. Удобство этого подхода состоит в том, что поля переменной типа packedStruct можно указывать как обычные компоненты структуры. Например, если объявлена пе-ременная packedData
```
struct packedStruct packedData;
```
вы можете легко присвоить значение 7 полю type переменной packedData с по-мощью простого оператора
```
packedData.type = 7;
```
Можно присвоить этому полю значение переменной п с помощью оператора
```
packed Data.type = n;
```
В последнем случае вы можете не думать о том, что значение п может ока-заться слишком большим, чтобы уместиться в поле type; в packedData.type будут записаны только младшие 4 бита.

Извлечь значение из битового поля тоже непрудно. Например, с помощью оператора
```
n = packedData.type;
```
извлекается значение поля type переменной packedData (с автоматическим сме-щением в младшие биты, если это требуется), которое присваивается перемен-ной n.

Битовые поля можно использовать в обычных выражениях и автоматически преобразовывать их в целые значения. Например, оператор
```
i = packed Data. index / 5 + 1;
```
является вполне допустимым, как и оператор
```
if (packedData.f2)
```
Проверка, установлен ли флаг f2. Мы не можем точно сказать, как заполня-ются битовые поля, — слева направо или справа налево. Если они заполняются справа налево, то П будет находиться в позиции младшего бита, f2 - в битовой позиции непосредственно слева от fl, ит.д. Это не представляет проблемы, если вы не работаете с данными, которые созданы другой программой или на другой машине.

Вы можете включать обычные типы данных в структуру, содержащую бито-вые поля. Например, если нужно определить структуру, содержащую типы int, char и два 1-битовых флага, можно использовать следующее определение.
```
struct table_entry
{
    int count;
    char c;
    unsigned int f1:1;
    unsigned int f2:1;
};
```
Битовые поля упаковываются в блоки (unit) в соответствии с порядком их следования в определении структуры, причем размер блока определяется реа-лизацией и, скорее всего, является словом. Компилятор Objective-C нс изменяет определения битовых полей, пытаясь уменьшить размер используемого про-странства.

Можно задавать битовое поле без имени, чтобы пропускать биты внутри слова. Ниже определяется структура x_entry, которая содержит 4-битовос поле с именем type и 9-битовое поле с именем count.
```
struct x_entry
{
    unsigned int type:4;
    unsigned int :3;
    unsigned int count:9;
};
```
Поле без имени указывает, что поле type отделяется от поля count 3 битами.

Особым случаем является использование неименованного поля длиной 0. Его можно использовать, чтобы принудительно выровнять следующее поле в структуре с началом границы блока.

### Не забывайте об объектно-ориентированном программировании!
Теперь вы знаете, как определить структуру для хранения даты, и умеете писать процедуры для работы со структурой даты, А как быть с объектно-ориентиро-ванным профаммированием? Ведь вместо этого можно создать класс с именем Date и затем разработать методы для работы с объектами типа Date. Конечно, такой подход будет лучше. Несомненно, при работе с большим числом дат в программах определение класса и методов для работы с датами является более подходящим. Для таких целей Foundation framework содержит пару классов с именами NSDate и NSCatendarDate. Реализацию класса Date для работы с датами как с объектами, а не структурами мы оставляем вам в качестве упражнения.

## 13.4. Указатели
Указатели (Pointer) позволяют эффективно представлять сложные структуры данных, изменять значения, передаваемые в виде аргументов функциям и методам, а также проще и эффективнее работать с массивами. В конце этой главы мы расскажем, насколько они важны для реализации объектов в языке Objective-C.

Мы ввели понятие объекта в главе 8, когда описывали классы Point и Rectangle, и упомянули, что можно иметь несколько ссылок на один объект.

Чтобы понять, как действуют указатели, вы должны сначала ознакомиться с понятием косвенного обращения (indirection). Мы часто встречаемся с этим по-нятием в повседневной жизни. Предположим, мне нужно купить новый картридж с тонером для моего принтера. В компании, где я работаю, все приобретения выполняются через отдел снабжения, поэтому я звоню сотруднику этого отдела и прошу заказать для меня новый картридж. Он звонит в местный магазин запчастей, чтобы заказать картридж. Для получения картриджа я применяю косвенный подход вместо прямого заказа картриджа в магазине.

Понятие косвенного подхода можно применить и к указателям в Objective- С. Указатель — это средство косвенного доступа к значению определенного эле-мента данных. Расмотрим, как действуют указатели. Орсделим переменную с именем count
```
int count = 10;
```
С помощью следующего объявления мы можем определить другую переменную с именем intPtr для косвенного доступа к значению переменной count.
```
int *intPtr;
```
Звездочка показывает, что переменная intPtr является указателем на тип int. Это означает, что программа будет использовать intPtr для косвенного доступа к значению одной или нескольких целых переменных.

Мы уже использовали в предыдущих программах оператор & при обращении к scant. Этот унарный оператор, который называют адресным (address) опе-ратором, создает указатель на переменную в Objective-C. Например, если х — переменная определенного типа, то выражение &х является указателем на эту переменную. Если нужно, вы можете присвоить выражение &х любой перемен-ной-указателю, объявленной как указатель на тип, который имеет переменная х. Оператор
```
intPtr = &count; 
```
задаст косвенную связь между intPtr и count. Адресный оператор 8 присваивает переменной intPtr не значение переменной count, а указатель на переменную count. На рис. 13.1 показана связь между intPtr и count. Линия со стрелкой показывает, что intPtr содержит не само значение count, а указатель на переменную count.

![](images/fig13_1.png)

Рис. 13.1. Указатель на переменную целого типа

Чтобы указать содержимое count с помощью переменной-указателя intPtr, ис-пользуется оператор косвенного обращения «звездочка» (*). Если переменная х была определена с типом int, то оператор
```
х = *intPtr;
```
присвоит переменной х значение, которое указывается путем косвенного обра-щения через intPtr. Поскольку выше мы задали, что intPtr указывает на переменную count, результатом этого оператора будет присваивание переменной х значения, содержащегося в переменной count (10).

В программе 13.8 показано использование двух основных операторов для указателей: адресного оператора (&) и оператора косвенного обращения (*).
```
// Программа, показывающая использование указателей

#import <Foundation/Foundation.h>

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    int count = 10, x;
    int *intPtr;

    intPtr = &count;
    x = *intPtr;

    NSLog (@"count = %i, x = %i", count, x);

    [pool drain];
    return 0;
}
```
Вывод программы 13.8
```
count = 10, x = 10
```
Переменные count и x объявляются обычным образом как целые переменные. В следующей строке переменная intPtr к объявляется ак «указатель на тип int». Эти две строки можно было бы объединить в одну: 
```
int count = 10, х, *intPtr;
```
После этого к переменной count применяется адресный оператор (&), результатом которого является создание указателя на эту переменную, который затем присваивается переменной intPtr.

Выполнение строки
```
х = *intPtr;
```
происходит следующим образом. Оператор косвенного обращения (*) сообщает системе Objective-C, что переменная intPtr содержит указатель на другой элемент данных. Этот указатель используется для доступа к нужному элементу данных, тип которого задан при объявлении переменной-указателя. При объявлении переменной мы сообщили компилятору, что переменная intPtr указывает на целые элементы данных, поэтому компилятор «понимает», что значение, указываемое выражением *intPtr, является целым. Кроме того, в предыдущей строке мы задали, что intPtr указывает на целую переменную count, поэтому это выражение представляет косвенный доступ к значению count.

В программе 13.9 иллюстрируются некоторые интересные свойства пере-менных-указателей. В ней используется указатель на символ.
```
#import <Foundation/Foundation.h>
int main (int arge, char *argv[])
{
    NSAutoreleasePooi * pool = [[NSAutoreleasePool alloc] init];
    char c = “Q";
    char *charPtr = &c;

    NSLog (@"%c %c", c, *charPtr);

    c = '/';
    NSLog (@"%c %c", c, *charPtr);

    *charPtr = T;
    NSLog (@“%c %c", c, *charPtr);

    [pool drain];
    return 0;
}
```
}
Вывод программы 13.9
```
QQ
//
((
```
Символьная переменная с определяется и инициализируется со значением 'Q'. В следующей строке этой программы определяется переменная charPtr как «указатель на тип char». Это означает, что любое значение, сохраняемое внутри этой переменной, следует интерпретировать как косвенное обращение (указатель) к символу. Этой переменной можно присвоить начальное значение обычным образом. В этой программе переменной charPtr присваивается указатель на переменную с, и для этого к переменной с применяется адресный оператор &. (Эта инициализация приведет к появлению ошибки компилятора, если определить с после этого оператора, поскольку любая переменная должна быть объявлена раньше ссылки на эту переменную в любом выражении.)

Объявление переменной charPtr и присваивание ее начального значения можно было бы представить в двух отдельных строках
```
char *charPtr;
charPtr = &с;
```
(Но не
```
char *charPtr;
*charPtr = &с;
```
как можно было бы предположить из объявления в одной строке.)

Значение указателя в Objective-C не существует, пока мы не зададим, на какой элемент данных он указывает.

В строке первого вызова NSLog выводится содержимое переменной с и со-держимое этой переменной, указанное с помощью charPtr. Поскольку мы задали, что charPtr указывает на переменную с, выводится и содержимое с, что под-тверждается первой строкой вывода программы.

В следующей строке профаммы символьной переменной с присваивается символ '/\ Поскольку charPtr по-прежнему указывает на с, в следующем вызове NSLog для значения *charPtr на терминал выводится новое значение переменной с. Это важно. Если значение charPtr не изменяется, то выражение *charPtr всегда означает доступ к значению с. Таким образом, если изменяется значение пере-менной с, то изменяется и значение выражения *charPtr.

Мы говорили, что если значение charPtr не изменено, то выражение *charPtr всегда является ссылкой на значение с. Поэтому в выражении
```
*charPtr = '(';
```
переменной с присваивается символ «левая круглая скобка». Более формально символ '(' присваивается переменной, на которую указывает charPtr. Мы знаем, что это переменная с, поскольку в начале профаммы мы присвоили charPtr указатель на с.

Эти концепции являются ключом к пониманию действия указателей. Про-думайте их снова, если что-то осталось неясным.

### Указатели и структуры
Мы определил указатель для базовых типов данных, таких как int или char. Можно определить указатель и на структуру. Выше в этой главе мы определили структуру dale.
```
struct date
{
    int month;
    int day;
    int year;
};
```
Мы определили переменные типа struct date, например, struct date todaysDate;

Мы можем также определить переменную-указатель на переменную типа struct date:
```
struct date *datePtr;
```
Переменная datePtr может, например, указывать на переменную todaysDate с помощью оператора присваивания
```
datePtr = StodaysDate;
```
После этот присваивания можно осуществлять косвенный доступ к любому из компонентов структуры date:
```
(*datePtr).day = 21;
```
С помощью указателя datePtr в этом операторе задается значение дня струк-туры date, равное 21. Здесь нужны круглые скобки, поскольку оператор «точка» для компонента структуры имеет более высокий приоритет, чем оператор кос-венного обращения *.

Чтобы проверить значение месяца (month), хранящееся в структуре date, на которую указывает datePtr, можно использовать оператор
```
if ((*datePtr).month == 12 )
```
Указатели на структуры используются настолько часто, что для них в языке имеется специальный оператор. Оператор указателя структуры -> (знаки «минус» и «больше») позволяет записывать выражения
```
(*х).у
```
в более понятном виде:
```
х->у
```
Таким образом, предыдущий оператор if можно записать в виде
```
if (datePtr->month == 12)
```
Перепишем программу 13.6, где впервые показали использование структур, с применением указателей структур (программа 13.10).
```
// Программа, показывающая использование указателей структур
#import <Foundation/Foundation.h>

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    struct date
    {
        int month;
        int day;
        int year;
    };

    struct date today, *datePtr;

    datePtr = &today;
    datePtr->month = 9;
    datePtr->day = 25;
    datePtr->year = 2009;

    NSLog (@"Today's date is %i/%i/%.2i.",
        datePtr->month, datePtr->day, datePtr->year % 100);

    (pool drain];
    return 0;
}
```
Вывод программы 13.10
```
Today's date is 9/25/09. (Текущая дата - 25.9.09)
```

### Указатели, методы и функции
Вы можете передавать указатель как аргумент методу или функции. Метод или функция может возвращать результат в виде указателя. Кстати, именно это про-исходит с методами alloc и init: они возвращают указатели. Более подробно мы обсудим этот вопрос в конце главы. А теперь рассмотрим программу 13.11.
```
// Указатели как аргументы, передаваемые функциям
#import <Foundation/Foundation.h>
void exchange (int *pint1, int *pint2)
{
    int temp;

    temp = *pint1;
    *pint1 = *pint2;
    *pint2 = temp;
}

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    void exchange (int *pint1, int *pint2);
    int И = -5, i2 = 66, *p1 = &i1, *p2 = &i2;

    NSLog (@"i1 = %i, i2 = %i", i1, i2);

    exchange (p1, p2);
    NSLog (@"i1 = %i, i2 = %i", i1, i2);

    exchange (&i1, &i2);
    NSLog (@"i1 = %i, i2 = %i", i1, i2);

    [pool drain];
    return 0;
}
```
Вывод программы 13.11
```
i1 =-5, i2 = 66
i1 = 66, i2 = -5
i1 = -5, i2 = 66
```
Функция exchange выполняет обмен значений двух целых переменных, на которые указывают два ее аргумента. Внутри функции локальная целая переменная temp сохраняет одно из целых значений во время выполнения обмена. Ей присваивается целое значение, на которое указывает pintl. Затем целое значение, на которое указывает pint2, копируется в целую переменную, на которую указывает pintl. После этого значение temp сохраняется в целой переменной, на которую указывает pint2, и обмен значениями завершается.

В процедуре main определяются целые переменные И и i2 со значениями -5 и 66 соответственно. Затем определяются два указателя на тип int (pi и р2), которые указывают соответственно на И и 12. Программа выводит значения И и i2 и вызывает функцию exchange, передавая в качестве аргументов эти указатели (р1 и р2). Функция exchange выполняет обмен значения, содержащегося в целой пе-ременной, на которую указывает pi, со значением, содержащимся в целой пе-ременной, на которую указывает р2. Поскольку р1 указывает на il и р2 на i2, функция exchange обменивает местами значения И и i2. Вывод с помошью второго вызова NSLog показывает, что обмен выполняется правильно.

Второй вызов exchange выглядит несколько интересней. На этот раз аргумен-ты, передаваемые функции, являются указателями на И и i2, которые создаются непосредственно при обращении в результате применения к этим переменным адресного оператора &. Поскольку выражение &И представляет указатель на целую переменную И, это согласуется с типом первого аргумента для функции (указатель на целое значение). То же самое относится ко второму аргументу. Вывод этой программы показывает, что функция exchange правильно выполнила свою работу и обменяла значения И и i2.

Внимательно изучите программу 13.11. Она показывает ключевые концепции работы с указателями в Objective-C.

### Указатели и массивы
Если имеется массив с именем values, содержащий 100 целых элементов, то с помощью следующей строки можно определить указатель с именем valuesPtr, который можно использовать для доступа к целым элементам, содержащимся в этом массиве.
```
int *valuesPtr;
```
Определяя указатель, который будет использоваться для указания элементов массива, мы не определяем его как «указатель на массив». Он определяется как указатель на тип элементов, содержащихся в массиве.

Если имеется массив tracts с объектами класса Fraction, то с помощью следующего оператора можно определить указатель на элементы массива tracts:
```
Fraction **fractsPtr;
```
Такое же объявление используется для определения любого объекта класса Fraction.

Чтобы valuesRr указывал на первый элемент массива values, достаточно напи-сать строку
```
valuesPtr = values;
```
В данном случае адресный оператор & не используется, поскольку компилятор Objective-C интерпретирует появление имени массива без индекса как указатель на первый элемент этого массива. Таким образом, мы получаем указатель на первый элемент массива values.

Эквивалентный способ создать указатель на начало массива values — приме-нить адресный оператор & к первому элементу этого массива:
```
valuesPtr = &values[0];
```
Чтобы вывести содержащийся в массиве tracts объект класса Fraction, на кото-рый указывает fractsPtr, нужно написать оператор
```
[*fractsPtr print];
```
Реальные возможности применения указателей к массивам начинают дей-ствовать при необходимости перебора элементов массива. Если указатель valuesPtr определен, как описано выше, и указывает на первый элемент массива values, то для доступа к первому элементу массива values (то есть values[0]) можно использовать выражение
```
*valuesPtr
```
Для доступа к values[3] с помощью переменной valuesPtr можно добавить 3 к valuesPtr и затем применить оператор косвенного доступа.
```
*(valuesPtr + 3)
```
Таким образом, доступ к значению, содержащемуся в values[i], дает выраже-ние
```
*(valuesPtr + i)
```
Например, чтобы присвоить элементу values[10] значение 27, можно написать следующее выражение
```
values[10] = 27;
```
Или, используя valuesPtr, можно написать
```
*(valuesPtr + 10) = 27;
```
Чтобы valuesPtr указывал на второй элемент массива values, нужно применить адресный оператор & к values[1] и присвоить результат переменной valuesPtr:
```
valuesPtr = &values[1];
```
Если valuesPtr указывает на values[0], и нужно сделать так, чтобы он указывал на values[1], достаточно добавить 1 к значению valuesPtr:
```
valuesPtr += 1;
```
Это вполне допустимое выражение в Objective-C, его можно использовать для указателей на любой тип данных.

В общем случае, если а — массив элементов типа х, рх — указатель на х, i и п — целые константы, то в выражении
```
рх = а;
```
рх указывает на первый элемент а, и выражение
```
*{рх + i)
```
дает доступ к значению, содержащемуся в a[i]. Кроме того, в выражении
```
рх += п;
```
рх указывает на п следующих элементов в массиве, независимо от их типа данных.

Предположим, что fractsPtr указывает на дробь (fraction), содержащуюся в массиве дробей. Ее нужно сложить с дробью, содержащейся в следующем элс- менте этого массива, и прис воить результат объекту result класса Fraction. Для этого можно написать:
```
result = [*fractsPtr add: *(fractsPtr +1)];
```
Операторы приращения (++) и уменьшения (—) особенно удобны при работе с указателями. Применение к указателю оператора (++) дает такой же результат, как прибавление к указателю 1, а оператор уменьшения (—) действует также, как вычитание 1 из указателя. Таким образом, если textPtr определен как указатель на тип char и указывает на начало массива элементов типа char с именем text, то в результате оператора
```
++textPtr;
```
textPtr будет указывать на следующий си мвол в массиве text, то есть на text[1 ]. Аналогичным образом, в результате оператора
```
--textPtr;
```
textPtr будет указывать на предыдущий символ в массиве text (если, конечно, textPtr не указывал на начало массива text перед выполнением этого оператора).

В Objective-C вполне допустимо сравнение двух переменных-указателей. Это особенно полезно при сравнении двух указателей на элементы одного массива. Так можно убедиться, что указатель valuesPtr не указывает дальше конца массива, содержащего 100 элементов. Для этого нужно сравнить этот указатель с ука-зателем на последний элемент массива. Например, выражение
```
valuesPtr > &values[99]
```
будет иметь значение TRUE (ненулевое значение), если valuesPtr указывает даль-ше последнего элемента массива values, и будет иметь значение FALSE (нулевое значение) в противном случае. В соответствии с предыдущим описанием мы можем заменить это выражение на его эквивалент
```
valuesPtr > values + 99
```
values без индекса — это указатель на начало массива values. (Эквивалентно &values[0].)

В программе 13.12 показано использование указателей на массивы. Функция arraySum вычисляет сумму целых элементов, содержащихся в массиве.
```
// Функция для вычисления суммы элементов, содержащихся в массиве целого типа
#import <Foundation/Foundation.h>

int arraySum (int array[], int n)
{
    int sum = 0, *ptr;
    int *arrayEnd = array + n;

    for ( ptr = array; ptr < array End; ++ptr)
        sum += *ptr;

    return (sum);
}

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    int arraySum (int array[], int n);
    int values[10] = { 3, 7, -9, 3,6, -1, 7, 9, 1, -5 };

    NSLog (@"The sum is %i", arraySum(values, 10));
    [pool drain];
    return 0;
}
```
Вывод программы 13.12
```
The sum is 21 (Сумма равна 21)
```
Внутри функции arraySum определен указатель arrayEnd на тип int, который указывает «ячейку» непосредственно вслед за последним элементом массива. За-тем для последовательного перебора элементов массива используется цикл for. При входе в цикл ptr указывает на начало массива. На каждом шаге цикла к сумме прибавляется элемент массива, на который указывает ptr. Затем в цикле for значение ptr наращивается, чтобы указывать на следующий элемент массива. Когда ptr указывает «ячейку» после конца массива, происходит выход из цикла for, и значение sum возвращается вызывающей процедуре.

### Это массив или это указатель?
Чтобы передать массив функции, нужно просто передать имя этого массива, как при вызове функции arraySum. Но мы говорили, что для создания указателя на массив достаточно задать имя этого массива. Из этого следует, что при вызове функции arraySum функции передается указатель на массив values. Именно это и происходит, поэтому мы можем изменять элементы массива внутри функции.

Но если функции перелается указатель на массив, то почему формальный параметр внутри функции не объявлен как указатель? Иначе говоря, почему при объявлении array в функции arraySum не используется следующее объявление:
```
int *array;
```
Не следует ли все обращения к массиву вну три функции выполнять с помо-щью переменных-указателей?

Чтобы ответить на эти вопросы, мы должны сначала вернуться к тому, что уже говорили об указателях и массивах. Если valuesPtr указывает на тип элемента, содержащегося в массиве с именем values, то выражение *(valuesPtr + i) эквива-лентно выражению valuesfi] в предположении, что valuesPtr сначала указывал на начало массива values. Из этого следует, что мы можем использовать выражение *(values + i) для обращения к i-му элементу массива values. В общем случае, если х — массив любого типа, то выражение x[i] всегда можно записать в эквивалентной форме *{х + i).

Как видите, указатели и массивы тесно связаны друг с другом, и поэтому внутри функции arraySum можно объявить массив как «массив целых значений (типа int)» или как «указатель на тип int».

Если использовать индексы для доступа к элементам массива, то соответ-ствующий формальный параметр нужно объявить как массив. Если использовать аргумент как указатель на массив, то его нужно объявить как указатель.

### Указатели на символьные строки
Чаще всего указатель на массив используется как указатель на символьную стро-ку. Чтобы показать, насколько просты в работе указатели на символьные строки, напишем функцию с именем copyString для копирования одной строки в другую. Используя обычные методы написания такой функции с помощью индексирования массивов, можно составить следующий код:
```
void copyString (char to[], char from[])
{
    int i;
    for (i = 0; fromp] != '\0'; ++i)
        to[i] = from[i];
    to[i] = '\0';
}
```
Выход из цикла for происходит в тот момент, когда обнаруживается нуль- символ, что и делает последний оператор в этой функции.

Если написать функцию copyString с использованием указателей, то индексная переменная i не нужна. Версия с указателями показана в программе 13.13.
```
#import < Foundation/Foundation.h>
void copyString (char *to, char *from)
{
    for (; *from != '\0'; ++from, ++to )
        *to = *from;
    *to = '\0';
}

int main (int arge, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    void copyString (char *to, char *from);
    char string [] = "Копируемая строка"2;
    char string2[50];

    copyString (string2, string 1);
    NSLog(@"%s", string2);

    copyString (string2, "Строка-константа");
    NSLog(@"%s", string2);

    [pool drain];
    return 0;
}
```
Вывод программы 13.13
```
Копируемая строка
Строка-константа
```
В функции copyString определены два формальных параметра (to и from) как указатели на символы, а не на массивы символов, как в предыдущей версии copyString. Это показывает, каким образом эти две переменные будут использо-ваться в функции.

Затем происходит вход в цикл for (без начальных условий) для копирования строки, которую указывает параметр from (откуда) в строку, которую указывает параметр to (куда). На каждом шаге цикла выполняется увеличение указателей from и to на I. В результате указатель from указывает на следующий символ для копирования из исходной строки, и указатель to указывает место, в котором будет сохранен этот символ. Когда указатель from указывает на нуль-символ, происходит выход из цикла for. Затем функция помещает нуль-символ в конец скопированной строки.

В процедуре main функция copyString вызывается дважды. В первый раз в строку string2 копируется содержимое строки stringl, во второй раз в строку string2 копируется содержимое константной символьной строки.

### Константные символьные строки и указатели
Из
```
copyString (string2, "Строка-константа");
```
следует, что если константная символьная строка передается как аргумент фун-кции, эта символьная строка фактически передается указателю. Это верно не только в данном случае. Обобщая, можно сказать, что если константная сим-вольная строка используется в Objective-C, то на эту символьную строку создается указатель.

Это может вызвать некоторую путаницу, но, как мы отмечали в главе 4, кон-стантные символьные строки называются строками встиле С (С-строками). Они не яатяются объектами. Объект константной символьной строки создается в том случае, если перед строкой поставлен знак   например, @"This is okay", и мы не можем использовать один вид вместо другого.

Таким образом, если переменная textPtr объявлена как указатель на символ,
```
char *textPtr;
```
оператор
```
textPtr = "Символьная строка";
```
присваивает переменной textPtr указатель на константную символьную строку "Символьная строка". Будьте внимательны, чтобы отличать указатели на символь-ные строки от символьных массивов, поскольку приведенное выше присваивание нс подходит для символьного массива. Например, если определить text как массив символов с помощью следующего оператора
```
char text[80];
```
то мы не сможем написать такой оператор, как text = "Это неправильно";

Единственный случай, когда Objective-C допускает такой тип присваивания для символьного массива —инициализация массива:
```
char text[80] = "Это правильно";
```
При такой инициализации массива text не происходит создание указателя на символьную строку "Это правильно" внутри text. Вместо этого происходит запись самих символов с конечным нуль-символом в соответствующие элементы массива text.

Если text — это указатель на тип char, то в случае инициализации text с помо-щью оператора
```
char *text = "Это правильно";
```
ему будет присвоен указатель на символьную строку "Это правильно".

#### Снова об операторах приращения (++) и уменьшения (--)
До настоящего момента оператор приращения или уменьшения был единствен-ным оператором в выражении. Если мы пишем выражение ++х, это означает, что значение х увеличивается на I. И, как вы уже видели, если х — указатель на массив, эта операция делает х указателем на следующий элемент массива.

Операторы приращения и уменьшения можно использовать в выражениях, где присутствуют другие операторы. В таких случаях важно знать, как они действуют.

Операторы приращения (increment) и уменьшения (decrement) всегда по-мещаются перед соответствующими наращиваемыми и уменьшаемыми пере-менными. Например, для приращения переменной i достаточно написать:
```
++i;
```
Оператор приращения можно также поместить после переменной:
```
i++;
```
Оба выражения допустимы, и оба дают одинаковый результат: увеличение на I значения i. В первом случае, когда ++ помещается перед операндом, операция увеличения называется преувеличением (pre-increment). Во втором случае, когда ++ помещается после операнда, операция увеличения называется посту-величением.

То же самое относится к оператору уменьшения. Поэтому оператор
```
--i;
```
выполняет предуменыиение i, а оператор
```
i--;
```
выполняет постуменьшение i. Оба дают одинаковый результат: вычитание 1 из значения i.

Если операторы приращения и уменьшения используются в более сложных выражениях, то отличия между пред- и пост-операторами могут быть существен-ными.

Предположим, что у нас есть две целые переменные: i и j. Если присвоить i значение 0 и затем написать оператор
```
j = ++i;
```
то переменной j будет присвоено значение 1, а не 0. В случае оператора преду-величения переменная наращивается до того, как ее значение используется в выражении. В приведенном выше выражении значение i сначала увеличивается с 0 до 1, а затем ее значение присваивается переменной j, как в следующих двух операторах.
```
++i;
i = i;
```
Если использовать оператор постувеличения
```
j = i++;
```
значение i будут увеличено после того, как она будет присвоена переменной j. Если i было присвоено значение 0 перед выполнением оператора постувеличс-
ния, то переменной j будет присвоено значение 0, и затем значение i будет уве-личено на 1, как в следующих операторах.
```
j = i;
++i;
```
Еше один пример. Если i равна 1, то в результате оператора
```
X = a[--i];
```
переменной х будет присвоено значение а[0], так как переменная i уменьшается до того, как ее значение используется для индексации а. Оператор
```
x = a[i--];
```
присваивает х значение а[1], поскольку i уменьшается после того, как ее значение используется для индексации а.

Третий пример отличий между пред- и пост-операторами приращения и уменьшения. При вызове функции
```
NSLog (@"%i", ++i);
```
происходит увеличение i, после чего ее значение передается функции NSLog, а при вызове
```
NSLog (@"%i", i++);
```
увеличение i происходит после того, как ее значение передано этой функции. Таким образом, если значение i было равно 100, при первом вызове NSLog на терминал будет выведено 101, а при втором вызове NSLog — 100. В обоих случаях значение i будет равно 101 после выполнения оператора.

И последний пример. Если textPtr — указатель на тип char, то в выражении
```
*(++textPtr)
```
textPtr сначала увеличивается на 1, а затем извлекается символ, на который ука-зывает textPtr. Однако в выражении
```
*(textPtr++)
```
сначала извлекается символ, на который указывает textPtr, а затем увеличивается его значение. В обоих случаях круглые скобки не обязательны, поскольку опера-торы * и ++ имеют одинаковый приоритет, но применяются справа налево.

Вернемся к функции copyString из программы 13.13 и перепишем ее для включения операций прирашения непосредственно в оператор присваивания.

Поскольку указатели to и from наращиваются каждый раз после выполнения оператора присваивания внутри цикла for, их следует включить в оператор при-сваивания как операции пост-увеличения. Модифицированный цикл for из про-граммы 13.13 принимает вид
```
for (; *from != '\0';)
    *to++ = *from++;
```
Выполнение оператора присваивания внутри никла происходит следующим образом. Считывается символ, на который указывает from, затем происходит наращивание from, чтобы он указывал следующий символ в исходной строке. Соответствующий символ будет сохранен в позиции, на которую указывает 1о; затем происходит наращивание to так, чтобы он указывал следующую позицию в конечной строке.

Приведенный цикл не слишком пригоден, поскольку не имеет начального выражения и не содержит выражения цикла. Для этой логики больше подходит цикл while. Он показан в программе 13.14, где представлена новая версия функции copyStriog. В этом цикле while учитывается, что нуль-символ равен значению 0.
```
// Функция для копирования одной строки в другую
// с помощью указателей, версия 2

#import <Foundation/Foundation.h>
void copyString (char *to, char *from)
{
    while (*from)
        *to++ = *from++;
    *to = “\0";
}

int main (int arge, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    void copyString (char *to, char *from);
    char string 1[] = "Копируемая строка";
    char string2[50];

    copyString (string2, string 1);
    NSLog (@"%s", string2);

    copyString (string2, "Строка-константа");
    NSLog (@"%s", string2);

    [pool drain];
    return 0;
}
```
Вывод программы 13.14
```
Копируемая строка
Строка-константа
```

### Операции с указателями
Мы можем добавлять или вычитать целые значения из указателей. Два указателя можно сравнивать. Помимо этих операций, два указателя одного типа можно вычитать. Результатом вычитания двух указателей в Objective-C является число элементов, содержащихся между этими двумя указателями. Так, если а указывает на массив элементов какого-либо типа, а b указывает на другой элемент с более высоким номером в том же массиве, то выражение b - а представляет число элементов между этими двумя указателями. Например, если р указывает на какой-либо элемент в массиве х, то оператор
```
n = р - х;
```
присваивает переменной п (в предположении, что это целая переменная) индекс элемента внутри массива х, на который указывает р. Следовательно, если р указывает на 100-й элемент в х
```
р = &х[99];
```
то значение п после вычитания будет равно 99.

#### Указатели на функции
Для полноты изложения введем чуть более сложное понятие указателя на фун-кцию. При работе с указателями на функции компилятору Objective-C требуется знать не только то, что указатель указывает на функцию, но и тип значения, возвращаемого этой функцией, число и типы ее аргументов. Чтобы объявить переменную fnPtr как указатель на функцию, которая возвращает значение типа int и не требует никаких аргументов, нужно написать строку
```
int (*fnPtr) (void);
```
Круглые скобки вокруг *fnPtr обязательны; в противном случае компилятор Objective-C будет интерпретировать этот оператор как объявление функции с именем fnPtr, которая возвращает указатель на тип int (оператор вызова функции () имеет более высокий приоритет, чем оператор косвенного обращения через указатель *).

Чтобы задать, что указатель указывает определенную функцию, достаточно присвоить ему имя этой функции. Например, если lookup — это функция, которая возвращает значение типа int и не требует никаких аргументов, то оператор
```
fnPtr = lookup;
```
сохраняет указатель на эту функцию в переменной-указателе функции fnPtr. Написание имени функции без последующих круглых скобок интерпретируется как имя массива без индекса. Компилятор Objective-C автоматически создает указатель на указанную функцию. Перед именем функции можно поставить амперсанд, но это не обязательно.

Если функция lookup не была ранее определена в программе, ее следует объявить до приведенного выше оператора, например,
```
int lookup (void);
```
Для косвенного обращения к этой функции через переменную-указатель нужно применить к этому указателю оператор вызова функций с указанием всех аргументов функции в круглых скобках. Например,
```
entry = fnPtr();
```
вызывает функцию, на которую указывает fnPtr, и возвращаемое значение со-храняется в переменной entry.

Указатели на функции часто перелаются в качестве аргументов другим фун-кциям. В библиотеке Standard Library функция qsort выполняет быструю сорти-ровку массива элементов данных. Эта функция принимает в качестве одного из своих аргументов указатель на функцию, которая вызывается, когда qsort требу-ется сравнение двух элементов в сортируемом массиве. Это позволяет исполь-зовать qsort для сортировки массивов любого типа, поскольку конкретное срав-нение любых двух элементов в массиве выполняется с помощью функции пользователя, а не самой функцией qsort.

В Foundation framework некоторые методы принимают в качестве аргумента указатель на функцию. Например, метод sortUsingFunction:context: определен в классе NSMutableArray и вызывает указанную функцию, когда требуется сравнение двух элементов массива.

Еще один применением указателей на функции является создание таблиц вызовов (dispatch table). М ы не можем сохранять сами функции в элементах мас-сива, но можем сохранять внутри массива указатели на функции. Это позволяет создавать таблицы, которые содержат указатели на вызываемые функции. Например, можно создать таблицу обработки различных команд, которые вводит пользователь. Каждая запись в таблице может содержать как имя команды, так и указатель на функцию, вызываемую для обработки этой конкретной команды. Когда пользователь вводит команду, ее можно найти в этой таблице и вызвать соответствующую функцию для ее обработки.

### Указатели и адреса памяти
Прежде чем закончить разговор об указателях в Objective-C, мы должны описать их реализацию. Память компьютера можно рассматривать как последовательный набор ячеек памяти. Каждая ячейка памяти компьютера имеет свой номер, называемый адресом. Обычно первый адрес памяти имеет номер 0. В большинстве компьютерных систем ячейка занимает 1 байт.

Компьютер использует память для хранения команд программы и хранения значений переменных, связанных с программой. Например, если мы объявим переменную с именем count типа int, то система выделит ячейки в памяти, чтобы сохранять значение count во время выполнения профаммы. Это может быть, например, адрес 1000FF<sub>16</sub> в памяти компьютера.

К счастью, нам не нужно думать о конкретных адресах памяти, связанных с переменными, поскольку система делает это автоматически. Однако знание того, что каждая переменная связана со своим адресом в памяти, помогает понять, как действу ют указатели.

Когда мы применяем адресный оператор & к переменной в Objective-C, ге-нерируемое значение — это конкретный адрес данной переменной в памяти компьютера. (Именно поэтому мы называем этот оператор адресным.) Например, оператор
```
intPtr = &count;
```
присваивает указателю intPtr адрес в памяти компьютера, который был выделен для переменной count. Так, если count размешена по адресу 1000FF6, этот опера-тор присвоит указателю intPtr значение OxlOOOFF.

Применение оператора косвенного доступа * к переменной-указателю, как в выражении
```
*intPtr
```
означает интерпретацию значения, содержащегося в этой переменной, как адреса памяти. Значение, хранящееся по этому адресу, считывается и интерпретируется в соответствии с типом, объявленным для этой переменной. Например, если переменная intPtr является указателем на тип int, то система будет интерпретировать значение, хранящееся по адресу памяти, заданному с помощью *intPtr, как целое значение.

## 13.5. Объединения
Одной из наиболее необычных конструкций в языке программирования Objective-C является объединение (union). Эта конструкция используется в ос-новном для сложных программных приложений, когда требуется сохранять раз-личные типы данных в одном и том же месте памяти. Предположим, что нужно определить одну переменную с именем х, которую можно было бы использовать для хранения одного символа, числа с плавающей точкой или целого числа. Для этого можно определить объединение, например, с именем mixed.
```
union mixed
{
    char с;
    float f;
    int i;
};
```
Объявление объединения совпадает со структурой (за исключением ключевого слова union). Принципиальным отличием между структурами и объединениями является способ выделения памяти. Объявление переменной типа union mixed, как в
```
union mixed х;
```
не означает, что х содержит три отдельных компонента с именами с, f или i. На самом деле х содержит один компонент, который называется с, f или L Тем самым мы можем использовать переменную х для хранения элемента типа char, float или int, но не всех трех типов одновременно. Чтобы сохранить какой-либо символ в переменной х, используется оператор
```
х.с = 'К';
```
Чтобы сохранить в х значение с плавающей точкой, используется форма за-писи x.f:
```
x.f = 786.3869;
```
И, наконец, чтобы сохранить в х результат деления целой переменной count на 2, используется оператор
```
x.i = count / 2;
```
Поскольку элементы х типа float, char и int находятся в одном месте памяти, мы можем единовременно сохранять в х только одно из этих значений. Кроме того, значение, которое считывается из объединения, должно соответствовать тому, что было в последний раз записано в это объединение.

При определении объединения имя объединения указывать не обязательно, и переменные можно объявлять одновременно с определением этого объединения. В объединениях можно объявлять указатели с таким же синтаксисом и правилами выполнения операций, как для структур. Мы можем инициализировать переменную типа union следующим образом.
```
union mixed х = {'#'};
```
Первому члену х, то есть с, присваивается символ #. Определенный член объединения можно также инициализировать по имени следующим образом.
```
union mixed х = {.f= 123.4;};
```
Мы можем инициализировать автоматическую union-переменную типа присвоив ей другую union-переменную того же типа.

С помощью объединения можно определять массивы для хранения элементов данных различного типа. Ниже задается массиве именем table, содержащий kTableEntries элементов.
```
struct
{
    char *name;
    int type;
    union {
        int i;
        float f;
        char c;
    } data;
} table [kTableEntries];
```
Каждый элемент этого массива содержит структуру, включающую указатель на типа char с именем паше, целый компонент с именем type и union-компонент с именем data. Каждый элемент data может содержать компонент типа int, float или char. Целый компонент type позволяет следить за типом значения, сохраняемого в data. Мы можем присвоить type значение INTEGER (определенное соответствую-щим образом), если содержится значение типа int; значение FLOATING, если со-держится значение типа float; CHARACTER, если содержится значение типа char. Эта информация позволяет узнать, как обращаться к определенному компоненту структуры data определенного элемента массива.

Чтобы сохранить символ '#' в элементе table[5] и затем записать в поле type, что в этом месте хранится символ, применяются два оператора
```
table[5].data.c = '#';
table[5].type = CHARACTER;
```
Во время перебора элементов table можно определять тип значения данных, хранящегося в каждом элементе, с помощью набора проверок. Например, в следующем цикле выводится имя и его значение из массива table.
```
enum symbolType {INTEGER, FLOATING, CHARACTER };
...
for (j = 0; j < kTableEntries; ++j)
{
    NSLog (@"%s", table[j].name);
    switch (table [j], type )
    {
        case INTEGER:
            NSLog (@"%i", tableOl-data.i);
            break;
        case FLOATING:
            NSLog (@"%g", table[j].data.f);
            break;
        case CHARACTER:
            NSLog (@"%cn, table[j].data.c);
            break;
        default:
            NSLog (@"Unknown type (%i), element %i", table(j]-type, j);
            break;
    }
}
```
На практике такое приложение можно использовать для хранения таблицы символов, содержащей имя каждого символа, его тип и его значение (и другую информацию).

## 13.6. Это не объекты!
Теперь вы знаете, как определять массивы, структуры, символьные строки и объединения и как работать с ними в программах. Помните главное: они не яв-ляются объектами. Мы не можем передавать им сообщения. Они не позволяют полностью использовать такие удобные возможности, как стратегию выделения памяти, которая обеспечивается в Foundation framework. Это одна из причин, по которым я советовал пропустить эту главу и вернуться к ней позже. Вы лучше подготовлены к изучению того, как использовать классы Foundation, в которых массивы и строки определяются как объекты, чем к использованию таких средств, встроенных в язык. Прибегайте к использованию типов, описанных в этой главе, только в случае реальной необходимости!

## 13.7. Различные средства языка
Некоторые средства языка не совсем согласуются с материалом других глав, поэтому мы включили их в этот раздел.

### Составные литералы
Составной литерал (compound literal) представляет собой имя типа, заключенное в круглые скобки, после которого следует список инициализации. В результате создается неименованное значение указанного типа, область действия которого ограничена блоком, в котором оно создано, или глобальной областью действия, если оно определено вне блока. В последнем случае все инициализаторы должны включать только константные выражения.

Рассмотрим следующий пример.
```
(struct date) {.month = 7, .day = 2, .year = 2004}
```
Это выражение создает структуру типа struct date с указанными начальными значениями. Ее можно присвоить другой структуре типа struct date, например,
```
theDate = (struct date} {.month = 7, .day = 2, .year = 2004};
```
Ее можно передать функции или методу как аргумент типа struct date, напри-мер,
```
setStartDate ((struct date) {.month = 7, .day = 2, .year = 2004});
```
Кроме того, можно определять типы, отличные от структур. Например, если intPtr имеет тип int *, оператор
```
intPtr = (int (100]) {(0) = 1, [50] = 50, [99] = 99 };
```
который может появиться в любом месте программы, задает intptr, указывающий на массив из 100 целых элементов, первые 3 элемента которого инициализируются указанным образом.

Если размер массива не задан, он определяется списком инициализации.

### Оператор goto
Оператор goto вызывает непосредственный переход в указанную точку програм-мы. Чтобы указать это место, требуется метка. Метка (label) — это имя, форми-руемое по таким же правилам, как имена переменных; сразу после него ставится двоеточие. Метка ставится непосредственно перед оператором, на который выполняется переход, и должна присутствовать в той же функции или методе, где находится соответствующий goto.

Например, оператор
```
goto out_of_data;
```
вызывает переход к оператору, перед которым стоит метка out_of_data;. Эта метка должна находиться где-либо в функции или методе (до или после goto) и может использоваться, например, как показано ниже.
```
out_of_data: NSLog (@"Unexpected end of data.");
```
Ленивые профаммисты часто злоупотребляют оператором goto для перехода к другим частям своего кода. Оператор goto нарушает нормальную последователь-ность программы, что затрудняет отслеживание ее выполнения. В практике на-дежною профаммирования не рекомендуется использовать операторы goto.

### Пустой оператор
Objective-C позволяет помещать отдельный символ «точка с запятой» в любом месте, где можно ставить обычный программный оператор. Такой оператор (его называют пустым (null) оператором) ничего не выполняем Это может показаться бесполезным, но программисты часто используют его в операторах while, for и do. Например, следующий оператор используется для сохранения всех символов, прочитанных со стандартного устройства ввода (по умолчанию это терминал), в массив символов, на который указывает text. Ввод продолжается, пока не встретится символ новой строки (перевода строки). В этом операторе ис-пользуется библиотечная процедура getchar, которая читает и возвращает по од-ному символу со стандартного устройства ввода.
```
while ((*text++ = getchar ())!='')
    ;
```
Все операции выполняются в соответствии с условиями цикла оператора while. Здесь требуется пустой оператор, поскольку компилятор интерпретирует оператор, который следует за выражением цикла, как тело цикла. Без пустого оператора компилятор будет обрабатывать как тело цикла любой следующий программный оператор.

### Оператор «запятая»
На самом нижнем уровне приоритетов находится оператор «запятая». В главе 5 мы указывали, что внутри оператора for можно включать в любое из полей не-сколько выражений, отделяя их запятыми. Например, в операторе
```
for (i = 0, j = 100; i != 10; ++i, j -= 10)
    ...
```
до начала цикла инициализируется значение i, равное 0, и j, равное 100. После выполнения тела цикла значение i увеличивается на 1 ,а из значения) вычитается 10.

Поскольку все операторы в Objective-C дают какое-то значение, значением оператора «запятая» является результат правого выражения.

### Оператор sizeof
В программах никогда не следует делать какие-либо предположения о размере определенного типа данных, но иногда нужно знать эту информацию — например, при выделении динамической памяти, использовании библиотечных процедур, при записи или архивации данных в файл. В Objective-C имеется оператор с именем sizeof, который можно использовать для определения размера типа данных или объекта. Оператор sizeof возвращает размер указанного элемента в байтах. Аргументом для оператора sizeof может быть переменная, имя массива, имя базового типа данных, объект, имя производного типа данных или выражение. Например, написав
```
sizeof (int)
```
мы получим число байтов для сохранения целого значения. На моем Mac Book Air получается значение 4 (то есть 32 бита). Если объявить х как массив из 100 значений типа int, то выражение
```
sizeof (х)
```
даст количество памяти, необходимой для сохранения 100 целых элементов массива х.

Если myFract является объектом класса Fraction, содержащим две переменных экземпляра типа int (numerator и denominator — числитель и знаменатель), то выражение
```
sizeof (myFract)
```
даст значение 4 на любом компьютере, где для представления указателей ис-пользуются 4 байта. На самом деле sizeof дает это значение для любого объекта, потому что мы запрашиваем размер указателя на данные объекта. Чтобы получить размер реальной структуры данных для хранения экземпляра объекта класса Fraction, нужно написать
```
sizeof (myFract)
```
На моем MacBook Air это дает значение 12. Эту сумма складывается из 4 байтов для numerator, 4 байтов для denominator, плюс еще 4 байта для наследуемого компонента isa, о котором говорится в разделе «Как это действует» в конце главы. Выражение
```
sizeof (struct data_entry)
```
дает количество памяти, необходимой для хранения одной структуры data_entry. Если data определен как массив элементов struct data_entry, то выражение
```
sizeof (data) / sizeof (struct dataentry)
```
дает число элементов, содержащихся в data (data должен быть заранее опреде-ленным массивом, а не формальным параметром или массивом по внешней ссылке). Выражение
```
sizeof (data) / sizeof (data[0])
```
дает тот же результат.

Используйте оператор sizeof, чтобы избежать вычислений или задания фик-сированных размеров в программах.

### Аргументы командной строки
Довольно часто программы запрашивают на терминале пользователя ввод не-большого количества информации.

Вместо запроса такую информацию можно вводить при запуске программы. Это осуществляется с помощью аргументов командной строки (commandline arguments).

Мы уже указывали, что единственным отличительным свойством функции main является специальное имя; она указывает, где должно начинаться выполнение программы. На самом деле функцию main в начале выполнения программы вызывает система выполнения (runtime) так же, как мы вызываем функцию из своей собственной программы. Когда main заканчивает выполнение, управление передается системе runtime, которая знает, что ваша программа завершена.

Когда система runtime вызывает main, этой функции передаются два аргумен-та. Первый аргумент, который называется arge (сокращение от argument count — число аргументов), является целым значением, которое указывает число аргу-ментов, вводимых в командной строке. Второй аргумент для main — это массив указателей на символьные значения с именем argv (сокращение от argument vector). В этом массиве содержатся aigc + I символьных указателей. Первым элементом этого массива является указатель на имя выполняемой программы или указатель на нуль-строку, если имя программы недоступно. Последующие записи этого массива указывают значения, заданные в той же строке, что и команда, инициировавшая выполнение данной программы. Последний указатель массива argv, argvfargc], определен как пустой указатель.

Для доступа к аргументам командной строки функция main должна быть объявлена с двумя аргументами. Во всех программах этой книги мы использовали объявление
```
int main (int arge, char *argv[])
{
    ...
}
```
Напомним, что объявление argv определяет массив, который содержит эле-менты типа «указатель на тип char». Для практического использования аргументов командной строки предположим, что мы разрабатываем программу, которая ищет нужное слово в словаре и выводит его смысл. С помощью следующей команды можно использовать аргументы командной строки, чтобы слово, смысл которого нужно определить, было указано одновременно с запуском программы.
```
lookup aerie
```
Это позволяет обойтись без запроса ввода пользователя, поскольку слово вво-дится из командной строки.

При запуске этой команды система автоматически передает функции main ука-затель на символьную строку "aerie" вагду[1]. Напомним, что argv[0] содержит указатель на имя программы (в данном случае это "lookup").

Процедура main может иметь следующий вид.
```
#include <Foundation/Foundation.h>
int main (int argc, char *argv[])
{
    struct entry dictionary[100] =
        {   {"aardvark", "a burrowing African mammal"},
            {"abyss", "a bottomless pit"},
            {"acumen", "mentally sharp; keen"},
            {"addle", "to become confused"},
            {"aerie", "a high nest"},
            {"affix", "to append; attach"},
            {"agar", "a jelly made from seaweed"},
            {"ahoy", "a nautical call of greeting"},
            {"aigrette", "an ornamental cluster of feathers"},
            {"ajar", "partially opened"} };

    int entries = 10;
    int entryNumber;
    int lookup (struct entry dictionary [], char search]],
                int entries);

    if ( argc != ? )
    {
        NSLog (@"No word typed on the command line.");
        return (1);
    }

    entryNumber = lookup (dictionary, argv[1], entries);

    if (entryNumber != -1 )
        NSLog (@"%s", dictionaryfentryNumber].definition);
    else
        NSLog (@"Sorry, %s is not in my dictionary.", argv[1]);

    return (0);
}
```
Процедура main при запуске программы проверяет, было ли введено слово после имени профаммы. Если не было или было введено больше одного слова, то значение arge не равно 2, программа выводит сообщение об ошибке и завершает работу, возвращая при выходе значение состояния 1.

Если значение arge равно 2, то вызывается функция lookup для поиска в сло-варе слова, на которое указывает argv[1]. Сели это слово найдено, выводится его смысл (определение).

Аргументы командной строки всегда сохраняются как символьные строки. Например, при запуске профаммы power (возведение в степень) с аргументами командной строки 2 и 16
```
power 2 16
```
в argv[1] сохраняется указатель на символьную строку "2" и в argv[2] сохраняется указатель на символьную строку "16". Если программа должна интерпретировать аргументы как числа (например, в случае программы power), их должна преобразовывать сама эта программа. Для таких преобразований в библиотеке профамм содержится несколько процедур: sscanf, atof, atoi, strtod и strotol. В части 11 вы узнаете, как использовать класс NSProcessInfo для доступа к аргументам ко-мандной строки как к строковым объектам, а не С-строкам.

## 13.8. Как это действует
Было бы упущением закончить эту главу без описания связей между некоторыми элементами. Поскольку в основе языка Objective-C лежит язык С, имеетсмысл описать некоторые связи между ними. Обратите внимание на эти детали реали-зации, чтобы лучше понять, как все это действует. Мы не будем здесь вдаваться в подробности, а просто приведем четыре факта о связях между Objective-C и С.

### Факт 1: переменные экземпляра сохраняются в структурах
Когда мы определяем новый класс и его переменные экземпляра, эти переменные на самом деле сохраняются в структуре. На самом деле это структуры, ком-понентами которых являются наши переменные экземпляра. Поэтому насле-дуемые переменные экземпляра плюс переменные экземпляра, которые мы добавляем в свой класс, представляют одну структуру. Если мы выделяем память для нового объекта с помощью alloc, резервируется достаточное пространство, чтобы включить одну из этих сфуктур.

Одним из наследуемых компонентов этой структуры (он поступает из кор-невого объекта) является защищенный компонент с именем isa, который указывает класс, которому принадлежит объект. Поскольку этот компонент является частью структуры (и гем самым частью объекта), он переносится вместе с объектом. Это позволяет системе runtime всегда идентифицировать класс объекта (даже если он присваивается обобщенной переменной-объекту типа id) по информации его компонента isa.

Чтобы получить непосредственный доступ к компонентам структуры объекта, можно объявить их как @public (см. главу 10). Если сделать это, например, для компонентов numerator и denominator класса Fraction, то можно писать в про-граммах такие выражения, как
```
myFract->numerator
```
для непосредственного доступа к компоненту numerator объекта myFract класса Fraction. Но мы настоятельно рекомендуем не делать этого. Как говорилось в главе К), это противоречит основам инкапсуляции данных.

### Факт 2: переменная-объект на самом деле является указателем
Определяя переменную-объект класса Fraction, например,
```
Fraction *myFract;
```
мы фактически определяем переменную-указатель с именем myFract. Эта пере-менная определяется для указания элемента типа Fraction (это имя нашего класса). При выделении памяти д ля нового экземпляра типа Fraction с помощью строки
```
myFract = [Fraction alloc];
```
мы выделяем пространство в памяти для хранения нового объекта класса Fraction (то есть пространство для структуры) и затем сохраняем указатель на эту струк-туру, который возвращается в перемен ной-указателе myFract.

Присваивая один объект-переменную другому, как в
```
myFract2 = myFract 1;
```
мы просто копируем указатели. В результате обе переменные будут указывать на одну структуру, хранящуюся в определенном месте памяти. Поэтому внесение изменений в один из компонентов, который указывается с помощью myFract2, вызывает изменения в той же переменной экземпляра (то есть в компоненте структуры), которую указывает myFractl.

### Факт 3: методы и функции, а также выражения с сообщениями - это вызовы функций
Методы — это на самом деле функции. При вызове метода мы вызываем функцию, связанную с классом получателя. Аргументы, передаваемые функции, это аргументы получателя (self) и метода. Поэтому все правила, касающиеся передачи аргументов функциям, возвращаемых значений, а также автоматических и статических переменных, одинаковы для функции и метода. Компилятор Objective-C создает уникальное имя для каждой функции в виде комбинации из имени класса и имени метода.

### Факт 4: тип id - это обобщенный тип указателя
Поскольку обращение к объектам выполняется через указатели, которые являются просто адресами памяти, мы можем легко присваивать им переменные тина id. Поэтому метод, который возвращает тип id, просто возвращает указатель на некоторый объект в памяти. Мы можем затем присвоить это значение любому объекту-переменной. Поскольку объект при его перемещении сопровождается своим компонентом isa, его класс можно всегда идентифицировать, даже если он хранится в обобщенном объекте-переменной типа id.

## Упражнения
1. Напишите функцию, которая вычисляет среднее значение 10 элементов массива с плавающей точкой и возвращает результат.
2. Метод reduce из класса Fraction находит наибольший общий делитель числи-теля и знаменателя (numerator и denominator) для сокращения дроби. Внесите изменения в этот метод, чтобы в нем можно было использовать функцию gcd из программы 13.5. Где следует поместить определение этой функции? Будет ли удобнее сделать эту функцию статической? Какой подход вы считаете более подходящим: использование функции gcd или включение этого кода непосредственно в метод, как мы делали это раньше? Почему?
3. Алгоритм, известный под названием «Решето Эратосфена», позволяет по-лучать простые числа. Ниже приводится алгоритм для этой процедуры. На-пишите программу, которая реализует этот алгоритм. Сделайте так, чтобы программа находила все простые числа до п = 150. Что вы можете сказать об этом алгоритме по сравнению с алгоритмами в этой книге для расчета простых чисел?

    Шаг 1. Определить массив Р с целыми значениями. Присвоить всем элементам Pi значение 0, 2 <= i <= п.
    Шаг 2. Присвоить i значение 2.
    Шаг 3. Если i > п, алгоритм завершается.
    Шаг 4. Earn Pi равно 0, i — простое число.
    Шаг 5. Для всех положительных целых значений j, удовлетворяющих условию ixj<=n, присвоить Лх) значение 1.
    Шаг 6. Увеличить i на I и перейти к шагу 3.

4. Напишите функцию для сложения всех дробей (объектов Fraction), передава-емых ей в массиве, и возвращения результата в виде объекта Fraction.
5. Напишите определение typedef для структуры struct date с именем Date, чтобы в вашей программе можно было делать, например, следующие объявления.
    ```
    Date todaysDate;
    ```
6. Определение класса Date вместо структуры date больше согласуется с прин-ципами объектно-ориентированного программирования. Определите такой класс с соответствующими методами-установщиками (setter) и получателями (getter). Добавьте метод dateUpdate, чтобы возвращать день по его аргументу.
    Покажите преимущества определения Date в виде класса, а не в виде струк-туры.

    Усматриваете ли вы какие-то недостатки?
7. В соответствии со следующими определениями
    ```
    char *message = "Программировать на Objective-C интересно";
    char me$sage2[] = "Вы сказали это";
    int х = 100;
    ```
    определите, является ли допустимым каждый вызов NSLog в следующих на-борах и является ли вывод одинаковым для всех вызовов из этого набора.
    ```
    /*** набор 1 ***/
    NSLog {@"Программировать на Objective-C интересно’);
    NSLog (@"%s',l "Программировать на Objective-C интересно");
    NSLog (@"%s\ message);
    /*** набор 2 ***/
    NSLog (@"Вы сказали это");
    NSLog (@"%s", message2);
    NSLog (@"%s", &message2[0j);
    /*** набор 3 ***/
    NSLog (@"сказали это");
    NSLog (@"%s", message2 + 4);
    NSLog (@"%s", &message2[4]);
    ```
8. Напишите программу, которая выводит на терминал все аргументы командной строки (по одному на строку). Обратите внимание на использование кавычек для аргументов, которые содержат пробелы.
9. Какие из следующих операторов дают на выходе строку "Это проверка"? Объясните результаты.
    ```
    NSLog {@"Это проверка");
    NSLog ("Это проверка");

    NSLog (@"%s", "Это проверка");
    NSLog (@"%s", @"Это проверка");

    NSLog ("%s", "Это проверка");
    NSLog ("%s", @"Это проверка"};

    NSLog (@"%@", @"Это проверка");
    NSLog (@"%@", "Это проверка");
    ```