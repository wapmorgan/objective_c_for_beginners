# Глава 11. Категории и протоколы
В этой главе описывается, как добавлять методы для класса в модульном стиле
с помощью категорий и как создавать стандартизованный список методов для
реализации другими людьми.


## 11.1. Категории
При работе с определенным классом к нему приходится добавлять новые методы. Например, для класса Fraction могут потребоваться методы, реализующие вычитание, умножение и деление двух дробей.

Предположим, что ваша группа в составе большого проекта определяет новый класс, который содержит много различных методов. Вашей задачей является написание для этого класса методов, которые работают с файловой системой. Другие члены проекта должны написать методы, которые реализуют создание и инициализацию экземпляров этого класса, выполняют операции над объектами в этом классе и рисуют представления объектов этого класса на экране.

Вы изучили, как использовать класс массивов из библиотеки Foundation framework с именем NSArray и поняли, что в этом классе необходимо реализовать один или нескольких методов. Конечно, вы могли бы написать новый подкласс класса NSArray и реализовать эти новые методы, но есть более простой способ. На практике для разрешения подобных ситуаций используются категории (category). Категория представляет простой способ модульного определения класса в виде групп или категорий связанных методов. Она также позволяет достаточно просто расширить существующее определение класса без доступа к существующему исходному коду этого класса или создания подкласса. Это мощная и достаточно простая для изучения концепция.

Вернемся к первому примеру и покажем, как добавить новую категорию в класс Fraction для работы с четырьмя основными арифметическими операциями. Приведем исходную секцию interface для Fraction.
```
#import <Foundation/Foundation.h>

#import <stdio.h>

// Определение класса Fraction

@interface Fraction : NSObject
{
    int numerator;
    int denominator;
}

@property int numerator, denominator;
-(void) setTo: (int) n over: (int) d;
-(Fraction *) add: (Fraction *) f;
-(void) reduce;
-(double) convertToNum;
-(void) print;
@end
```
Теперь удалим метод add: из этой секции interface и добавим его в новую категорию вместе с тремя другими арифметическими операциями, которые нужно реализовать. Ниже показана секция in te rfa c e д л я новой категории MathOpS.
```
#import «Fraction.h»
@interface Fraction (MathOps)
-(Fraction *) add: (Fraction *) f;
-(Fraction *) mul: (Fraction *) f;
-(Fraction *) sub: (Fraction *) f;
-(Fraction *) div: (Fraction *) f;
@end
```
Здесь представлено некоторое определение секции interface, по на самом деле это расширение существующей секции. Мы должны включить исходную секцию interface, чтобы указать компилятору на класс Fraction (правда, вы можете включить эту новую категорию непосредственно в исходный файл Fraction.h).

После строки «import мы вилим следующую строку:
```
@interface Fraction (MathOps)
```
Она указывает компилятору, что для класса Fraction определяется новая категория с именем MathOps. Имя категории после имени класса заключено в круглые скобки. Отметим, что здесь не указывается родительский класс для Fraction; компилятору уже извес тно о нем из Fraction.h. Кроме того, мы ничего не сообщаем ему о переменных экземпляра, хотя делали это во всех предыдущих секциях interface. На самом деле мы получим от компилятора сообщение о синтаксической ошибке, если попытаемся включить родительский класс или переменные экземпляра.

Эта секция interface указы вает компилятору, что мы добавляем в класс Fraction расширение под категорией с именем MathOps. Категория MathOps содержит четыре метода экземпляра: add:, mul:, sub: и div:. Каждый метод получает в качестве аргумента дробь (fraction) и возвращает тоже дробь.

Определения всех этих четырех методов можно поместить в одну секцию implementation.Мы можем определить в одной секции implementation все методы из секции interface файла Fraction.h плюс методы из категории MathOps. Мы также можем определить методы из этой категории в отдельной секции implementation. Тогда в секции implementation для этих методов следует также идентифицировать категорию, к которой принадлежат эти методы. Как и в секции interface, имя категории после имени класса нужно заключить: в круглые скобки
```
@implementation Fraction (MathOps)
    // код для методов этой категории
    ...
@end
```
В программе 11.1 для новой категории MathOps секции interface и implementation объединены в одном файле вместе с тестовой процедурой.
```
#import "Fraction.h"

@interface Fraction (MathOps)
-(Fraction *) add: (Fraction *) f;
-(Fraction *) mul: (Fraction *) f;
-(Fraction *) sub: (Fraction *) f;
-(Fraction *) div: (Fraction *) f;
@end

@implementation Fraction (MathOps)
-(Fraction *) add: (Fraction *) f
{
    // Для сложения двух дробей:
    // a/b + c/d = ((a*d) + (b*c)) / (b * d)

    Fraction *result = [[Fraction alloc] init];
    int resultNum, resultDenom;

    resultNum = (numerator * f.denominator) +
        (denominator * f.numerator);
    resultDenom = denominator * f.denominator;

    [result setTo: resultNum over: resultDenom];
    [result reduce];

    return result;
}

-(Fraction *) sub: (Fraction *) f
    // Для вычитания двух дробей:
    // a/b - c/d = ((a*d) - (b*c)) / (b * d)

    Fraction *result = [[Fraction alloc] init];
    int resultNum, resultDenom;

    resuUNum = (numerator * f.denominator) -
        (denominator * {.numerator);
    resultDenom = denominator * f.denominator;

    [result setTo: resultNum over: resultDenom];
    [result reduce];

    return result;
}

-(Fraction *) mul: (Fraction *) f
{
    Fraction *result = [[Fraction alloc] init];

    [result setTo: numerator * f.numerator
        over: denominator * f.denominator];
    [result reduce];

    return result;
}

-(Fraction *) div: (Fraction *) f
{
    Fraction *result = [[Fraction alloc] init];

    [result setTo: numerator * f.denominator
        over: denominator * {.numerator];
    [result reduce];

    return result;
}
@end

int main (int argc, char *argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

    Fraction *a = [[Fraction alloc] init];
    Fraction *b = [[Fraction alloc] init];
    Fraction *result;

    [a setTo: 1 over: 3];
    [b setTo: 2 over: 5];

    [a print]; NSLog (@"    +"); [b print]; NSLog (@"----");
    result = [a add: b];
    [result print];
    NSLog (@ "\n");
    [result release];

    [а print]; NSLog (@"    -"); [b print]; NSLog (@"----");
    result = [a sub: b];
    [result print];
    NSLog (@"\n");
    [result release];

    [a print]; NSLog (@"    *"); [b print]; NSLog (@"----");
    result = [a mul: b];
    [result print];
    NSLog (@"\n");
    [result release];

    [a print]; NSLog (@"    /"); [b print]; NSLog (@"----");
    result = [a div: b];
    [result print];
    NSLog (@"\n");
    [result release];
    [a release];
    [b release];

    [pool drain];
    return 0;
}
```
Вывод программы 11.1
```
1/3
   +
2/5
----
11/15

1/3
   -
2/5
----
-1/15

1/3
   *
2/5
----
2/15

1/3
   /
2/5
----
5/6
```
И снова напомним, что в Objective-C вполне допустимы такие операторы, как
```
[[a div: b] print];
```
В этой строке выполняется непосредственный вывод результата деления а на Ь, что позволяет избежать промежуточного присваивания результата какой- либо переменной, как в программе 11.1.Нам нужно это промежуточное присваивание, чтобы получить результирующую дробь (Fraction) и освободить память, которую она занимает. В противном случае при каждом выполнении арифметической операции над дробью будет происходить утечка памяти.

В программе 11.1 секции interface и implementation для новой категории помещены в один файл вместе с тестовой программой. Как уже говорилось выше, секция interface для категории может быть включена в исходный header-файл Fraction.h (чтобы все методы были объявлены в одном месте), или в свой соб-ственный header-файл.

Если поместить категорию в мастер-файл определения класса, все пользователи этого класса будут иметь доступ к методам данной категории. Если у вас пет возможности непосредственного внесения изменений в исходный header- файл (см. добавление категории в существующий класс из библиотеки в части II, «Foundation Framework»), то вы вынуждены хранить категорию в отдельном файле.


### Некоторые замечания по категориям
Отметим несколько особенностей категорий. Во-первых, хотя категория имеет доступ к переменным экземпляра исходного класса, в ней нельзя добавить ее собственные переменные экземпляра. При необходимости нужно использовать подклассы.

Кроме того, ка тегория может замещать другой метод своего класса. Обычно это считается недопустимым в практике надежного программирования. После замещения метода вы уже нс имеете доступа к исходному методу, поэтому при замене вы должны аккуратно дублировать все функциональные возможности замещаемого метода. Если вам действительно требуется замещение какого-либо метода, используйте подклассы. При замещении метода в подклассе вы можете по-прежнему обращаться к родительскому методу, передавая сообщение super. В этом случае вам не нужно знать все особенности метода, который вы замешаете; можно просто вызвать родительский метод и добавить ваши функциональ-ные возможности в метод подкласса.

Соблюдая изложенные здесь правила, можно иметь сколько угодно категорий. Если метод определен более чем в одной категории, язык не указывает, какая из них будет использоваться.

В отличие от обычной секции interface, вам не нужно реализовать все методы, указанные в категории. Это полезно для пошаговой разработки программ, поскольку вы можете объявить все методы в категории и постепенно их реализовывать.

Расширение класса путем добавления новых методов с помощью категории влияет не только на этот класс, по и на все его подклассы. Это может быть потенциально опасным. Например, если вы добавляете новые методы в корневой объект NSObject, каждый пользователь будет наследовать эти методы. Новые методы, которые вы добавляете к существующему классу с помощью категории, возможно, будут отвечать вашим намерениям, но могут оказаться несогласованными с исходной организацией или целями класса. Например, превращение квадрата (Square) в окружность (Circle) путем добавления новой категории и некоторых методов искажает определение класса и не согласуется с практикой надежного программирования.

Кроме того, пары объект/категория должны быть уникальными. Только одна категория NSString (Private) может существовать в заданном пространстве имен Objective-C. Это может вызывать затруднения, поскольку пространство имен Objective-C совместно используется кодом программы и всеми библиотеками, структурами framework (фреймворками) и дополнительными программными модулями (plug-in). Это особенно важно для программистов Objective-C, которые пишут коды экранных заставок (screensaver), панелей предпочтений и других дополнительных модулей, поскольку их код будет вставляться в код приложения или фреймворк, которыми они не могут управлять.

## 11.2. Протоколы
Протокол (protocol) — это список методов, которые совместно используются классами. Методы, включенные в протокол, не имеют соответствующих реализаций (implementation): предполагается, что они будут реализованы кем-то другим. Протокол — это способ определения набора методов, которые каким-либо образом связаны с указанным именем. Эти методы обычно документируются, что позволяет вам реализовать их в ваших определениях классов.

Если вы реализуете все необходимые методы для определенного протокола, вы подчиняетесь (conform) этому протоколу или принимаете (adopt) его.

Протокол определяется просто: укажите имя протокола после директивы @protocol. После этого нужно объявить методы так же, как в секции interface. Все объявления методов вплоть до директивы @end становятся частью данного протокола.

При работе с Foundation framework вы увидите, что несколько протоколов уже определены. Один из них, NSCopying, объявляет метод, который вам потребуется реализовать, если ваш класс должен поддерживать копирование объектов с помощью метода сору (или copyWrthZone:). (Подробно тема копирования объектов рассматривается в главе 18.)

Ниже показано, как определяется протокол NSCopying в стандартном файле Foundation NSObject.h.
```
@protocol NSCopying
- (id)copyWithZone: (NSZone *}zone;
@end
```
Если вы приняли протокол NSCopying в своем классе, то должны реализовать метод copyWithZone:. Вы сообщаете компилятору, что принимаете протокол, заключая имя этого протокола в угловые скобки (<...>) в строке @interface. Имя про школа указывается после имени класса и его родительского класса, как в следующей строке:
```
@interlace AddressBook: NSObject <NSCopying>
```
В этой строке сообщается, что AddressBook является объектом с родительским классом NSObject и подчиняется протоколу NSCopying. Поскольку система уже знает о методах, определенных ранее для этого протокола (в данном случае — из файла NSObject.h), эти методы не нужно объявлять в секции interface. Однако их нужно определить в вашей секции implementation.

В данном примере в секции implementation для AddressBook компилятор предполагает обнаружить определение метода copyWithZone:.

Если ваш класс принимает более одного протокола, просто перечислите их в угловых скобках, разделяя запятыми:
```
@interface AddressBook: NSObject <NSCopying, NSCoding>
```
Здесь компилятору сообщается, что класс AddressBook принимает протоколы NSCopying и NSCoding. В данном случае компилятор предполагает обнаружить определение всех требуемых методов (перечисленных в этих протоколах) в секции implementation для AddressBook.

Определив свой собственный протокол, вы не обязаны реализовать его сам и. Вы уведомляете других программистов, что если они хотят принять этот протокол, то должны реализовать соответствующие методы. Эти методы могут наследоваться из суперкласса. Так, если класс подчиняется протоколу NSCopying, это действительно и для его подклассов (хотя и не означает, что эти методы правильно реализованы для данного подкласса).

Протокол позволяет определить методы, которые будут реализовать другие люди, использующие подкласс нашего класса. Например, вы можете определить протокол Drawing для своего класса GraphicObjcct; п нем можно определить методы paint (окраска), erase (стирание) и outline (контур).
```
@protocol Drawing
-(void) paint;
-(void) erase;
@optional
-(void) outline;
@end
```
Создав класс GraphicObject, вы не обязаны реализовать эти методы, однако вы должны указать методы, которые должен реализовать человек, создающий подкласс класса GraphicObject, чтобы соответствовать стандарту для создаваемых объектов рисования.

**Примечание.** Любые методы, которые указаны после директивы @optional директивы, не являются обязательными. Что человек, принявший протокол Drawing, не обязан реализовать метод outline, подчиняясь этому протоколу. (Вы можете вернуться к перечислению обязательных протоколов с помощью директивы @required в определении протокола.)

Таким образом, если вы создаете подкласс Rectangle класса GraphicObject и объявляете (то есть документируете), что ваш класс Rectangle подчиняется протоколу Drawing, пользователи данного класса будут знать, что они могут передавать экземплярам этого класса сообщения paint, erase и (возможно) outline.

**Примечание.** Это теория. Компилятор позволяет вам указать, что вы подчиняетесь протоколу, и выдает предупреждающие сообщения, только если вы не реализуете эти методы.

Отметим, что в протоколе нет ссылки ни на какие классы; это «бесклассовое» средство. Протоколу Drawing может подчиняться любой класс, не только подклассы GraphicObject.

Чтобы проверить, подчиняется ли объект какому-либо протоколу, можно использовать метод conformsToProtocol:. Например, вы хотите определить, подчиняется ли объект с именем currentObject протоколу Drawing, чтобы передавать этому объекту сообщения для рисования. Для этого можно написать следующее.
```
id currentObject;
...
if ([currentObject conformsToProtocol: @protocol (Drawing)] == YES)
{
    // Передача сообщений currentObject paint, erase и/или outline
    ...
}
```
Специальная директива @protocol, которая используется здесь, принимает имя протокола и создает объект типа Protocol, который используется как аргумент методом conformsToProtocol:.

Вы можете воспользоваться помощью компилятора, чтобы проверить согласование с вашими переменными, заключив имя протокола в угловые скобки после имени типа:
```
id <Drawing> currentObject;
```
Это указывает компилятору, что cunentObject будет содержать объекты, подчиняющиеся протоколу Drawing. Если присвоить currentObject объект статического типа, который не согласуется с протоколом Drawing (например, у вас есть несогласуюш ийся класс Square), то компилятор выдаст предупреждающее сообщение:
```
warning: class 'Square' does not implement the 'Drawing' protocol
(предупреждение: класс 'Square' не реализует протокол 'Drawing')
```
Здесь проверку выполняет компилятор, поэтому присваивание currentObject переменной типа id не приведет к выводу этого сообщения. Ддля объекта, хранящегося в переменной типа id, компилятор не сможет определить, подчиняется ли он протоколу Drawing.

В списке можно указать более одного протокола, если переменная будет содержать объект, подчиняющийся нескольким протоколам:
```
id <NSCopying, NSCoding> myDocument;
```
Определение протокола можно расширить. В следующем объявлении протокола указывается, что протокол Drawing3D принимает также протокол Drawing.
```
@protocol Drawing3D <Drawing>
```
Таким образом, класс, который принимает протокол Drawing3D, должен реализовать методы, перечисленные для этого протокола, а также методы из протокола Drawing.

И, наконец, категория тоже может принимать протокол, например:
```
@interface Fraction (Stuff) <NSCopying, NSCoding>
```
Здесь Fraction содержит категорию Stuff, которая принимает протоколы NSCopying и NSCoding.

Как и имена классов, имена протоколов должны быть уникальными.

### Неформальные протоколы
В литературе встречается понятие неформального, свободного (informal) протокола. На самом деле это категория, содержащая список группы методов, но не реализующая их. Все (или почти все) наследуется из одного корневого объекта, поэтому неформальные категории часто определяются для корневого класса. Иногда неформальные протоколы называют также абстрактными (abstract)
протоколами.

В header-файле <NSScriptWhoseTests.h> могут встретиться объявления методов, которые выглядят следующим образом:
```
@interface NSObject (NSComparisonMethods)

-(BOOL)isEqualTo:(id)object;
-(BOOL)isLessThanOrEqualTo:(id)object;
-{B00L}isLessThan:(id)object;
-<BOOL}isGreaterThanOrEqualTo:(id)object;
BOOLJisGreaterThan: (id)object;
-(BOOL)isNotEqualTo:(id)object;
-{BOOL)doesContain:(id)object;
-(B00L)isLike:(NSString *)object;
-(BOOL)isCaselnsensitiveLike:(NSString *)object;
@end
```
Здесь определяется категория с именем NSComparisonMethods для класса NSObject. В этом неформальном протоколе содержится список группы методов (в данном случае — девять), которые могут быть реализованы как часть этого протокола. Неформальный протокол — это фактически просто группа методов под определенным именем. Это полезно с точки зрения документирования и модульной организации методов.

Класс, где объявляется неформальный протокол, не реализует методы в самом этом классе. В подклассе, выбранном для реализации этих методов, требуется переобъявить их в секции interface, а также реализовать один или несколько из этих методов. В отличие от формальных протоколов, компилятор не оказывает никакой помощи с неформальными протоколами: здесь нет никакой концепции подчинения или проверки компилятором.

Если объект принимает какой-либо формальный протокол, этот объект должен подчиняться всем требуемым сообщениям в этом протоколе. Это можно сделать как на этапе выполнения (runtime), так и во время компиляции. Если объект принимает неформальный протокол, то он не обязан принять все методы данного протокола (в зависимости от самого протокола). Подчинение неформальному протоколу можно сделать обязательным на этапе выполнения (с помощью respondsToSelector:), но не во время компиляции.

**Примечание.** Описанную выше директиву @optional (она была добавлена в Objective-C 2.0) можно использовать вместо неформальных протоколов. Она используется в нескольких классах UIKit (UIK.it — составная часть структур Cocoa Touch framework).

## 11.3. Составные объекты
Вы уже знаете несколько способов, позволяющих расширить определение класса с помощью таких средств, как подклассы и категории. Еще один способ — это определение класса, который содержит один или несколько объектов из других классов. Объект из этого класса называется составным (composite) объектом, поскольку он составлен из других объектов.

В качестве примера рассмотрим класс Square (квадрат), который мы определили в главе 8. Он был определен как подкласс класса Rectangle (прямоугольник), поскольку квадрат это прямоугольник с равными сторонами. Подкласс, который мы определяем наследует все переменные экземпляра и методы родительского класса. В некоторых случаях это нежелательно. Метод setWidth:andHeight: (задание ширины и высоты) класса Rectangle наследуется классом Square, но реально не относится к квадрату (хотя действует правильно). Кроме того, создавая подкласс, мы должны обеспечить правильность работы наследуемых методов, поскольку пользователи этого подкласса будут иметь к ним доступ.

Вместо подкласса можно определить новый класс, который содержит в качестве одной из своих переменных экземпляра объект из класса, который вы хотите расширить. Затем нужно определить в новом классе только те методы, которые для него подходят. В примере с классом Square можно определить Square следующим образом.
```
@interface Square: NSObject
{
    Rectangle *rect;
}
-(int) setSide: (int) s;
-(int) side; (сторона)
•(int) area; (площадь)
-(int) perimeter; (периметр)
@end
```
Здесь определен класс Square с четырьмя методами. В отличие от версии с подклассом, которая дает непосредственный доступ к методам класса Rectangle (setWidth:, setHeight:, setWidthiandHeight:, width и height), этих методов нет в определении для Square. Это имеет смысл, поскольку не все методы подходят для работы с квадратами.

Если мы определяем класс Square таким способом, то он становится ответственным за выделение памяти для прямоугольника (rectangle), который содержит. Например, без заметающих методов оператор
```
Square *mySquare = [[Square alloc] init];
```
выделяет память для нового объекта типа Square, но не выделяет память для объекта типа Rectangle, хранящегося в его переменной экземпляра red.

Чтобы выполнить выделение памяти, требуется замещение метода init или добавление нового метода, например, initWithSide:. Этот метод может выделять память для переменной Rectangle red и задавать соответствующим образом сторону (side). Необходимо также заместить метод dealloc (как описано для класса Rectangle в главе 8), чтобы освободить память, используемую для Rectangle red, когда освобождается сам объект Square.

Определяя свои методы в классе Square, мы по-прежнему можем использовать методы класса Rectangle. Например, мы можем реализовать метод area следующим образом:
```
-(int) area
{
    return [rect area];
}
```
Реализацию остальных методов вы можете написать в качестве упражнения
(см. ниже упражнение 5).


## Упражнения
1. Выполните расширение категории MathOps из программы 11.1, чтобы дополнительно включить метод invert, который возвращает дробь (Fraction), обратную получателю.
2. Добавьте в класс Fraction категорию с именем Comparison. В этой категории добавьте два метода в соответствии со следующими объявлениями.
    ```
    -(BOOL) isEqualTo: (Fraction *) 1;
    -(int) compare: (Fraction *) f;
    ```
    Первый метод должен возвращать значение YES, если две дроби равны, и значение N0 в противном случае. Правильно сравнивайте дроби (например, при сравнении дробей 3/4 и 6/8 следует возвращать значение YES). Второй метод должен возвращать значение -1, если получатель меньше дроби, представляемой аргументом; возвращать 0, если две дроби равны; возвращать 1, если получатель больше дроби, представляемой аргументом.
3. Выполните расширение класса Fraction, добавив методы, которые подчиняются неформальному протоколу NSComparisonMethods, описанному з этой главе. Напишите реализацию первых шести методов из этого протокола `(isEqualTo:, isLessThanOrEqualTo:, isLessThan:, isGreaterThanOrEquaHo:, isGreaterThan:,isNotEqualTo:`) и выполните их тестирование.
4. Функции sin (),cos() и tan {) включены в стандартную библиотеку Standard Library (как и scant ()). Эти функции объявлены в header-файле <math.h>, который вы должны импортировать в программу с помощью строки
    ```
    #import <math.h>
    ```
    Эти функции можно использовать для вычисления синуса, косинуса и тангенса аргумента типа double, выраженного в радианах. Возвращаемый результат является значением с плавающей точкой двойной точности. Например, для вычисления синуса аргумента d, где d — угол, выраженный в радианах, можно использовать следующую строку:
    ```
    result = sin (d);
    ```
    Добавьте категорию с именем Trig в класс Calculator, определенный в главе 6. Включите в эту категорию методы для вычисления синуса, косинуса и тангенса в соответствии со следующими объявлениями.
    ```
    -(double) sin;
    -(double) cos;
    -(double) tan;
    ```
5. Напишите секцию implementation для Square и выполните тестирование программы для проверки ее методов, используя описание составных объектов из этой главы и следующую секцию interface,
    ```
    @interface Square: NSObject
    {
        Rectangle *rect;
    }
    -(Square*) initWithSide: (int) s;
    -(void) setSide: (int) s;
    -(int) side;
    -(int) area;
    -(int) perimeter;
    -(void) dealloc; // Замещающий метод для освобождения памяти объекта типа Rectangle
    @end
    ```