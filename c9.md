# Глава 9. Полиморфизм, динамический контроль типов и динамическое связывание
В этой главе описываются возможности языка Objective-C, которые делают его
столь мощным языком программирования и отличают его от некоторых объек­
тно-ориентированных языков, таких как C++. Это три ключевых концепции:
полиморфизм, динамический контроль типов и динамическое связывание.

Полиморфизм (polymorphism) позволяет разрабатывать программы таким обра­
зом, чтобы объекты из различных классов могли определять методы, которые
имеют одно и то же имя. Динамический контроль типов (dynamic typing) позво­
ляет откладывать определение класса, которому принадлежит объект, до вы­
полнения программы. Динамическое связывание (dynamic binding) позволяет от­
кладывать определение конкретного метода для вызова в объекте до начала
выполнения программы.

## 9.1. Полиморфизм: одно имя, различные классы
В программе 9.1 показан файл секции interface для класса Complex, который ис­
пользуется для представления в программе комплексных чисел.
Программа 9.1. Файл секции interface Complex.h
```
// файл секции interface для класса Complex
#import <Foundation/Foundation.h>
@interface Complex: NSObject
{
double real;
double imaginary;
}
@property double real, imaginary;
-(void) print;
-(void) setReal: (double) a andlmaginary: (double) b;
-(Complex *) add: (Complex *) f;
@end
```
В упражнении 6 главы 4 мы создали секцию implementation для этого клас­
са. Мы добавили дополнительный метод setReal:andlmaginary:, чтобы задавать ве­
щественную и мнимую части числа с помощью одного сообщения, а также
синтезировали методы доступа. Это показано в следующей программе.
Программа 9.1. Файл секции implementation Complex.m
```
// Файл секции implementation для класса Complex
#import "Complex.h"
@implementation Complex
@synthesize real, imaginary;
-(void) print
{
NSLog (@" %g + %gi", real, imaginary);
}
-(void) setReal: (double) a andlmaginary: (double) b
{
real = a;
imaginary = b;
}
-(Complex *) add: (Complex *) f
{
Complex *result = [[Complex alloc] init];
[result setReal: real + [f real]
andlmaginary: imaginary + [f imaginary]];
return result;
}
@end
```
Программа 9.1. Тестовая программа main.m
```
// Совместно используемые имена методов: полиморфизм
#import "Fraction.h
#import "Complex.h"
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Fraction *f1 = [[Fraction alloc] init];
Fraction *f2 = [[Fraction alloc] init];
Fraction *fracResult;
Complex *c1 = [[Complex alloc] init];
Complex *c2 = [[Complex alloc] init];
Complex *compResult;
[f1 setTo: 1 over: 10];
[f2 setTo: 2 over: 15];
[c1 setReal: 18.0 andlmaginary: 2.5];
[c2 setReal: -5.0 andlmaginary: 3.2];
// добавление и вывод 2 комплексных чисел
[d print]; NSLog (@" +"); [с2 print];
NSLog (@и............ ");
compResult = [d add: с2];
[compResult print];
NSLog (@"\n"J;
[c1 release];
[c2 release];
[compResult release];
// добавление и вывод 2 дробей
[f1 print]; NSLog (@" +"); [f2 print];
NSLog (<§>"-—");
fracResult = [f1 add: f2];
[fracResult print];
[f1 release];
[f2 release];
[fracResult release];
[pool drain];
return 0;
}
```
Вывод программы 9.1
```
18 + 2.5i
+
-5 + 3.2i
13 + 5.7i
1/10
+
2/15
7/30
```
Отметим, что оба класса, Fraction и Complex, содержат методы add: и print. Но
откуда система знает, какие методы нужно вызывать при выполнении следую­
щих выражений с сообщениями?
```
compResult = [d add: с2];
[compResult print];
```
Системе выполнения (runtime) Objective-C известно, что с1, получатель пер­
вого сообщения, является объектом класса Complex. Поэтому выбирается метод
add:, определенный для класса Complex. Система выполнения Objective-C оп­
ределяет также, что compResult является объектом класса Complex, поэтому она
выбирает метод print, определенный в классе Complex, чтобы вывести результат
сложения. То же самое относится к следующим выражениям с сообщениями.
```
fracResult = [f1 add: f2];
[fracResult print];
```
Примечание. Система всегда содержит информацию о классе, которому принад­
лежит объект. Это позволяет ей принимать нужные решения во время выполне­
ния, не во время компиляции. Подробнее об этом рассказывается в главе 13.
Выбор методов из класса Fraction выполняется при оценке выражения с со­
общением в зависимости от класса П и fracResult.

Возможность использования одного имени из различных классов называ­
ется полиморфизмом. Полиморфизм позволяет вам разрабатывать набор клас­
сов с одинаковым именем метода. В определение каждого класса включается
код, необходимый для ответа на вызов данного определенного метода, и это
делает его независимым от определений в других классах. Это позволяет также
добавлять новые классы, которые могут отвечать на вызов методов с тем же
именем.

**Примечание.** Именно классы Fraction и Complex (а не тестовая программа) должны
предусматривать освобождение памяти, занимаемой результатами их методов
add:. На самом деле эти объекты должны освобождаться автоматически
(autorelease). Подробнее об этом рассказывается в главе 18.

## 9.2. Динамическое связывание и тип id
В главе 4 уже говорилось, что тип данных id является обобщенным типом объек­
та. Это означает, что id используется для хранения объектов, которые принад­
лежат любому классу. Он используется для хранения в переменной различных
типов объектов. Рассмотрим программу 9.2 и ее вывод.
```
// Пример динамического контроля типов и динамического связывания
#import Traction.h"
#import "Complex.h"
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
id dataValue;
Fraction *f1 = [[Fraction alloc] init];
Complex *c1 = [[Complex alloc] init];
[f1 setTo: 2 over: 5];
[c1 setReal: 10.0 andlmaginary: 2.5];
// в первый раз dataValue присваивается дробь (fraction)
dataValue = f1;
[dataValue print];
// теперь dataValue присваивается комплексное число (complex)
dataValue = c1;
[dataValue print];
[c1 release];
[f1 release];
[pool drain];
return 0;
}
```
Вывод программы 9.2
```
2/5
10 + 2.5i
```
Переменная dataValue объявляется как объект типа id, поэтому dataValue можно
использовать для хранения в программе объекта любого типа. Отметим, что в
строке объявления не используется «звездочка»:
```
id dataValue;
```
Объекту f 1 типа Fraction присваивается дробь 2/5, переменной с1 типа Complex
присваивается значение (10 + 2.5i). Оператор
```
dataValue = f 1;
```
сохраняет f1 в dataValue. Вы можете вызвать с dataValue любой из методов, допус­
тимых в объекте типа Fraction, хотя dataValue имеет тип id, а не Fraction. Но как сис­
тема определяет, какой метод нужно вызвать, если в dataValue можно сохранять
объект любого типа? Если система встречает выражение с сообщением
```
[dataValue print];
```
откуда она знает, какой метод print нужно вызвать? Ведь методы print определены
и в классе Fraction, и в классе Complex.

Как уже говорилось, система Objective-C всегда следит за классом, которо­
му принадлежит объект. Это также определяется концепциями динамического
контроля типов и динамического связывания: система принимает решение о
классе объекта и о методе для его динамического вызова во время выполнения,
а не во время компиляции.

Поэтому во время выполнения программы, прежде чем передать dataValue
сообщение print, система проверяет класс объекта, хранящегося в dataValue. В слу­
чае программы 9.2 эта переменная содержит объект типа Fraction, поэтому ис­
пользуется метод print, определенный в классе Fraction.

Во втором случае а с1 типа Complex присваивается dataValue. Затем выполняет­
ся следующее выражение с сообщением:
```
[dataValue print];
```
Поскольку теперь dataValue содержит объект, принадлежащий классу Complex,
для выполнения выбирается метод print из этого класса.

Это простой пример, но вы можете распространить эту концепцию на более
сложные приложения. В сочетании с концепцией полиморфизма динамичес­
кое связывание и динамический контроль типов позволяют легко писать коды,
которые передают одинаковое сообщение объектам из различных классов.

Например, метод draw можно использовать для рисования графических
объектов на экране. У вас могут быть различные методы draw, определенные для
каждого из ваших графических объектов, таких как тексты, окружности, прямоугольники, окна и т.д. Если графический объект, который нужно нарисовать,
сохраняется, например, в переменной типа id с именем currentObject, то его мож­
но нарисовать на экране, просто передав ему сообщение draw:
```
[currentObject draw];
```
Вы можете сначала проверить, отвечает ли на метод draw объект, хранящий­
ся в currentObject. Ниже вы увидите, как это делать.

## 9.3. Проверка на этапе компиляции и проверка на этапе выполнения
Поскольку тип объекта, хранящегося в переменной id, во время компиляции
может быть неизвестен, некоторые проверки откладываются до выполнения
программы (runtime). Рассмотрим следующую последовательность кодов.
```
Fraction *f1 = [[Fraction alloc] init];
[f1 setReal: 10.0 andlmaginary: 2.5];
```
Поскольку метод setReakandlmaginary: применяется к комплексным числам, а
не к дробям, при компиляции программы, содержащей эти строки, появится
предупреждающее сообщение.
```
ргодЗ.т: In function 'main':(B функции 'main')
prog3.m:13: warning: ’Fraction' does not respond to 'setReakandlmaginary:'
(предупреждение: объект типа 'Fraction' не отвечает на 'setReakandlmaginary:')
```
Компилятору Objective-C известно, что И является объектом класса Fraction,
поскольку он был объявлен именно так. При появлении выражения с сообще­
нием
```
[Н setReal: 10.0 andlmaginary: 2.5];
```
ему стало известно, что класс Fraction не содержит метода setReal:andlmaginary: (и не
наследует его). Поэтому компилятор выдает предупреждающее сообщение.

Теперь рассмотрим следующую последовательность кодов.
```
id dataValue = [[Fraction alloc] init];
[dataValue setReal: 10.0 andlmaginary: 2.5];
```
Компилятор не выводит предупреждающего сообщения, поскольку во вре­
мя обработки исходного файла ему неизвестно, какой тип объекта сохраняется
в dataValue.

Сообщение об ошибке не появится, пока вы не запустите программу, содержа­
щую эти строки. Сообщение об ошибке может выглядеть следующим образом.
```
objc: Fraction: does not recognize selector -setReakandlmaginary:
(не распознается селектор -setReakandlmaginary)
dynamic3: received signal: Abort trap
(получен сигнал: аварийное прерывание)
When attempting to execute the expression
(При попытке выполнить выражение)
[dataValue setReal: 10.0 and I maginary: 2.5];
```
Система runtime сначала проверяет тип объекта, хранящегося внутри dataValue.
Поскольку dataValue содержит дробь (объект Fraction), система runtime проверяет,
определен ли метод setReal:andlmaginary: для класса Fraction. Поскольку это не так,
выдается сообщение, и выполнение программы прекращается.

## 9.4. Тип данных id и статический контроль типов
Если тип данных id можно использовать для хранения любого объекта, так по­
чему бы нам не объявлять все объекты с типом id? Этого не следует делать по
нескольким причинам.

Во-первых, определяя переменную как объект из определенного класса, мы
используем так называемый статический контроль типов (static typing). Слово
статический означает, что переменная всегда используется для хранения объек­
тов из определенного класса, поэтому класс объекта, хранящегося в этом типе,
заранее определен, то есть является статическим. При использовании стати­
ческого контроля типов компилятор обеспечивает согласованное использова­
ние этой переменной во всей программе. Компилятор может проверить, опре­
делен ли (или унаследован) метод, применяемый к объекту, и если нет, то
выводит предупреждающее сообщение. Таким образом, если вы объявляете в
своей программе переменную класса Rectangle с именем myRect, то компилятор
проверяет, все ли методы, которые вы вызываете для myRect, определены в клас­
се Rectangle или наследуются из его суперкласса.

**Примечание.** Определенные приемы позволяют вызывать методы, который ука­
зываются самой переменной, в таком случае компилятор не может выполнить
проверку.

Но если проверка будет выполнена во время выполнения, почему вас дол­
жен интересовать статический контроль типов? Дело в том, что лучше выявить
ошибки на этапе компиляции программы, чем на этапе выполнения. Если про­
грамму будет выполнять другой человек, вы не сможете увидеть ошибку. Это
означает, что если программа введена в эксплуатацию, ничего не подозреваю­
щий пользователь может столкнуться с ошибкой, при которой указывается, что
определенный объект не распознает некоторый метод.

Еще одним доводом к применению статического контроля типов является
то, что он делает ваши программы более удобными для чтения. Рассмотрим
объявление
```
id f1;
```
и сравним его с
```
Fraction *f1;
```
Конечно, второе объявление лучше, поскольку в нем указывается предпо­
лагаемое использование переменной И. Сочетание статического контроля ти­
пов и осмысленных имен переменных позволяет делать программы самодоку-
ментируемыми.

### Типы аргументов и возвращаемых значений при динамическом контроле типов
Если для вызова метода используется динамический контроль типов, соблю­
дайте следующее правило. Если методы с одинаковым именем реализованы в
нескольких классах, каждый метод должен быть согласован с типом каждого
аргумента и типом возвращаемого значения, чтобы компилятор мог генериро­
вать правильный код для выражений с сообщениями.

Компилятор выполняет проверку на согласованность в объявлениях каж­
дого класса, которые он встречает. Если один или несколько методов не согла­
суются с типом аргумента или возвращаемого значения, компилятор выводит
предупреждающее сообщение. Например, оба класса, Fraction и Complex, содер­
жат метод add:, но класс Fraction принимает в качестве аргумента и возвращает
объект типа Fraction, а класс Complex - объект типа Complex. Если trad и myFract -
объекты типа Fraction, a compl и myComplex — объекты типа Complex, то определения
```
result = [myFract add: trad];
```
и
```
result = [myComplex add: compl];
```
не вызовут проблемы. В обоих случаях получатель сообщения доступен для ста­
тического контроля типов и компилятор может проверить согласованность при
использовании метода, поскольку он определен в классе получателя.
Если dataValuel и dataValue2 — переменные типа id, то выражение
```
result = [dataValuel add: dataValue2];
```
заставляет компилятор генерировать код для передачи данного аргумента ме­
тоду add: и обработки его возвращаемого значения, делая некоторые предполо­
жения.

Во время выполнения система runtime Objective-C проверит конкретный
класс объекта, хранящегося в dataValuel, и выберет метод из подходящего класса
для выполнения. Однако в более общем случае компилятор может генериро­
вать неверный код для передачи методу аргументов или обработки его возвра­
щаемого значения. Это может произойти, например, если один метод принял в
качестве аргумента какой-либо объект, а другой — значение с плавающей точ­
кой, или один метод возвратил объект, а другой — целое значение. Если методы
отличаются только типом объекта (например, метод add: класса Fraction прини­
мает в качестве аргумента и возвращает объект типа Fraction, а метод add: класса
Complex принимает в качестве аргумента и возвращает объект типа Complex), то
компилятор же будет генерировать правильный код, поскольку адреса памяти
(то есть указатели) в обоих случаях будут передаваться как ссылки на объекты.

## 9.5. Как задавать вопросы о классах
При работе с переменными, которые могут содержать объекты из различных
классов, вам могут потребоваться ответы на вопросы следующего рода.
* Является ли данный объект прямоугольником (rectangle)?
* Поддерживает ли данный объект метод print?
* Является ли данный объект членом класса Graphics или одного из его потомков?

Ответы на такие вопросы можно использовать, чтобы выполнять разные
последовательности кода, чтобы избежать возникновения ошибок или прове­
рить целостность программы во время ее выполнения.

В таблице 9.1 приводится сводка основных методов, поддерживаемых клас­
сом Object. В таблице объект-класс (object-class) — это объект, получаемый для
заданного класса (обычно он генерируется с помощью метода class), а с е л е к т о р
(s e le c to r ) — это значение типа SEL (обычно создается с помощью директивы
@selector).

Табл. 9.1. Методы для работы с динамическими типами
```
Метод Вопрос или действие
-(BOOL) isKindOfClass: объект-класс Является ли объект членом о б ъ е к т а -к л а с с а
или дочернего класса?
-(BOOL) isMemberOfClass: объект-класс Является ли объект членом о б ъ е к т а -
к л а с с а ?
-(BOOL) respondsToSelector:
селектор
+(B00L) instancesRespondToSelector:
селектор
+(B00L)isSubclass0fClass: объект-класс
Может ли объект отвечать на метод, указан­
ный с е л е к т о р о м ?
Могут ли экземпляры указанного класса
отвечать на с е л е к т о р ?
Является ли объект подклассом указанно­
го класса?
-(id) performSelector: selector
-(id) performSelector:
селектор withObject: объект
-(id) performSelector:
селектор withObject: объект 1 withObject:
объект2
Применение метода, указанного селектором.
Применение метода, указанного селектором , с передачей аргумента о б ъ е к т .
Применение метода, указанного селектором , с передачей аргументов объект1 и объект2.
```
Имеются и другие методы. Один из них позволяет спрашивать, согласуется
ли объект с определенным протоколом (см. главу 11). Другие позволяют спра­
шивать о динамически разрешаемых методах (в этой книге они не рассматри­
ваются).

Чтобы создать объект-класс из имени класса или другого объекта, нужно
передать ему сообщение class. Например, чтобы получить объект-класс из класса
с именем Square, напишите строку
```
[Square class]
```
Если mySquare является экземпляром объекта типа Square, то для получения
его объекта-класса нужно написать
```
[mySquare class]
```
Чтобы проверить, являются ли объекты, хранящиеся в переменных obj1 и
obj2, экземплярами одного класса, нужно написать строку
```
if ([obj1 class] == [obj2 class])
```
Чтобы убедиться, что объект myFract является членом класса Fraction, нужно
проверить результат выражения
```
[myFract isMemberOfClass: [Fraction class]]
```
Чтобы генерировать один из так называемых селекторов, которые приво­
дятся в таблице 9.1, нужно применить директиву @selector к имени метода. В
следующей строке создается значение типа SEL для метода с именем alloc, кото­
рый является наследуемым методом из класса NSObject.
```
(@selector (alloc)
```
В следующем выражении создается селектор для метода setTo:over:, который
мы реализовали в классе Fraction (вспомните о двоеточияхв именах методов).
```
(@selector (setTo:over:)
```
Чтобы убедиться, что экземпляр класса Fraction отвечает на метод setTo:over:,
можно проверить возвращаемое значение из следующего выражения.
```
[Fraction instancesRespondToSelector: (@selector (setTo:over:)]
```
Эта проверка охватывает и наследуемые, и непосредственно определенные
в определении класса методы.

Метод performSelector: и его вариации (не показанные в таблице 9.1) позволяют
передавать объекту сообщение, где сообщение может быть селектором, храня­
щимся внутри переменной. Рассмотрим следующую последовательность кода.
```
SEL action;
id graphicObject;
action = @selector (draw);
[graphicObject performSelector: action];
```
Метод, указанный переменной action типа SEL, передается графическому
объекту, который хранится в graphicObject. Предполагается, что действие (action)
может изменяться во время выполнения программы в зависимости от ввода
пользователя, несмотря на указанное действие draw. Чтобы убедиться, что объект
может ответить на данное действие, нужно использовать, например, следую­
щую последовательность.
```
if ([graphicObject respondsToSelector: action] == YES)
[graphicObject perform: action]
else
// здесь должен быть код для обработки ошибок
```

**Примечание.** Вы можете отлавливать ошибку, переопределив метод
doesNotRecognize:. Этот метод вызывается, когда классу передано нераспознавае­
мое сообщение и в качестве аргумента передан нераспознаваемый селектор.
Можно применять и другие стратегии. Например, с помощью метода forward::
можно перенаправлять сообщение для обработки. Всегда можно передавать
метод и перехватывать возникшую исключительную ситуацию. Мы рассмот­
рим этот способ чуть позже.

В программе 9.3 задаются некоторые вопросы о классах Square и Rectangle, оп­
ределенных в главе 8. Постарайтесь предсказать результаты этой программы.
```
#import "Square.h"
int main (int argc, char *argv[])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Square *mySquare = [[Square alloc] init];
// Проверка с помощью isMemberOf:
if ( [mySquare isMemberOfClass: [Square class]] == YES )
NSLog (@"mySquare is a member of Square class");
if ( [mySquare isMemberOfClass: [Rectangle class]] == YES )
NSLog (@"mySquare is a member of Rectangle class");
if ( [mySquare isMemberOfClass: [NSObject class]] == YES )

NSLog (@"mySquare is a member of NSObject class");
II Проверка с помощью isKindOf:
if ( [mySquare isKindOfClass: [Square class]] == YES )
NSLog (@"mySquare is a kind of Square");
if ( [mySquare isKindOfClass: [Rectangle class]] == YES )
NSLog (@"mySquare is a kind of Rectangle");
if ( [mySquare isKindOfClass: [NSObject class]] == YES )
NSLog (@"mySquare is a kind of NSObject");
// Проверка с помощью respondsTo:
if ( [mySquare respondsToSelector: @selector (setSide:)] == YES )
NSLog (@"mySquare responds to setSide: method");
if ( [mySquare respondsToSelector: @selector (setWidth:andHeight:)] == YES )
NSLog (@"mySquare responds to setWidth:andHeight: method");
if ( [Square respondsToSelector: @selector (alloc)] == YES )
NSLog (@"Square class responds to alloc method");
// Проверка с помощью instancesRespondTo:
if ([Rectangle instancesRespondToSelector: @selector (setSide:)] == YES)
NSLog (@"lnstances of Rectangle respond to setSide: method");
if ([Square instancesRespondToSelector: @selector (setSide:)] == YES)
NSLog (@"lnstances of Square respond to setSide: method");
if ([Square isSubclassOfClass: [Rectangle class]] == YES)
NSLog (@"Square is a subclass of a rectangle");
[mySquare release];
[pool drain];
return 0;
}
```
Эта программа должна быть создана с файлами секции implementation для
классов Square, Rectangle и XYPoint, которые были рассмотрены в главе 8.

Вывод программы 9.3
```
mySquare is a member of Square class (mySquare является членом класса Square)
mySquare is a kind of Square (mySquare происходит из Square)
mySquare is a kind of Rectangle
mySquare is a kind of NSObject
mySquare responds to setSide: method (mySquare отвечает на метод setSide:)
mySquare responds to setWidthiandHeight: method
Square class responds to alloc method (Square отвечает на метод alios)
Instances of Square respond to setSide: method (Экземпляры mySquare отвечают на
метод setSide:)
Square is a subclass of a rectangle (Square - это подкласс класса Rectangle)
```
Вывод программы 9.3 вполне понятен. isMemberOfClass: прозеряет непосред­
ственное членство в классе, a isKindOfClass: проверяет членство в иерархии на­
следования. mySquare является членом класса Square и «происходит» из Square,
Rectangle и NSObject, поскольку входи т в иерархию этою класса (очевидно, что
все объекты должны возвращать значение YES для проверки isKindOf: по классу
NSObject, если только вы не определили новый корневой объект).

В проверке
```
if ( [Square respondsTo: @selector (alloc)] == YES )
```
определяется, отвечает ли класс Square на метод класса alloc. Это так, поскольку
он унаследован из корневого объекта NSObject. Вы всегда можете использовать
непосредственно имя класса в качестве получателя в выражении для сообще­
ния и не обязаны включать
```
[Square class]
```
в предыдущее выражение (хотя могли бы это сделать).

Но это единственное место, где можно без этого обойтись. В других местах
для получения объекта-класса нужно обязательно применять метод class.

## 9.6. Обработка исключительных ситуаций с помощью @try
Практика надежного программирования обязывает предусматривать пробле­
мы, которые могут возникнуть в программе. Это можно делать, проверяя со­
стояния, которые могут вызвать аварийное завершение программы, и включая
обработку этих ситуаций, например, выводя сообщение и корректно завершая
программу. Например, выше в этой главе было показано, как проверить, отве­
чает ли объект на определенное сообщение. Эта проверка позволяет избежать
отправки нераспознаваемого сообщения. Обычно при попытке отправки не­
распознаваемою сообщения профамма сразу прекращает свою работу, выда­
вая гак называемую исключительную ситуацию, или исключение (exception).

Рассмотрим программу 9.4. В определении класса Fraction у нас не было ме­
тода с именем noSuchMethod («нет такого метода»). При компиляции этой про­
граммы вы получите из-за этого предупреждающие сообщения.
```
#import Traction.h"
int main (int arge, char *argv [])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Fraction *f = [[Fraction alloc] init];
[f noSuchMethod];
NSLog (@"Execution continues!'’);
[f release];
[pool drain];
return 0;
}
```
Несмотря на эти предупреждающие сообщения, вы можете попытаться про­
должить работу и выполнить программу. В этом случае программа будет ава­
рийно завершена с выводом следующих сообщений об ошибках.
Вывод программы 9.4
```
-[Fraction noSuchMethod]: unrecognized selector sent to instance 0x103280
(... нераспознанный селектор передан экземпляру)
*** Terminating арр due to uncaught exception ’NSInvalidArgumentException',
(Прекращение работы приложения из-за необработанного исключения)
reason: ’*** -[Fraction noSuchMethod]: unrecognized selector sent
to instance 0x103280’
(причина: ... нераспознанный селектор передан экземпляру)
Stack: (
2482717003,
2498756859,
2482746186,
2482739532,
2482739730
)
Trace/BPT trap
```
Чтобы избежать аварийного завершения программы, можно поместить оди н
или несколько операторов в блоке операторов, имеющем следующий формат.
```
@try {
оператор
оператор
}
@catch (NSException *exception) {
оператор
оператор
)
```
Выполнение программы в блоке @try происходит как обычно. Однако если
один из операторов в этом блоке выдает исключение, работа программы нс пре­
кращается, а управление передастся в блок @catch, где продолжается ее выпол­
нение. Внутри этого блока можно обрабатывать исключение. Последователь­
ностью действий в этом случае может быть вывод сообщения об ошибке, очистка
и завершение работы программы.

В профамме 9.5 показана обработка исключения. Затем приводится вывод
программы.
```
#import "Fraction.h"
int main {int arge, char *argv [])
{
NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
Fraction *f = [[Fraction alloc] init];
@try {
[f noSuchMethod];
}
@catch (NSException *exception) {
NSLog(@"Caught %@%@", [exception name], [exception reason]);
}
NSLog (@"Execution continues!");
[f release];
[pool drain];
return 0;
}
```
Вывод программы 9.5
```
*** -[Fraction noSuchMethod]: unrecognized selector sent to instance
0x103280
Caught NSInvalidArgumentException: *** -[Fraction noSuchMethod]:
unrecognized selector sent to instance 0x103280
Execution continues! (Выполнение продолжается!)
```
Если возникает исключительная ситуация, выполняется блок @catch. Объект
NSExceptton, который содержит информацию об исключении, передастся в этот
блок как аргумент. Мметод name считывает имя исключения, а метод reason ука­
зывает причину (которую система runtime раньше выводила автоматически).
После выполнения последнего оператора в блоке @catch (здесь только один
оператор) программа продолжает выполнение, начиная с оператора, который
непосредственно следует за этим блоком. В данном случае мы выполняем вы­
зов NSLog, чтобы подтвердить, что выполнение не было прекращено.

Это очень простой пример, показывающий, как перехватывать исключения
в профамме. Можно также использовать блок @finally, чтобы включить код, вы­
полняемый независимо от возникновения исключительной ситуации в каком-
либо операторе блока @try.

Директива @throw позволяет создавать ваше собственное исключение. Ее
можно использовать для создания конкретного исключения или внугри блока
@catch для создания той же исключительной ситуации, которая вызвала пере­
ход в этот блок:
```
@throw;
```
Это может потребоваться после вашей собственной обработки исключения
(например, после выполнения операций очистки). После этого вы можете пе­
редать системе остальную часть работы. И, наконец, у вас может быть несколь­
ко блоков @catch, которые следуют в определенном порядке для перехвата и
обработки исключений различного типа.

## Упражнения
1. Что произойдет, если вставить выражение с сообщением
    ```
    [compResult reduce];
    ```
    в профамму 9.1 после того, как выполнено сложение (но до выполнения release для compResult)? Попробуйте и посмотрите, что получится.
2. Можно ли переменной dataValue типа id (определенной в профамме 9.2) присвоить объект класса Rectangle в соответствии с его определением в главе 8? Иначе говоря, является ли допустимым оператор
    ```
    dataValue = [[Rectangle alloc] init];
    ```
    Почему?
3. Добавьте метод print к классу XYPoint, определенному в главе 8. Он должен выводить точку в формате (х,у). Затем внесите изменения в программу 9.2, чтобы включить объект типа XYPoint. Эта модифицированная программа должна создавать объект типа XYPoint, задавать его значение, присваивать его переменной dataValue типа id и затем выводить его значение.
4. Вспомните, что говорилось в этой главе о типах ар1ументов и возвращаемых значений, и модифицируйте методы add: в классах Fraction и Complex, чтобы принимать и возвращать объекты типа id. Затем напишите программу, которая включает следующую последовательность кода.
    ```
    result = [dataValuel add: dataValue2];
    [result print];
    ```
    Здесь result, dataValuel и dataValue2 — это объекты типа id. He забудьте задать образом значения dataValuel и dataValue2 в программе и освободить (release) все объекты, прежде чем завершить программу.

    **Примечание.** Вам придется изменить имна этих методов. Системный класс NSObjectController тоже содержит метод add:. Как говорилось выше в разделе «Типы аргументов и возвращаемых значений при динамическом контроле типов», в случае существования нескольких методов с одним именем в разных классах, если на этапе компиляции тип получателя неизвестен, компилятор выполняет проверку согласованности типов аргументов и возвращаемого значения с методами, имеющими одинаковые имена.
5. Используя определения классов Fraction и Complex, заданные в этой книге, и определения
    ```
    Fraction *fraction = [[Fraction alloc] init];
    Complex *complex = [[Complex alloc] init];
    id number = [[Complex alloc] init];
    ```
    определите возвращаемое значение для следующих выражений с сообщениями. Затем введите их в программу, чтобы проверить результаты.
    ```
    [fraction isMemberOfClass: [Complex class]];
    [complex isMemberOfClass: [NSObject class]];
    [complex isKindOfClass: [NSObject class]];
    [fraction isKindOfClass: [Fraction class]];
    [fraction respondsToSelector: @selector (print)];
    [complex respondsToSelector: @selector (print)];
    [Fraction instancesRespondToSelector: @selector (print)];
    [number respondsToSelector: @selector (print)];
    [number isKindOfClass: [Complex class]];
    [number respondsToSelector: @selector (release)];
    [[number class] respondsToSelector: @selector (alloc)];
    ```